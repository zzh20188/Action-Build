diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 60af93c04b45..5ba590235a8c 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -6,6 +6,7 @@ CONFIG_HIGH_RES_TIMERS=y
 CONFIG_BPF_SYSCALL=y
 CONFIG_BPF_JIT=y
 CONFIG_PREEMPT=y
+CONFIG_HMBIRD_SCHED=y
 CONFIG_IRQ_TIME_ACCOUNTING=y
 CONFIG_BSD_PROCESS_ACCT=y
 CONFIG_BSD_PROCESS_ACCT_V3=y
diff --git a/arch/arm64/configs/gki_defconfig b/arch/arm64/configs/gki_defconfig
index bebb76e87e97..a0c91fd40bf6 100644
--- a/arch/arm64/configs/gki_defconfig
+++ b/arch/arm64/configs/gki_defconfig
@@ -10,6 +10,7 @@ CONFIG_BPF_JIT_ALWAYS_ON=y
 # CONFIG_BPF_UNPRIV_DEFAULT_OFF is not set
 CONFIG_BPF_LSM=y
 CONFIG_PREEMPT=y
+CONFIG_HMBIRD_SCHED=y
 CONFIG_IRQ_TIME_ACCOUNTING=y
 CONFIG_TASKSTATS=y
 CONFIG_TASK_DELAY_ACCT=y
diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 4bd028fa7500..5825ce9d6d7b 100755
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -510,6 +510,9 @@ static int msm_drm_init(struct device *dev, const struct drm_driver *drv)
 		}
 
 		sched_set_fifo(ev_thread->worker->task);
+#ifdef CONFIG_HMBIRD_SCHED
+		hmbird_set_sched_prop(ev_thread->worker->task, SCHED_PROP_DEADLINE_LEVEL3);
+#endif
 	}
 
 	ret = drm_vblank_init(ddev, priv->num_crtcs);
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index 63029bc7c9dd..c0fee44f5417 100755
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -131,6 +131,7 @@
 	*(__dl_sched_class)			\
 	*(__rt_sched_class)			\
 	*(__fair_sched_class)			\
+	*(__hmbird_sched_class)			\
 	*(__idle_sched_class)			\
 	__sched_class_lowest = .;
 
diff --git a/include/linux/sched.h b/include/linux/sched.h
index c2fb5603e211..39c797c5cc75 100755
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -73,6 +73,9 @@ struct task_delay_info;
 struct task_group;
 struct user_event_mm;
 
+#ifdef CONFIG_HMBIRD_SCHED
+#include <linux/sched/hmbird.h>
+#endif
 
 /*
  * Task state bitmask. NOTE! These bits are also
@@ -1921,6 +1924,91 @@ static inline int task_nice(const struct task_struct *p)
 	return PRIO_TO_NICE((p)->static_prio);
 }
 
+#ifdef CONFIG_HMBIRD_SCHED
+static inline bool task_is_top_task(struct task_struct *p)
+{
+	return (((struct hmbird_entity *)(p->android_oem_data1[HMBIRD_TS_IDX]))
+		->top_task_prop & TOP_TASK_BITS_MASK);
+}
+
+static inline int get_top_task_prop(struct task_struct *p)
+{
+	return get_hmbird_ts(p)->top_task_prop;
+}
+
+static inline int set_top_task_prop(struct task_struct *p, u64 set, u64 clear)
+{
+	if (set)
+		get_hmbird_ts(p)->top_task_prop |= set;
+	if (clear)
+		get_hmbird_ts(p)->top_task_prop &= ~clear;
+	return 0;
+}
+
+static inline void reset_top_task_prop(struct task_struct *p)
+{
+	get_hmbird_ts(p)->top_task_prop = 0;
+}
+
+static inline int hmbird_set_sched_prop(struct task_struct *p, unsigned long sp)
+{
+	struct hmbird_entity *entity = get_hmbird_ts(p);
+
+	if (entity) {
+		entity->sched_prop = sp;
+	}
+	return 0;
+}
+
+static inline unsigned long hmbird_get_sched_prop(struct task_struct *p)
+{
+	struct hmbird_entity *entity = get_hmbird_ts(p);
+
+	if (entity)
+		return entity->sched_prop;
+	else
+		return 0;
+}
+
+static inline void hmbird_set_dsq_id(struct task_struct *p, unsigned long dsq)
+{
+	unsigned long new_dsq;
+	struct hmbird_entity *entity = get_hmbird_ts(p);
+
+	if (entity) {
+		new_dsq = (entity->sched_prop & ~SCHED_PROP_DEADLINE_MASK) | dsq;
+		entity->sched_prop = new_dsq;
+	}
+}
+
+static inline unsigned long hmbird_get_dsq_id(struct task_struct *p)
+{
+	struct hmbird_entity *entity = get_hmbird_ts(p);
+
+	if (entity)
+		return (entity->sched_prop & SCHED_PROP_DEADLINE_MASK);
+	else
+		return 0;
+}
+
+static inline void hmbird_set_dsq_sync_ux(struct task_struct *p, int val)
+{
+	struct hmbird_entity *entity = get_hmbird_ts(p);
+
+	if (entity)
+		entity->dsq_sync_ux = val;
+}
+
+static inline int hmbird_get_dsq_sync_ux(struct task_struct *p)
+{
+	struct hmbird_entity *entity = get_hmbird_ts(p);
+
+	if (entity)
+		return entity->dsq_sync_ux;
+	else
+		return 0;
+}
+#endif
 
 extern int can_nice(const struct task_struct *p, const int nice);
 extern int task_curr(const struct task_struct *p);
diff --git a/include/linux/sched/hmbird.h b/include/linux/sched/hmbird.h
new file mode 100755
index 000000000000..3c7861e37ade
--- /dev/null
+++ b/include/linux/sched/hmbird.h
@@ -0,0 +1,381 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * HMBIRD scheduler class: Documentation/scheduler/hmbird.rst
+ *
+ * Copyright (c) 2024 OPlus.
+ * Copyright (c) 2024 Dao Huang
+ * Copyright (c) 2024 Yuxing Wang
+ * Copyright (c) 2024 Taiyu Li
+ */
+#ifndef _LINUX_SCHED_HMBIRD_H
+#define _LINUX_SCHED_HMBIRD_H
+
+#define HMBIRD_TS_IDX 1
+#define HMBIRD_OPS_IDX 14
+#define HMBIRD_RQ_IDX 15
+
+#define get_hmbird_ts(p)	\
+	((struct hmbird_entity *)(p->android_oem_data1[HMBIRD_TS_IDX]))
+
+#define get_hmbird_rq(rq)	\
+	((struct hmbird_rq *)(rq->android_oem_data1[HMBIRD_RQ_IDX]))
+
+#define get_hmbird_ops(rq)	\
+	((struct hmbird_ops *)(rq->android_oem_data1[HMBIRD_OPS_IDX]))
+
+#define SCHED_PROP_DEADLINE_MASK (0xFF) /* deadline for ext sched class */
+/*
+ * Every task has a DEADLINE_LEVEL which stands for
+ * max schedule latency this task can afford. LEVEL1~5
+ * for user-aware tasks, LEVEL6~9 for other tasks.
+ */
+#define SCHED_PROP_DEADLINE_LEVEL0 (0)
+#define SCHED_PROP_DEADLINE_LEVEL1 (1)
+#define SCHED_PROP_DEADLINE_LEVEL2 (2)
+#define SCHED_PROP_DEADLINE_LEVEL3 (3)
+#define SCHED_PROP_DEADLINE_LEVEL4 (4)
+#define SCHED_PROP_DEADLINE_LEVEL5 (5)
+#define SCHED_PROP_DEADLINE_LEVEL6 (6)
+#define SCHED_PROP_DEADLINE_LEVEL7 (7)
+#define SCHED_PROP_DEADLINE_LEVEL8 (8)
+#define SCHED_PROP_DEADLINE_LEVEL9 (9)
+/*
+ * Distinguish tasks into periodical tasks which requires
+ * low schedule latency and non-periodical tasks which are
+ * not sensitive to schedule latency.
+ */
+#define SCHED_HMBIRD_DSQ_TYPE_PERIOD            (0) /* period dsq of hmbird */
+#define SCHED_HMBIRD_DSQ_TYPE_NON_PERIOD        (1) /* non period dsq of hmbird */
+
+#define TOP_TASK_BITS_MASK      (0xFF)
+#define TOP_TASK_BITS           (8)
+#include <linux/llist.h>
+
+extern atomic_t non_hmbird_task;
+extern atomic_t __hmbird_ops_enabled;
+#define hmbird_enabled()           atomic_read(&__hmbird_ops_enabled)
+#define MAX_GLOBAL_DSQS (10)
+
+enum hmbird_consts {
+	HMBIRD_SLICE_DFL		= 1 * NSEC_PER_MSEC,
+	HMBIRD_SLICE_ISO		= 8 * HMBIRD_SLICE_DFL,
+	HMBIRD_SLICE_INF		= U64_MAX,	/* infinite, implies nohz */
+};
+
+/*
+ * DSQ (dispatch queue) IDs are 64bit of the format:
+ *
+ *   Bits: [63] [62 ..  0]
+ *         [ B] [   ID   ]
+ *
+ *    B: 1 for IDs for built-in DSQs, 0 for ops-created user DSQs
+ *   ID: 63 bit ID
+ *
+ * Built-in IDs:
+ *
+ *   Bits: [63] [62] [61..32] [31 ..  0]
+ *         [ 1] [ L] [   R  ] [    V   ]
+ *
+ *    1: 1 for built-in DSQs.
+ *    L: 1 for LOCAL_ON DSQ IDs, 0 for others
+ *    V: For LOCAL_ON DSQ IDs, a CPU number. For others, a pre-defined value.
+ */
+enum hmbird_dsq_id_flags {
+	HMBIRD_DSQ_FLAG_BUILTIN	= 1LLU << 63,
+	HMBIRD_DSQ_FLAG_LOCAL_ON	= 1LLU << 62,
+
+	HMBIRD_DSQ_INVALID		= HMBIRD_DSQ_FLAG_BUILTIN | 0,
+	HMBIRD_DSQ_GLOBAL		= HMBIRD_DSQ_FLAG_BUILTIN | 1,
+	HMBIRD_DSQ_LOCAL		= HMBIRD_DSQ_FLAG_BUILTIN | 2,
+	HMBIRD_DSQ_LOCAL_ON	= HMBIRD_DSQ_FLAG_BUILTIN | HMBIRD_DSQ_FLAG_LOCAL_ON,
+	HMBIRD_DSQ_LOCAL_CPU_MASK	= 0xffffffffLLU,
+};
+
+enum hmbird_switch_type {
+	HMBIRD_SWITCH_PROC,
+	HMBIRD_SWITCH_ERR_WDT,
+	HMBIRD_SWITCH_ERR_HB,
+	HMBIRD_SWITCH_ERR_DSQ,
+	HMBIRD_EXIT_ERROR_STALL,	/* watchdog detected stalled runnable tasks */
+	HMBIRD_EXIT_ERROR_HEARTBEAT,	/* heart beat has stopped */
+};
+
+/*
+ * Dispatch queue (dsq) is a simple FIFO which is used to buffer between the
+ * scheduler core and the BPF scheduler. See the documentation for more details.
+ */
+struct hmbird_dispatch_q {
+	raw_spinlock_t		lock;
+	struct list_head	fifo;	/* processed in dispatching order */
+	struct rb_root_cached	priq;
+	u32			nr;
+	u64			id;
+	struct llist_node	free_node;
+	struct rcu_head		rcu;
+	u64                     last_consume_at;
+	bool                    is_timeout;
+};
+
+/* hmbird_entity.flags */
+enum hmbird_ent_flags {
+	HMBIRD_TASK_QUEUED		= 1 << 0, /* on hmbird runqueue */
+	HMBIRD_TASK_BAL_KEEP	= 1 << 1, /* balance decided to keep current */
+	HMBIRD_TASK_ENQ_LOCAL	= 1 << 2, /* used by hmbird_select_cpu_dfl, set HMBIRD_ENQ_LOCAL */
+
+	HMBIRD_TASK_OPS_PREPPED	= 1 << 8, /* prepared for BPF scheduler enable */
+	HMBIRD_TASK_OPS_ENABLED	= 1 << 9, /* task has BPF scheduler enabled */
+
+	HMBIRD_TASK_WATCHDOG_RESET = 1 << 16, /* task watchdog counter should be reset */
+	HMBIRD_TASK_DEQD_FOR_SLEEP	= 1 << 17, /* last dequeue was for SLEEP */
+
+	HMBIRD_TASK_CURSOR		= 1 << 31, /* iteration cursor, not a task */
+};
+
+/* hmbird_entity.dsq_flags */
+enum hmbird_ent_dsq_flags {
+	HMBIRD_TASK_DSQ_ON_PRIQ	= 1 << 0, /* task is queued on the priority queue of a dsq */
+};
+
+#define RAVG_HIST_SIZE 5
+struct hmbird_sched_task_stats {
+	u64				mark_start;
+	u64				window_start;
+	u32				sum;
+	u32				sum_history[RAVG_HIST_SIZE];
+	int				cidx;
+
+	u32				demand;
+	u16				demand_scaled;
+	void			*sdsq;
+};
+
+struct hmbird_sched_rq_stats {
+	u64		window_start;
+	u64		latest_clock;
+	u32		prev_window_size;
+	u64		task_exec_scale;
+	u64		prev_runnable_sum;
+	u64		curr_runnable_sum;
+	int		*sched_ravg_window_ptr;
+};
+
+/*
+ * The following is embedded in task_struct and contains all fields necessary
+ * for a task to be scheduled by HMBIRD.
+ */
+struct hmbird_entity {
+	struct hmbird_dispatch_q	*dsq;
+	struct {
+		struct list_head	fifo;	/* dispatch order */
+		struct rb_node		priq;
+	} dsq_node;
+	struct list_head	watchdog_node;
+	u32			flags;		/* protected by rq lock */
+	u32			dsq_flags;	/* protected by dsq lock */
+	u32			weight;
+	s32			sticky_cpu;
+	s32			holding_cpu;
+	u32			kf_mask;	/* see hmbird_kf_mask above */
+	struct task_struct	*kf_tasks[2];	/* see HMBIRD_CALL_OP_TASK() */
+	atomic64_t		ops_state;
+	unsigned long		runnable_at;
+	u64			slice;
+	u64			dsq_vtime;
+	bool			disallow;	/* reject switching into HMBIRD */
+	u16			demand_scaled;
+
+	/* cold fields */
+	struct list_head	tasks_node;
+	struct task_struct	*task;
+	const struct sched_class *sched_class;
+	unsigned long		sched_prop;
+	unsigned long		top_task_prop;
+	struct hmbird_sched_task_stats sts;
+	unsigned long           running_at;
+	int                     gdsq_idx;
+
+	s32			critical_affinity_cpu;
+	int			dsq_sync_ux;
+};
+
+
+/*
+ * All variables use 64bits width,
+ * Avoid parsing problems caused by automatic alignment(with padding) of structures.
+ */
+
+/* NOTING : Must align to 64bits. */
+#define DESC_STR_LEN	(32)
+/* Supporti up to  three-dimensional arrays. */
+#define PARSE_DIMENS	(3)
+struct meta_desc_t {
+	char desc_str[DESC_STR_LEN];
+	u64 len;
+	u64 parse[PARSE_DIMENS];
+};
+
+#define MAX_SWITCHS	(5)
+struct hmbird_switch_t {
+	u64 switch_at;
+	u64 is_success;
+	u64 end_state;
+	u64 switch_reason;
+};
+#define SWITCH_ITEMS	(sizeof(struct hmbird_switch_t) / sizeof(u64))
+
+#define MAX_EXCEPS	(5)
+enum excep_id {
+	NO_CGROUP_L1,
+	MODULE_UNLOAD,
+	ALREADY_ENABLED,
+	ALREADY_DISABLED,
+	INIT_TASK_FAIL,
+	ALLOC_RQSCX_FAIL,
+	DSQ_ID_ERR,
+	CPU_NO_MASK,
+	SCAN_ENTITY_NULL,
+	ITER_RET_NULL,
+	DEQ_DEQING,
+	ENQ_EXIST1,
+	ENQ_EXIST2,
+	TASK_LINKED1,
+	TASK_UNLINKED,
+	TASK_LINKED2,
+	TASK_UNQUED,
+	TASK_UNWATCHED,
+	HMBIRD_OPN,
+	TASK_WATCHED,
+	RQ_NO_RUNNING,
+	EXTRA_FLAGS,
+	HOLDING_CPU1,
+	HOLDING_CPU2,
+	TASK_OPS_PREPPED,
+	TASK_OPS_UNPREPPED,
+	HMBIRD_OPS_ERR,
+	MAX_EXCEP_ID,
+};
+
+struct snap_misc_t {
+	u64 hmbird_enabled;
+	u64 curr_ss;
+	u64 hmbird_ops_enable_state_var;
+	u64 non_ext_task;
+	u64 parctrl_high_ratio;
+	u64 parctrl_low_ratio;
+	u64 parctrl_high_ratio_l;
+	u64 parctrl_low_ratio_l;
+	u64 isoctrl_high_ratio;
+	u64 isoctrl_low_ratio;
+	u64 misfit_ds;
+	u64 partial_enable;
+	u64 iso_free_rescue;
+	u64 isolate_ctrl;
+	u64 snap_jiffies;
+	u64 snap_time;
+};
+#define SNAP_ITEMS	(sizeof(struct snap_misc_t) / sizeof(u64))
+
+struct panic_snapshot_t {
+	/* what time dose the first task of dsq turn in runnable, check starvation */
+	struct meta_desc_t runnable_at_meta;
+	u64 runnable_at[MAX_GLOBAL_DSQS];
+
+	struct meta_desc_t rq_nr_meta;
+	u64 rq_nr[NR_CPUS];
+
+	struct meta_desc_t scxrq_nr_meta;
+	u64 scxrq_nr[NR_CPUS];
+
+	struct meta_desc_t snap_misc_meta;
+	struct snap_misc_t snap_misc;
+};
+
+/*
+ * Do not record info in hot paths unless absolutely necessary,
+ * The impact on performance should be minimized.
+ */
+struct kernel_info_t {
+	struct meta_desc_t sw_rec_meta;
+	struct hmbird_switch_t sw_rec[MAX_SWITCHS];
+
+	struct meta_desc_t sw_idx_meta;
+	u64 sw_idx;
+
+	struct meta_desc_t excep_rec_meta;
+	u64 excep_rec[MAX_EXCEP_ID][MAX_EXCEPS];
+
+	struct meta_desc_t excep_idx_meta;
+	u64 excep_idx[MAX_EXCEP_ID];
+
+	/* snapshot while panic. */
+	struct panic_snapshot_t snap;
+};
+
+struct ko_info_t {};
+
+struct md_meta_t {
+	u64 self_len;
+	u64 unit_size;
+	u64 desc_meta_len;
+	u64 desc_str_len;
+	u64 switches;
+	u64 exceps;
+	u64 global_dsqs;
+	u64 parse_dimens;
+	u64 nr_cpus;
+	u64 real_cpus;
+	u64 nr_meta_desc;
+	u64 dump_real_size;
+};
+
+struct md_info_t {
+	struct md_meta_t meta;
+	struct kernel_info_t kern_dump;
+	struct ko_info_t ko_dump;
+};
+
+static inline void exceps_update(struct md_info_t *rec, int id, unsigned long jiffies)
+{
+	u64 *idx;
+
+	if (!rec)
+		return;
+
+	idx = &rec->kern_dump.excep_idx[id];
+	rec->kern_dump.excep_rec[id][*idx] = jiffies;
+	*idx = ++(*idx) % MAX_EXCEPS;
+}
+
+static inline void sw_update(struct md_info_t *rec, u64 switch_at,
+				u64 is_success, u64 end_state, u64 switch_reason)
+{
+	u64 *idx;
+
+	if (!rec)
+		return;
+
+	idx = &rec->kern_dump.sw_idx;
+	rec->kern_dump.sw_rec[*idx].switch_at = switch_at;
+	rec->kern_dump.sw_rec[*idx].is_success = is_success;
+	rec->kern_dump.sw_rec[*idx].end_state = end_state;
+	rec->kern_dump.sw_rec[*idx].switch_reason = switch_reason;
+	*idx = ++(*idx) % MAX_SWITCHS;
+}
+
+struct hmbird_ops {
+	bool (*scx_enable)(void);
+	bool (*check_non_task)(void);
+	void (*do_sched_yield_before)(long *skip);
+	void (*window_rollover_run_once)(struct rq *rq);
+	void (*hmbird_get_md_info)(unsigned long *vaddr, unsigned long *size);
+};
+
+void hmbird_free(struct task_struct *p);
+
+enum DSQ_SYNC_UX_FLAG {
+	DSQ_SYNC_UX_NONE = 0,
+	DSQ_SYNC_STATIC_UX = 1,
+	DSQ_SYNC_INHERIT_UX = 1 << 1,
+};
+
+#endif	/* _LINUX_SCHED_HMBIRD_H */
diff --git a/include/linux/sched/hmbird_proc_val.h b/include/linux/sched/hmbird_proc_val.h
new file mode 100755
index 000000000000..e59708b16ea3
--- /dev/null
+++ b/include/linux/sched/hmbird_proc_val.h
@@ -0,0 +1,22 @@
+#ifndef __HMBORD_PROC_VAL_H__
+#define __HMBORD_PROC_VAL_H__
+
+extern int scx_enable;
+extern int partial_enable;
+extern int cpuctrl_high_ratio;
+extern int cpuctrl_low_ratio;
+extern int slim_stats;
+extern int hmbirdcore_debug;
+extern int slim_for_app;
+extern int misfit_ds;
+extern unsigned int highres_tick_ctrl;
+extern unsigned int highres_tick_ctrl_dbg;
+extern int cpu7_tl;
+extern int slim_walt_ctrl;
+extern int slim_walt_dump;
+extern int slim_walt_policy;
+extern int slim_gov_debug;
+extern int scx_gov_ctrl;
+extern int sched_ravg_window_frame_per_sec;
+
+#endif
\ No newline at end of file
diff --git a/include/linux/sched/hmbird_version.h b/include/linux/sched/hmbird_version.h
new file mode 100755
index 000000000000..b2843881c26f
--- /dev/null
+++ b/include/linux/sched/hmbird_version.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+
+#ifndef _OPLUS_HMBIRD_VERSION_H_
+#define _OPLUS_HMBIRD_VERSION_H_
+#include <linux/of.h>
+#include <linux/string.h>
+#include <linux/printk.h>
+
+enum hmbird_version {
+	HMBIRD_UNINIT,
+	HMBIRD_GKI_VERSION,
+	HMBIRD_OGKI_VERSION,
+	HMBIRD_UNKNOW_VERSION,
+};
+
+static enum hmbird_version hmbird_version_type = HMBIRD_UNINIT;
+
+#define HMBIRD_VERSION_TYPE_CONFIG_PATH "/soc/oplus,hmbird/version_type"
+
+static inline enum hmbird_version get_hmbird_version_type(void)
+{
+	struct device_node *np = NULL;
+	const char *hmbird_version_str = NULL;
+	if (HMBIRD_UNINIT != hmbird_version_type)
+		return hmbird_version_type;
+	np = of_find_node_by_path(HMBIRD_VERSION_TYPE_CONFIG_PATH);
+	if (np) {
+		of_property_read_string(np, "type", &hmbird_version_str);
+		if (NULL != hmbird_version_str) {
+			if (strncmp(hmbird_version_str, "HMBIRD_OGKI", strlen("HMBIRD_OGKI")) == 0) {
+				hmbird_version_type = HMBIRD_OGKI_VERSION;
+				pr_debug("hmbird version use HMBIRD_OGKI_VERSION, set by dtsi");
+			} else if (strncmp(hmbird_version_str, "HMBIRD_GKI", strlen("HMBIRD_GKI")) == 0) {
+				hmbird_version_type = HMBIRD_GKI_VERSION;
+				pr_debug("hmbird version use HMBIRD_GKI_VERSION, set by dtsi");
+			} else {
+				hmbird_version_type = HMBIRD_UNKNOW_VERSION;
+				pr_debug("hmbird version use default HMBIRD_UNKNOW_VERSION, set by dtsi");
+			}
+			return hmbird_version_type;
+		}
+	}
+
+	hmbird_version_type = HMBIRD_UNKNOW_VERSION;
+	pr_debug("hmbird version use default HMBIRD_UNKNOW_VERSION");
+	return hmbird_version_type;
+}
+
+#endif /*_OPLUS_HMBIRD_VERSION_H_ */
diff --git a/include/linux/sched/sa_common.h b/include/linux/sched/sa_common.h
new file mode 100755
index 000000000000..6f76d7cfd7bf
--- /dev/null
+++ b/include/linux/sched/sa_common.h
@@ -0,0 +1,797 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2020-2022 Oplus. All rights reserved.
+ */
+
+
+#ifndef _OPLUS_SA_COMMON_H_
+#define _OPLUS_SA_COMMON_H_
+
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/atomic.h>
+#include <linux/hashtable.h>
+#include <linux/cgroup-defs.h>
+#if IS_ENABLED(CONFIG_SCHED_WALT)
+#include <linux/sched/walt.h>
+#endif
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/sched/rt.h>
+
+#include "sa_oemdata.h"
+#include "sa_common_struct.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+#define OPLUS_UX_EEVDF_COMPATIBLE 1
+#endif
+
+#define SA_DEBUG_ON 0
+
+#if (SA_DEBUG_ON >= 1)
+#define DEBUG_BUG_ON(x) BUG_ON(x)
+#define DEBUG_WARN_ON(x) WARN_ON(x)
+#else
+#define DEBUG_BUG_ON(x)
+#define DEBUG_WARN_ON(x)
+#endif
+
+#define ux_err(fmt, ...) \
+		pr_err("[sched_assist][%s]"fmt, __func__, ##__VA_ARGS__)
+#define ux_warn(fmt, ...) \
+		pr_warn("[sched_assist][%s]"fmt, __func__, ##__VA_ARGS__)
+#define ux_debug(fmt, ...) \
+		pr_info("[sched_assist][%s]"fmt, __func__, ##__VA_ARGS__)
+
+#define UX_MSG_LEN		64
+#define UX_DEPTH_MAX		5
+
+/* define for debug */
+#define DEBUG_SYSTRACE (1 << 0)
+#define DEBUG_FTRACE   (1 << 1)
+#define DEBUG_KMSG     (1 << 2)        /* used for frameboost */
+#define DEBUG_PIPELINE (1 << 3)
+#define DEBUG_DYNAMIC_HZ (1 << 4)
+#define DEBUG_DYNAMIC_PREEMPT (1 << 5)
+#define DEBUG_AMU_INSTRUCTION (1 << 6)
+#define DEBUG_VERBOSE  (1 << 10)       /* used for frameboost */
+#define DEBUG_SET_DSQ_ID (1 << 11) /* used for hmbird */
+
+/* define for sched assist feature */
+#define FEATURE_COMMON (1 << 0)
+#define FEATURE_SPREAD (1 << 1)
+
+#define UX_EXEC_SLICE (4000000U)
+
+/* define for sched assist thread type, keep same as the define in java file */
+#define SA_OPT_CLEAR				(0)
+#define SA_TYPE_LIGHT				(1 << 0)
+#define SA_TYPE_HEAVY				(1 << 1)
+#define SA_TYPE_ANIMATOR			(1 << 2)
+/* SA_TYPE_LISTPICK for camera */
+#define SA_TYPE_LISTPICK			(1 << 3)
+#define SA_TYPE_MQ_VIP				(1 << 4)
+#define SA_OPT_SET					(1 << 7)
+#define SA_OPT_RESET				(1 << 8)
+#define SA_OPT_SET_PRIORITY			(1 << 9)
+
+/* The following ux value only used in kernel */
+#define SA_TYPE_SWIFT				(1 << 14)
+/* clear ux type when dequeue */
+#define SA_TYPE_ONCE				(1 << 15)
+#define SA_TYPE_INHERIT				(1 << 16)
+/* SA_TYPE_COMBINED isn't marked in ux_state, it only exists in return value of function */
+#define SA_TYPE_COMBINED			(1 << 17)
+#define SA_TYPE_URGENT_MASK	(SA_TYPE_LIGHT|SA_TYPE_ANIMATOR|SA_TYPE_SWIFT)
+#define SCHED_ASSIST_UX_MASK	(SA_TYPE_LIGHT|SA_TYPE_HEAVY|SA_TYPE_ANIMATOR|SA_TYPE_LISTPICK|SA_TYPE_SWIFT)
+
+/* load balance operation is performed on the following ux types */
+#define SCHED_ASSIST_LB_UX			(SA_TYPE_SWIFT | SA_TYPE_ANIMATOR | SA_TYPE_LIGHT | SA_TYPE_HEAVY)
+#define POSSIBLE_UX_MASK			(SA_TYPE_SWIFT | \
+									SA_TYPE_LIGHT | \
+									SA_TYPE_HEAVY | \
+									SA_TYPE_ANIMATOR | \
+									SA_TYPE_LISTPICK | \
+									SA_TYPE_ONCE | \
+									SA_TYPE_INHERIT)
+
+#define SCHED_ASSIST_UX_PRIORITY_MASK	(0xFF000000)
+#define SCHED_ASSIST_UX_PRIORITY_SHIFT	24
+
+#define UX_PRIORITY_TOP_APP		0x0A000000
+#define UX_PRIORITY_AUDIO		0x0A000000
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_PIPELINE)
+#define UX_PRIORITY_PIPELINE_UI 0x06000000
+#define UX_PRIORITY_PIPELINE    0x05000000
+#endif
+
+/* define for sched assist scene type, keep same as the define in java file */
+#define SA_SCENE_OPT_CLEAR			(0)
+#define SA_LAUNCH					(1 << 0)
+#define SA_SLIDE					(1 << 1)
+#define SA_CAMERA					(1 << 2)
+#define SA_ANIM_START				(1 << 3) /* we care about both launcher and top app */
+#define SA_ANIM						(1 << 4) /* we only care about launcher */
+#define SA_INPUT					(1 << 5)
+#define SA_LAUNCHER_SI				(1 << 6)
+#define SA_SCENE_OPT_SET			(1 << 7)
+
+#define ROOT_UID               0
+#define SYSTEM_UID             1000
+#define FIRST_APPLICATION_UID  10000
+#define LAST_APPLICATION_UID   19999
+#define PER_USER_RANGE         100000
+/* define for clear IM_FLAG
+if im_flag is 70, it should clear im_flag_audio (70 - 64 = 6)
+eg: gerrit patchset "30438485"
+ */
+#define IM_FLAG_CLEAR			64
+
+extern pid_t save_audio_tgid;
+extern pid_t save_top_app_tgid;
+extern unsigned int top_app_type;
+extern int global_lowend_plat_opt;
+
+#ifdef CONFIG_OPLUS_SCHED_HALT_MASK_PRT
+/* This must be the same as the definition of pause_type in walt_halt.c */
+enum oplus_pause_type {
+	OPLUS_HALT,
+	OPLUS_PARTIAL_HALT,
+
+	OPLUS_MAX_PAUSE_TYPE
+};
+extern cpumask_t cur_cpus_halt_mask;
+extern cpumask_t cur_cpus_phalt_mask;
+DECLARE_PER_CPU(int[OPLUS_MAX_PAUSE_TYPE], oplus_cur_pause_client);
+extern void sa_corectl_systrace_c(void);
+#endif /* CONFIG_OPLUS_SCHED_HALT_MASK_PRT */
+
+/* define for boost threshold unit */
+#define BOOST_THRESHOLD_UNIT (51)
+
+
+enum UX_STATE_TYPE {
+	UX_STATE_INVALID = 0,
+	UX_STATE_NONE,
+	UX_STATE_STATIC,
+	UX_STATE_INHERIT,
+	UX_STATE_COMBINED,
+	MAX_UX_STATE_TYPE,
+};
+
+enum INHERIT_UX_TYPE {
+	INHERIT_UX_BINDER = 0,
+	INHERIT_UX_RWSEM,
+	INHERIT_UX_MUTEX,
+	INHERIT_UX_FUTEX,
+	INHERIT_UX_PIFUTEX,
+	INHERIT_UX_MAX,
+};
+
+/*
+ * WANNING:
+ * new flag should be add before MAX_IM_FLAG_TYPE, never change
+ * the value of those existed flag type.
+ */
+enum IM_FLAG_TYPE {
+	IM_FLAG_NONE = 0,
+	IM_FLAG_SURFACEFLINGER,
+	IM_FLAG_HWC,			/* Discarded */
+	IM_FLAG_RENDERENGINE,
+	IM_FLAG_WEBVIEW,
+	IM_FLAG_CAMERA_HAL,
+	IM_FLAG_AUDIO,
+	IM_FLAG_HWBINDER,
+	IM_FLAG_LAUNCHER,
+	IM_FLAG_LAUNCHER_NON_UX_RENDER,
+	IM_FLAG_SS_LOCK_OWNER,
+	IM_FLAG_FORBID_SET_CPU_AFFINITY = 11, /* forbid setting cpu affinity from app */
+	IM_FLAG_SYSTEMSERVER_PID,
+	IM_FLAG_MIDASD,
+	IM_FLAG_AUDIO_CAMERA_HAL, /* audio mode disable camera hal ux */
+	IM_FLAG_AFFINITY_THREAD,
+	IM_FLAG_TPD_SET_CPU_AFFINITY = 16,
+	IM_FLAG_COMPRESS_THREAD = 17, /* compress thread skips locking protect */
+	IM_FLAG_RENDER_THREAD = 18,
+	MAX_IM_FLAG_TYPE,
+};
+
+#define MAX_IM_FLAG_PRIO	MAX_IM_FLAG_TYPE
+
+enum ots_state {
+	OTS_STATE_SET_AFFINITY,
+	OTS_STATE_DDL_ACTIVE,
+	OTS_STATE_DDL_ACTIVE_PREEMPTED,
+	OTS_STATE_MAX,
+};
+
+#ifdef CONFIG_OPLUS_FEATURE_TICK_GRAN
+DECLARE_PER_CPU(u64, retired_instrs);
+DECLARE_PER_CPU(u64, nvcsw);
+DECLARE_PER_CPU(u64, nivcsw);
+#endif
+
+struct ux_sched_cluster {
+	struct cpumask cpus;
+	unsigned long capacity;
+};
+
+#define OPLUS_NR_CPUS (8)
+#define OPLUS_MAX_CLS (5)
+struct ux_sched_cputopo {
+	int cls_nr;
+	struct ux_sched_cluster sched_cls[OPLUS_NR_CPUS];
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)
+	cpumask_t oplus_cpu_array[2*OPLUS_MAX_CLS][OPLUS_MAX_CLS];
+#endif
+};
+
+struct oplus_rq {
+	/* CONFIG_OPLUS_FEATURE_SCHED_ASSIST */
+	struct rb_root_cached ux_list;
+	/* a tree to track minimum exec vruntime */
+	struct rb_root_cached exec_timeline;
+	/* malloc this spinlock_t instead of built-in to shrank size of oplus_rq */
+	spinlock_t *ux_list_lock;
+	int nr_running;
+	u64 min_vruntime;
+	u64 load_weight;
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_SCHED_DDL)
+	struct rb_root_cached ddl_root;
+	spinlock_t *ddl_lock;
+#endif
+
+#ifdef CONFIG_LOCKING_PROTECT
+#ifndef CONFIG_LOCKING_LAST_ENTITY
+	struct list_head locking_thread_list;
+	spinlock_t *locking_list_lock;
+	int rq_locking_task;
+#else
+	struct sched_entity *last_entity;
+#endif
+#endif
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)
+	/* for loadbalance */
+	struct oplus_lb lb;
+#endif
+#ifdef CONFIG_OPLUS_FEATURE_TICK_GRAN
+	struct hrtimer *resched_timer;
+	int cpu;
+#endif
+};
+
+extern int global_debug_enabled;
+extern int global_sched_assist_enabled;
+extern int global_sched_assist_scene;
+extern int global_silver_perf_core;
+extern int global_sched_group_enabled;
+
+struct rq;
+
+#ifdef CONFIG_LOCKING_PROTECT
+struct sched_assist_locking_ops {
+	void (*check_preempt_tick)(struct task_struct *p,
+			unsigned long *ideal_runtime, bool *skip_preempt,
+			unsigned long delta_exec, struct cfs_rq *cfs_rq,
+			struct sched_entity *curr, unsigned int granularity);
+	void (*check_preempt_wakeup)(struct rq *rq, struct task_struct *p, bool *preempt, bool *nopreempt);
+	void (*state_systrace_c)(unsigned int cpu, struct task_struct *p);
+	void (*locking_tick_hit)(struct task_struct *prev, struct task_struct *next);
+#ifndef CONFIG_LOCKING_LAST_ENTITY
+	void (*replace_next_task_fair)(struct rq *rq,
+			struct task_struct **p, struct sched_entity **se, bool *repick, bool simple);
+	void (*enqueue_entity)(struct rq *rq, struct task_struct *p);
+	void (*dequeue_entity)(struct rq *rq, struct task_struct *p);
+#else
+	void (*set_last_entity)(struct task_struct *prev, struct task_struct *next, struct rq *rq);
+	void (*pick_last_entity)(struct rq *rq, struct task_struct **p, struct sched_entity **se, bool *repick, bool simple);
+	void (*clear_last_entity)(struct rq *rq, struct task_struct *p);
+#endif
+	void (*opt_ss_lock_contention)(struct task_struct *p, int old_im, int new_im);
+};
+
+extern struct sched_assist_locking_ops *locking_ops;
+
+
+#define LOCKING_CALL_OP(op, args...) 						\
+do {														\
+	if (locking_ops && locking_ops->op) {					\
+		locking_ops->op(args);								\
+	}														\
+} while (0)
+
+#define LOCKING_CALL_OP_RET(op, args...) 						\
+({																\
+	__typeof__(locking_ops->op(args)) __ret = 0;				\
+	if (locking_ops && locking_ops->op) 							\
+			__ret = locking_ops->op(args);						\
+	__ret; 														\
+})
+
+void register_sched_assist_locking_ops(struct sched_assist_locking_ops *ops);
+#endif
+
+/* attention: before insert .ko, task's list->prev/next is init with 0 */
+static inline bool oplus_list_empty(struct list_head *list)
+{
+	return list_empty(list) || (list->prev == 0 && list->next == 0);
+}
+
+static inline bool oplus_rbtree_empty(struct rb_root_cached *list)
+{
+	return (rb_first_cached(list) == NULL);
+}
+
+/**
+ * Check if there are ux tasks waiting to run on the specified cpu
+ */
+static inline bool orq_has_ux_tasks(struct oplus_rq *orq)
+{
+	return !oplus_rbtree_empty(&orq->ux_list);
+}
+
+/* attention: before insert .ko, task's node->__rb_parent_color is init with 0 */
+static inline bool oplus_rbnode_empty(struct rb_node *node)
+{
+	return RB_EMPTY_NODE(node) || (node->__rb_parent_color == 0);
+}
+
+static inline struct oplus_task_struct *ux_list_first_entry(struct rb_root_cached *list)
+{
+	struct rb_node *leftmost = rb_first_cached(list);
+	if (leftmost == NULL) {
+		return NULL;
+	}
+	return rb_entry(leftmost, struct oplus_task_struct, ux_entry);
+}
+
+static inline struct oplus_task_struct *exec_timeline_first_entry(struct rb_root_cached *tree)
+{
+	struct rb_node *leftmost = rb_first_cached(tree);
+	if (leftmost == NULL) {
+		return NULL;
+	}
+	return rb_entry(leftmost, struct oplus_task_struct, exec_time_node);
+}
+
+typedef bool (*migrate_task_callback_t)(struct task_struct *tsk, int src_cpu, int dst_cpu);
+extern migrate_task_callback_t fbg_migrate_task_callback;
+typedef void (*android_rvh_schedule_handler_t)(struct task_struct *prev,
+	struct task_struct *next, struct rq *rq);
+extern android_rvh_schedule_handler_t fbg_android_rvh_schedule_callback;
+
+extern struct kmem_cache *oplus_task_struct_cachep;
+
+#define ots_to_ts(ots)	(ots->task)
+#define OTS_IDX			0
+#define ORQ_IDX			0
+
+static inline bool test_task_is_fair(struct task_struct *task)
+{
+	DEBUG_BUG_ON(!task);
+
+	/* valid CFS priority is MAX_RT_PRIO..MAX_PRIO-1 */
+	if ((task->prio >= MAX_RT_PRIO) && (task->prio <= MAX_PRIO-1))
+		return true;
+	return false;
+}
+
+static inline bool test_task_is_rt(struct task_struct *task)
+{
+	DEBUG_BUG_ON(!task);
+
+	/* valid RT priority is 0..MAX_RT_PRIO-1 */
+	if (rt_prio(task->prio))
+		return true;
+
+	return false;
+}
+
+static inline struct oplus_task_struct *get_oplus_task_struct(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = NULL;
+
+	/* not Skip idle thread */
+	if (!t)
+		return NULL;
+
+	ots = (struct oplus_task_struct *) READ_ONCE(t->android_oem_data1[OTS_IDX]);
+	if (IS_ERR_OR_NULL(ots))
+		return NULL;
+
+	return ots;
+}
+
+static inline unsigned long oplus_get_im_flag(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return IM_FLAG_NONE;
+
+	return ots->im_flag;
+}
+
+static inline bool is_optimized_audio_thread(struct task_struct *t)
+{
+	unsigned long im_flag;
+
+	im_flag = oplus_get_im_flag(t);
+	if (test_bit(IM_FLAG_AUDIO, &im_flag))
+		return true;
+
+	return false;
+}
+
+static inline void oplus_set_im_flag(struct task_struct *t, int im_flag)
+{
+	struct oplus_task_struct *ots = NULL;
+	ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return;
+
+	set_bit(im_flag, &ots->im_flag);
+}
+
+static inline int get_ots_ux_state(struct oplus_task_struct *ots)
+{
+	int ux_state;
+	int sub_ux_state;
+	int ux_prio;
+	int ret;
+
+	ux_prio = ots->ux_state & SCHED_ASSIST_UX_PRIORITY_MASK;
+	ux_state = ots->ux_state & (SCHED_ASSIST_UX_MASK | SA_TYPE_INHERIT);
+	sub_ux_state = ots->sub_ux_state & (SCHED_ASSIST_UX_MASK | SA_TYPE_INHERIT);
+
+	if (sub_ux_state) {
+		ret = ux_state | (sub_ux_state & ~SA_TYPE_INHERIT) | SA_TYPE_COMBINED;
+	} else {
+		ret = ux_state;
+	}
+
+	if (ret & SCHED_ASSIST_UX_MASK) {
+		return ux_prio | ret;
+	}
+
+	return 0;
+}
+
+bool is_multiple_ux(struct oplus_task_struct *ots);
+
+static inline int oplus_get_ux_state(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return 0;
+
+	return get_ots_ux_state(ots);
+}
+
+static inline int oplus_get_static_ux_state(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return 0;
+
+	if (ots->ux_state & SA_TYPE_INHERIT) {
+		return 0;
+	}
+	return ots->ux_state;
+}
+
+static inline int oplus_get_sub_ux_state(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return 0;
+
+	return ots->sub_ux_state;
+}
+
+static inline int oplus_get_inherited_ux_state(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return 0;
+
+	if (ots->ux_state & SA_TYPE_INHERIT) {
+		return ots->ux_state;
+	}
+	return ots->sub_ux_state;
+}
+
+void oplus_set_ux_state_lock(struct task_struct *t, int ux_state, int inherit_type, bool need_lock_rq);
+
+static inline s64 oplus_get_inherit_ux(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return 0;
+
+	return atomic64_read(&ots->inherit_ux);
+}
+
+static inline void oplus_set_inherit_ux(struct task_struct *t, s64 inherit_ux)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return;
+
+	atomic64_set(&ots->inherit_ux, inherit_ux);
+}
+
+static inline int oplus_get_ux_depth(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return 0;
+
+	return ots->ux_depth;
+}
+
+static inline void oplus_set_ux_depth(struct task_struct *t, int ux_depth)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return;
+
+	ots->ux_depth = ux_depth;
+}
+
+static inline u64 oplus_get_enqueue_time(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return 0;
+
+	return ots->enqueue_time;
+}
+
+static inline void oplus_set_enqueue_time(struct task_struct *t, u64 enqueue_time)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return;
+
+	ots->enqueue_time = enqueue_time;
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)
+	/*
+	 * Record the number of task context switches
+	 * and scheduling delays when enqueueing a task.
+	 */
+	ots->snap_pcount = t->sched_info.pcount;
+	ots->snap_run_delay = t->sched_info.run_delay;
+#endif
+}
+
+static inline void oplus_set_inherit_ux_start(struct task_struct *t, u64 start_time)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return;
+
+	ots->inherit_ux_start = t->se.sum_exec_runtime;
+}
+
+static inline void init_task_ux_info(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return;
+
+	RB_CLEAR_NODE(&ots->ux_entry);
+	RB_CLEAR_NODE(&ots->exec_time_node);
+	ots->ux_state = 0;
+	ots->sub_ux_state = 0;
+	atomic64_set(&ots->inherit_ux, 0);
+	ots->ux_depth = 0;
+	ots->enqueue_time = 0;
+	ots->inherit_ux_start = 0;
+	ots->ux_priority = -1;
+	ots->ux_nice = -1;
+	ots->vruntime = 0;
+	ots->preset_vruntime = 0;
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_ABNORMAL_FLAG)
+	ots->abnormal_flag = 0;
+#endif
+#ifdef CONFIG_OPLUS_FEATURE_SCHED_SPREAD
+	ots->lb_state = 0;
+	ots->ld_flag = 0;
+#endif
+	ots->exec_calc_runtime = 0;
+	ots->is_update_runtime = 0;
+	ots->target_process = -1;
+	ots->wake_tid = 0;
+	ots->running_start_time = 0;
+	ots->update_running_start_time = false;
+	ots->last_wake_ts = 0;
+/*#if IS_ENABLED(CONFIG_OPLUS_LOCKING_STRATEGY)*/
+	memset(&ots->lkinfo, 0, sizeof(struct locking_info));
+	INIT_LIST_HEAD(&ots->lkinfo.node);
+/*#endif*/
+	ots->block_start_time = 0;
+#ifdef CONFIG_LOCKING_PROTECT
+	INIT_LIST_HEAD(&ots->locking_entry);
+	ots->locking_start_time = 0;
+	ots->locking_depth = 0;
+#endif
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)
+	/* for loadbalance */
+	ots->snap_pcount = 0;
+	ots->snap_run_delay = 0;
+	plist_node_init(&ots->rtb, MAX_IM_FLAG_PRIO);
+#endif
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_PIPELINE)
+	atomic_set(&ots->pipeline_cpu, -1);
+#endif
+
+#if IS_ENABLED(CONFIG_ARM64_AMU_EXTN) && IS_ENABLED(CONFIG_OPLUS_FEATURE_CPU_JANKINFO)
+	ots->amu_cycle = 0;
+	ots->amu_instruct = 0;
+#endif
+};
+
+static inline bool test_ux_type(struct task_struct *task, int ux_type)
+{
+	return oplus_get_ux_state(task) & ux_type;
+}
+
+static inline bool is_heavy_ux_task(struct task_struct *t)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(t);
+
+	if (IS_ERR_OR_NULL(ots))
+		return false;
+
+	return get_ots_ux_state(ots) & SA_TYPE_HEAVY;
+}
+
+static inline bool sched_assist_scene(unsigned int scene)
+{
+	if (unlikely(!global_sched_assist_enabled))
+		return false;
+
+	return global_sched_assist_scene & scene;
+}
+
+static inline unsigned long oplus_task_util(struct task_struct *p)
+{
+#if IS_ENABLED(CONFIG_SCHED_WALT)
+	struct walt_task_struct *wts = (struct walt_task_struct *) p->android_vendor_data1;
+
+	return wts->demand_scaled;
+#else
+	return READ_ONCE(p->se.avg.util_avg);
+#endif
+}
+
+#if IS_ENABLED(CONFIG_SCHED_WALT)
+static inline u32 task_wts_sum(struct task_struct *tsk)
+{
+	struct walt_task_struct *wts = (struct walt_task_struct *) tsk->android_vendor_data1;
+
+	return wts->sum;
+}
+#endif
+
+bool is_min_cluster(int cpu);
+bool is_max_cluster(int cpu);
+bool is_mid_cluster(int cpu);
+bool im_mali(const char *comm);
+bool is_top(struct task_struct *p);
+bool task_is_runnable(struct task_struct *task);
+struct oplus_rq *get_oplus_rq(struct rq *rq);
+
+typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
+extern kallsyms_lookup_name_t _kallsyms_lookup_name;
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)
+int ux_mask_to_prio(int ux_mask);
+int ux_prio_to_mask(int prio);
+#endif
+
+noinline int tracing_mark_write(const char *buf);
+void hwbinder_systrace_c(unsigned int cpu, int flag);
+void sched_assist_init_oplus_rq(void);
+void queue_ux_thread(struct rq *rq, struct task_struct *p, int enqueue);
+
+void inherit_ux_inc(struct task_struct *task, int type);
+void inherit_ux_sub(struct task_struct *task, int type, int value);
+void set_inherit_ux(struct task_struct *task, int type, int depth, int inherit_val);
+void reset_inherit_ux(struct task_struct *inherit_task, struct task_struct *ux_task, int reset_type);
+void unset_inherit_ux(struct task_struct *task, int type);
+void unset_inherit_ux_value(struct task_struct *task, int type, int value);
+void inc_inherit_ux_refs(struct task_struct *task, int type);
+void clear_all_inherit_type(struct task_struct *p);
+int get_max_inherit_gran(struct task_struct *p);
+
+bool is_heavy_load_top_task(struct task_struct *p);
+bool test_task_is_fair(struct task_struct *task);
+bool test_task_is_rt(struct task_struct *task);
+
+bool test_task_ux(struct task_struct *task);
+bool test_task_ux_depth(int ux_depth);
+bool test_inherit_ux(struct task_struct *task, int type);
+bool test_set_inherit_ux(struct task_struct *task);
+int get_ux_state_type(struct task_struct *task);
+void sched_assist_target_comm(struct task_struct *task, const char *comm);
+unsigned int ux_task_exec_limit(struct task_struct *p);
+
+void update_ux_sched_cputopo(void);
+bool is_task_util_over(struct task_struct *tsk, int threshold);
+bool oplus_task_misfit(struct task_struct *tsk, int cpu);
+ssize_t oplus_show_cpus(const struct cpumask *mask, char *buf);
+void adjust_rt_lowest_mask(struct task_struct *p, struct cpumask *local_cpu_mask, int ret, bool force_adjust);
+bool sa_skip_rt_sync(struct rq *rq, struct task_struct *p, bool *sync);
+void ux_state_systrace_c(unsigned int cpu, struct task_struct *p);
+bool sa_rt_skip_ux_cpu(int cpu);
+int is_vip_mvp(struct task_struct *p);
+
+/* s64 account_ux_runtime(struct rq *rq, struct task_struct *curr); */
+void opt_ss_lock_contention(struct task_struct *p, unsigned long old_im, int new_im);
+
+/* register vender hook in kernel/sched/topology.c */
+void android_vh_build_sched_domains_handler(void *unused, bool has_asym);
+
+/* register vender hook in kernel/sched/rt.c */
+void android_rvh_select_task_rq_rt_handler(void *unused, struct task_struct *p, int prev_cpu, int sd_flag, int wake_flags, int *new_cpu);
+void android_rvh_find_lowest_rq_handler(void *unused, struct task_struct *p, struct cpumask *local_cpu_mask, int ret, int *best_cpu);
+
+/* register vender hook in kernel/sched/core.c */
+void android_rvh_sched_fork_handler(void *unused, struct task_struct *p);
+void android_rvh_after_enqueue_task_handler(void *unused, struct rq *rq, struct task_struct *p, int flags);
+void android_rvh_dequeue_task_handler(void *unused, struct rq *rq, struct task_struct *p, int flags);
+void android_rvh_schedule_handler(void *unused, struct task_struct *prev, struct task_struct *next, struct rq *rq);
+void android_vh_scheduler_tick_handler(void *unused, struct rq *rq);
+
+void android_vh_account_process_tick_gran_handler(void *unused, struct task_struct *p, struct rq *rq, int user_tick, int *ticks);
+#ifdef CONFIG_OPLUS_FEATURE_TICK_GRAN
+void sa_sched_switch_handler(void *unused, bool preempt, struct task_struct *prev, struct task_struct *next, unsigned int prev_state);
+#endif
+
+void set_im_flag_with_bit(int im_flag, struct task_struct *task);
+
+/* register vendor hook in kernel/cgroup/cgroup-v1.c */
+void android_vh_cgroup_set_task_handler(void *unused, int ret, struct task_struct *task);
+/* register vendor hook in kernel/signal.c  */
+void android_vh_exit_signal_handler(void *unused, struct task_struct *p);
+void android_rvh_set_cpus_allowed_by_task_handler(void *unused, const struct cpumask *cpu_valid_mask,
+	const struct cpumask *new_mask, struct task_struct *task, unsigned int *dest_cpu);
+void android_rvh_setscheduler_handler(void *unused, struct task_struct *p);
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_BAN_APP_SET_AFFINITY)
+void android_vh_sched_setaffinity_early_handler(void *unused, struct task_struct *task, const struct cpumask *new_mask, bool *skip);
+#endif
+
+#ifdef CONFIG_OPLUS_SCHED_GROUP_OPT
+void android_vh_reweight_entity_handler(void *unused, struct sched_entity *se);
+#endif
+
+#ifdef CONFIG_BLOCKIO_UX_OPT
+int sa_blockio_init(void);
+void sa_blockio_exit(void);
+#endif
+extern struct notifier_block process_exit_notifier_block;
+#endif /* _OPLUS_SA_COMMON_H_ */
diff --git a/include/linux/sched/sa_common_struct.h b/include/linux/sched/sa_common_struct.h
new file mode 100755
index 000000000000..876feff48b36
--- /dev/null
+++ b/include/linux/sched/sa_common_struct.h
@@ -0,0 +1,277 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2020-2022 Oplus. All rights reserved.
+ */
+
+/*
+this file is splited from the sa_common.h to adapt the OKI,
+IS_ENABLED is not allowed in here, because the macro will not work in OKI.
+*/
+#ifndef _OPLUS_SA_COMMON_STRUCT_H_
+#define _OPLUS_SA_COMMON_STRUCT_H_
+
+#define MAX_CLUSTER            (4)
+
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CPU_JANKINFO)*/
+/* hot-thread */
+struct task_record {
+#define RECOED_WINSIZE			(1 << 8)
+#define RECOED_WINIDX_MASK		(RECOED_WINSIZE - 1)
+	u8 winidx;
+	u8 count;
+};
+
+#define MAX_TASK_COMM_LEN 256
+struct uid_struct {
+	uid_t uid;
+	u64 uid_total_cycle;
+	u64 uid_total_inst;
+	spinlock_t lock;
+	char leader_comm[TASK_COMM_LEN];
+	char cmdline[MAX_TASK_COMM_LEN];
+};
+
+struct  amu_uid_entry {
+	uid_t uid;
+	struct uid_struct *uid_struct;
+	struct hlist_node node;
+};
+
+/*#endif*/
+
+/*#if IS_ENABLED(CONFIG_OPLUS_LOCKING_STRATEGY)*/
+struct locking_info {
+	u64 waittime_stamp;
+	u64 holdtime_stamp;
+	/* Used in torture acquire latency statistic.*/
+	u64 acquire_stamp;
+	/*
+	 * mutex or rwsem optimistic spin start time. Because a task
+	 * can't spin both on mutex and rwsem at one time, use one common
+	 * threshold time is OK.
+	 */
+	u64 opt_spin_start_time;
+	struct task_struct *holder;
+	u32 waittype;
+	bool ux_contrib;
+	/*
+	 * Whether task is ux when it's going to be added to mutex or
+	 * rwsem waiter list. It helps us check whether there is ux
+	 * task on mutex or rwsem waiter list. Also, a task can't be
+	 * added to both mutex and rwsem at one time, so use one common
+	 * field is OK.
+	 */
+	bool is_block_ux;
+	u32 kill_flag;
+	/* for cfs enqueue smoothly.*/
+	struct list_head node;
+	struct task_struct *owner;
+	struct list_head lock_head;
+	u64 clear_seq;
+	atomic_t lock_depth;
+};
+/*#endif*/
+
+/*#if IS_ENABLED(CONFIG_HMBIRD_SCHED_GKI)*/
+#define RAVG_HIST_SIZE 	5
+#define SCX_SLICE_DFL 	(1 * NSEC_PER_MSEC)
+#define SCX_SLICE_INF	U64_MAX
+#define DEFAULT_CGROUP_DL_IDX (8)
+#define EXT_FLAG_RT_CHANGED  	(1 << 0)
+#define EXT_FLAG_CFS_CHANGED 	(1 << 1)
+struct scx_task_stats {
+	u64	mark_start;
+	u64	window_start;
+	u32	sum;
+	u32	sum_history[RAVG_HIST_SIZE];
+	int	cidx;
+	u32	demand;
+	u16	demand_scaled;
+	void	*sdsq;
+};
+/*
+ * The following is embedded in task_struct and contains all fields necessary
+ * for a task to be scheduled by SCX.
+ */
+struct scx_entity {
+	struct scx_dispatch_q	*dsq;
+	struct {
+		struct list_head	fifo;	/* dispatch order */
+		struct rb_node		priq;	/* p->scx.dsq_vtime order */
+	} dsq_node;
+	u32			flags;		/* protected by rq lock */
+	u32			dsq_flags;	/* protected by dsq lock */
+	s32			sticky_cpu;
+	unsigned long		runnable_at;
+	u64			slice;
+	u64			dsq_vtime;
+	int			gdsq_idx;
+	int 			ext_flags;
+	int 			prio_backup;
+	unsigned long		sched_prop;
+	struct scx_task_stats 	sts;
+};
+/*#endif*/
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_POWERMODEL)
+
+#define MAX_CPU_FREQ_STATE 32
+#define MAX_CPU_CNT 8
+
+#define STATE_IN_POOL 0
+#define STATE_ACTIVE 1
+
+struct powermodel_freq_task_state {
+	u8 powermodel_enqueued:1;
+	u8 powermodel_index:7;
+};
+
+struct powermodel_cpu_task_state {
+	struct oplus_task_struct *ots;
+	struct powermodel_freq_task_state powermodel_freq_task_states[MAX_CPU_FREQ_STATE];
+	u64 powermodel_last_seq;
+	u64 last_seq;
+	struct list_head node;
+	int state;
+	int pool_id;
+};
+
+#endif
+
+
+/* Please add your own members of task_struct here :) */
+struct oplus_task_struct {
+	/* CONFIG_OPLUS_FEATURE_SCHED_ASSIST */
+	struct rb_node ux_entry;
+	struct rb_node exec_time_node;
+	struct task_struct *task;
+	atomic64_t inherit_ux;
+	u64 enqueue_time;
+	u64 inherit_ux_start;
+	/* u64 sum_exec_baseline; */
+	u64 total_exec;
+	u64 vruntime;
+	u64 preset_vruntime;
+	/* contains ux state
+	 1. if static and inherited ux both exist, static ux stores in ux_state, inherited ux in sub_ux_state.
+	 2. if only static ux exists, static ux stores in ux_state.
+	 2. if only inherited ux exists, inherited ux stores in ux_state */
+	int ux_state;
+	int sub_ux_state;
+	u8 ux_depth;
+	s8 ux_priority;
+	s8 ux_nice;
+	pid_t affinity_pid;
+	pid_t affinity_tgid;
+	unsigned long state;
+	unsigned long im_flag;
+	atomic_t is_vip_mvp;
+
+/* #if IS_ENABLED(CONFIG_OPLUS_FEATURE_SCHED_DDL) */
+	u64 ddl;
+	u64 ddl_active_ts;
+	u64 runnable_ts;
+	struct rb_node ddl_node;
+/* #endif */
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_ABNORMAL_FLAG)*/
+	int abnormal_flag;
+/*#endif*/
+	/* CONFIG_OPLUS_FEATURE_SCHED_SPREAD */
+	int lb_state;
+	int ld_flag:1;
+	/* CONFIG_OPLUS_FEATURE_TASK_LOAD */
+	int is_update_runtime:1;
+	int target_process;
+	u64 wake_tid;
+	u64 running_start_time;
+	bool update_running_start_time;
+	u64 exec_calc_runtime;
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_CPU_JANKINFO)*/
+	struct task_record record[MAX_CLUSTER];	/* 2*u64 */
+	u64 block_start_time;
+/*#endif*/
+	/* CONFIG_OPLUS_FEATURE_FRAME_BOOST */
+	struct list_head fbg_list;
+	raw_spinlock_t fbg_list_entry_lock;
+	bool fbg_running; /* task belongs to a group, and in running */
+	u16 fbg_state;
+	s8 preferred_cluster_id;
+	s8 fbg_depth;
+	u64 last_wake_ts;
+	int fbg_cur_group;
+/*#ifdef CONFIG_LOCKING_PROTECT*/
+	unsigned long locking_start_time;
+	unsigned long last_jiffies;
+	struct list_head locking_entry;
+	int locking_depth;
+	int lk_tick_hit;
+/*#endif*/
+/*#if IS_ENABLED(CONFIG_OPLUS_LOCKING_STRATEGY)*/
+	struct locking_info lkinfo;
+/*#endif*/
+/*#if IS_ENABLED(CONFIG_HMBIRD_SCHED_GKI)*/
+	struct scx_entity scx;
+/*#endif*/
+
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_FDLEAK_CHECK)*/
+	u8 fdleak_flag;
+/*#endif*/
+
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)*/
+	/* for loadbalance */
+	struct plist_node rtb;		/* rt boost task */
+
+	/*
+	 * The following variables are used to calculate the time
+	 * a task spends in the running/runnable state.
+	 */
+	u64 snap_run_delay;
+	unsigned long snap_pcount;
+/*#endif*/
+#if IS_ENABLED(CONFIG_OPLUS_SCHED_TUNE)
+	int stune_idx;
+#endif
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_PIPELINE)*/
+	atomic_t pipeline_cpu;
+/*#endif*/
+
+	/* for oplus secure guard */
+	int sg_flag;
+	int sg_scno;
+	uid_t sg_uid;
+	uid_t sg_euid;
+	gid_t sg_gid;
+	gid_t sg_egid;
+/*#if IS_ENABLED(CONFIG_ARM64_AMU_EXTN) && IS_ENABLED(CONFIG_OPLUS_FEATURE_CPU_JANKINFO)*/
+	struct uid_struct *uid_struct;
+	u64 amu_instruct;
+	u64 amu_cycle;
+/*#endif*/
+	/* for binder ux */
+	int binder_async_ux_enable;
+	bool binder_async_ux_sts;
+	int binder_thread_mode;
+	struct binder_node *binder_thread_node;
+
+/* for powermodel */
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_POWERMODEL)
+	struct powermodel_cpu_task_state *powermodel_cpu_task_states[MAX_CPU_CNT];
+	u64 exec_runtime;
+#endif
+
+#if IS_ENABLED(CONFIG_OPLUS_FEATURE_SCHED_CFBT)
+	int cfbt_cur_group;
+	bool cfbt_running;
+#endif /* CONFIG_OPLUS_FEATURE_SCHED_CFBT */
+} ____cacheline_aligned;
+
+/*#if IS_ENABLED(CONFIG_OPLUS_FEATURE_LOADBALANCE)*/
+#define INVALID_PID						(-1)
+struct oplus_lb {
+	/* used for active_balance to record the running task. */
+	pid_t pid;
+};
+/*#endif*/
+
+#endif /* _OPLUS_SA_COMMON_STRUCT_H_ */
+
diff --git a/include/linux/sched/sa_oemdata.h b/include/linux/sched/sa_oemdata.h
new file mode 100755
index 000000000000..ebbbc754e391
--- /dev/null
+++ b/include/linux/sched/sa_oemdata.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2022 Oplus. All rights reserved.
+ */
+
+
+#ifndef _OPLUS_SA_OEMDATA_H_
+#define _OPLUS_SA_OEMDATA_H_
+
+int sa_oemdata_init(void);
+void sa_oemdata_deinit(void);
+
+#endif /* _OPLUS_SA_OEMDATA_H_ */
diff --git a/include/linux/sched/sched_ext.h b/include/linux/sched/sched_ext.h
new file mode 100755
index 000000000000..9f1afdb8a04b
--- /dev/null
+++ b/include/linux/sched/sched_ext.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+#ifndef _OPLUS_SCHED_EXT_H
+#define _OPLUS_SCHED_EXT_H
+#include "sa_common.h"
+
+#define SCHED_PROP_TOP_THREAD_SHIFT (8)
+#define SCHED_PROP_TOP_THREAD_MASK  (0xf << SCHED_PROP_TOP_THREAD_SHIFT)
+#define SCHED_PROP_DEADLINE_MASK (0xFF) /* deadline for ext sched class */
+#define SCHED_PROP_DEADLINE_LEVEL1 (1)  /* 1ms for user-aware audio tasks */
+#define SCHED_PROP_DEADLINE_LEVEL2 (2)  /* 2ms for user-aware touch tasks */
+#define SCHED_PROP_DEADLINE_LEVEL3 (3)  /* 4ms for user aware dispaly tasks */
+#define SCHED_PROP_DEADLINE_LEVEL4 (4)  /* 6ms */
+#define SCHED_PROP_DEADLINE_LEVEL5 (5)  /* 8ms */
+#define SCHED_PROP_DEADLINE_LEVEL6 (6)  /* 16ms */
+#define SCHED_PROP_DEADLINE_LEVEL7 (7)  /* 32ms */
+#define SCHED_PROP_DEADLINE_LEVEL8 (8)  /* 64ms */
+#define SCHED_PROP_DEADLINE_LEVEL9 (9)  /* 128ms */
+
+static inline int sched_prop_get_top_thread_id(struct task_struct *p)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(p);
+
+	if (!ots) {
+		return -EPERM;
+	}
+
+	return ((ots->scx.sched_prop & SCHED_PROP_TOP_THREAD_MASK) >> SCHED_PROP_TOP_THREAD_SHIFT);
+}
+
+static inline int sched_set_sched_prop(struct task_struct *p, unsigned long sp)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(p);
+
+	if (!ots) {
+		pr_err("scx_sched_ext: sched_set_sched_prop failed! fn=%s\n", __func__);
+		return -EPERM;
+	}
+
+	ots->scx.sched_prop = sp;
+	return 0;
+}
+
+static inline unsigned long sched_get_sched_prop(struct task_struct *p)
+{
+	struct oplus_task_struct *ots = get_oplus_task_struct(p);
+
+	if (!ots) {
+		pr_err("scx_sched_ext: sched_get_sched_prop failed! fn=%s\n", __func__);
+		return (unsigned long)-1;
+	}
+	return ots->scx.sched_prop;
+}
+
+#endif /*_OPLUS_SCHED_EXT_H */
diff --git a/include/linux/sched/task.h b/include/linux/sched/task.h
index a23af225c898..6a5f0c0d74bd 100644
--- a/include/linux/sched/task.h
+++ b/include/linux/sched/task.h
@@ -62,6 +62,9 @@ extern void init_idle(struct task_struct *idle, int cpu);
 
 extern int sched_fork(unsigned long clone_flags, struct task_struct *p);
 extern void sched_cgroup_fork(struct task_struct *p, struct kernel_clone_args *kargs);
+#ifdef CONFIG_HMBIRD_SCHED
+extern void hmbird_cancel_fork(struct task_struct *p);
+#endif
 extern void sched_post_fork(struct task_struct *p);
 extern void sched_dead(struct task_struct *p);
 
diff --git a/include/uapi/linux/sched.h b/include/uapi/linux/sched.h
index 3bac0a8ceab2..969716ab4320 100755
--- a/include/uapi/linux/sched.h
+++ b/include/uapi/linux/sched.h
@@ -118,6 +118,7 @@ struct clone_args {
 /* SCHED_ISO: reserved but not implemented yet */
 #define SCHED_IDLE		5
 #define SCHED_DEADLINE		6
+#define SCHED_HMBIRD		7
 
 /* Can be ORed in to make sure the process is reverted back to SCHED_NORMAL on fork */
 #define SCHED_RESET_ON_FORK     0x40000000
diff --git a/kernel/Kconfig.preempt b/kernel/Kconfig.preempt
index 4ba4fd80581b..b131d5662b48 100755
--- a/kernel/Kconfig.preempt
+++ b/kernel/Kconfig.preempt
@@ -132,3 +132,33 @@ config SCHED_CORE
 	  SCHED_CORE is default disabled. When it is enabled and unused,
 	  which is the likely usage by Linux distributions, there should
 	  be no measurable impact on performance.
+
+config HMBIRD_SCHED
+	bool "hmbird Scheduling Class(base on ext scheduler)"
+	help
+	  This option enables a new scheduler class sched_ext (SCX), which
+	  allows scheduling policies to be implemented as BPF programs to
+	  achieve the following:
+
+	  - Ease of experimentation and exploration: Enabling rapid
+	    iteration of new scheduling policies.
+	  - Customization: Building application-specific schedulers which
+	    implement policies that are not applicable to general-purpose
+	    schedulers.
+	  - Rapid scheduler deployments: Non-disruptive swap outs of
+	    scheduling policies in production environments.
+
+	  sched_ext leverages BPFs struct_ops feature to define a structure
+	  which exports function callbacks and flags to BPF programs that
+	  wish to implement scheduling policies. The struct_ops structure
+	  exported by sched_ext is struct sched_ext_ops, and is conceptually
+	  similar to struct sched_class.
+
+	  See Documentation/scheduler/sched-ext.rst for more details.
+
+config DYNAMIC_WALT_SUPPORT
+	bool "Dynamic WALT Support for Extensible Scheduling Class"
+	depends on HMBIRD_SCHED
+	default n
+	help
+	  Enable dynamic WALT support for Extensible Scheduling Class.
diff --git a/kernel/fork.c b/kernel/fork.c
index 4bcd5b98eadd..6a393a0d638e 100755
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -23,6 +23,9 @@
 #include <linux/sched/task.h>
 #include <linux/sched/task_stack.h>
 #include <linux/sched/cputime.h>
+#ifdef CONFIG_HMBIRD_SCHED
+#include <linux/sched/hmbird.h>
+#endif
 #include <linux/seq_file.h>
 #include <linux/rtmutex.h>
 #include <linux/init.h>
@@ -995,6 +998,10 @@ void __put_task_struct(struct task_struct *tsk)
 	WARN_ON(!tsk->exit_state);
 	WARN_ON(refcount_read(&tsk->usage));
 	WARN_ON(tsk == current);
+
+#ifdef CONFIG_HMBIRD_SCHED
+	hmbird_free(tsk);
+#endif
 	io_uring_free(tsk);
 	cgroup_free(tsk);
 	task_numa_free(tsk, true);
@@ -2505,7 +2512,11 @@ __latent_entropy struct task_struct *copy_process(
 
 	retval = perf_event_init_task(p, clone_flags);
 	if (retval)
+#ifdef CONFIG_HMBIRD_SCHED
+		goto bad_fork_hmbird_cancel_fork;
+#else
 		goto bad_fork_cleanup_policy;
+#endif
 	retval = audit_alloc(p);
 	if (retval)
 		goto bad_fork_cleanup_perf;
@@ -2808,6 +2819,10 @@ __latent_entropy struct task_struct *copy_process(
 	audit_free(p);
 bad_fork_cleanup_perf:
 	perf_event_free_task(p);
+#ifdef CONFIG_HMBIRD_SCHED
+bad_fork_hmbird_cancel_fork:
+	hmbird_cancel_fork(p);
+#endif
 bad_fork_cleanup_policy:
 	lockdep_free_task(p);
 #ifdef CONFIG_NUMA
diff --git a/kernel/sched/build_policy.c b/kernel/sched/build_policy.c
index c073bc56a87c..c091539a0f60 100755
--- a/kernel/sched/build_policy.c
+++ b/kernel/sched/build_policy.c
@@ -28,6 +28,10 @@
 #include <linux/suspend.h>
 #include <linux/tsacct_kern.h>
 #include <linux/vtime.h>
+#ifdef CONFIG_HMBIRD_SCHED
+#include <linux/sysrq.h>
+#include <linux/percpu-rwsem.h>
+#endif
 
 #include <uapi/linux/sched/types.h>
 
@@ -51,3 +55,11 @@
 
 #include "cputime.c"
 #include "deadline.c"
+
+#ifdef CONFIG_HMBIRD_SCHED
+#include "hmbird/hmbird_util_track.c"
+#include "hmbird/hmbird_sched_proc.c"
+#include "hmbird/hmbird_shadow_tick.c"
+#include "hmbird/hmbird.c"
+#include "hmbird/hmbird_misc.c"
+#endif
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 1924fd95d991..716788a51a5e 100755
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -96,6 +96,12 @@
 #include "../../io_uring/io-wq.h"
 #include "../smpboot.h"
 
+#ifdef CONFIG_HMBIRD_SCHED
+#include "hmbird/slim.h"
+#include "hmbird/hmbird_shadow_tick.h"
+#include "hmbird.h"
+#endif
+
 #include <trace/hooks/sched.h>
 #include <trace/hooks/cgroup.h>
 #include <trace/hooks/dtask.h>
@@ -182,6 +188,11 @@ static inline int __task_prio(const struct task_struct *p)
 	if (p->sched_class == &idle_sched_class)
 		return MAX_RT_PRIO + NICE_WIDTH; /* 140 */
 
+#ifdef CONFIG_HMBIRD_SCHED
+	if (p->sched_class == &hmbird_sched_class)
+		return MAX_RT_PRIO + MAX_NICE + 1; /* 120, squash ext */
+#endif
+
 	return MAX_RT_PRIO + MAX_NICE; /* 119, squash fair */
 }
 
@@ -211,6 +222,11 @@ static inline bool prio_less(const struct task_struct *a,
 	if (pa == MAX_RT_PRIO + MAX_NICE)	/* fair */
 		return cfs_prio_less(a, b, in_fi);
 
+#ifdef CONFIG_HMBIRD_SCHED
+	if (pa == MAX_RT_PRIO + MAX_NICE + 1)	/* ext */
+		return hmbird_prio_less(a, b, in_fi);
+#endif
+
 	return false;
 }
 
@@ -1265,6 +1281,18 @@ bool sched_can_stop_tick(struct rq *rq)
 	if (fifo_nr_running)
 		return true;
 
+#ifdef CONFIG_HMBIRD_SCHED
+	/*
+	 * If there are no DL,RR/FIFO tasks, there must only be CFS or HMBIRD tasks
+	 * left. For CFS, if there's more than one we need the tick for
+	 * involuntary preemption. For HMBIRD, ask.
+	 */
+	if (!hmbird_enabled() && rq->nr_running > 1)
+		return false;
+
+	if (hmbird_enabled() && !hmbird_can_stop_tick(rq))
+		return false;
+#else
 	/*
 	 * If there are no DL,RR/FIFO tasks, there must only be CFS tasks left;
 	 * if there's more than one we need the tick for involuntary
@@ -1272,7 +1300,7 @@ bool sched_can_stop_tick(struct rq *rq)
 	 */
 	if (rq->nr_running > 1)
 		return false;
-
+#endif
 	/*
 	 * If there is one task and it has CFS runtime bandwidth constraints
 	 * and it's on the cpu now we don't want to stop the tick.
@@ -2197,6 +2225,42 @@ void deactivate_task(struct rq *rq, struct task_struct *p, int flags)
 }
 EXPORT_SYMBOL_GPL(deactivate_task);
 
+#ifdef CONFIG_HMBIRD_SCHED
+struct hmbird_sched_change_guard
+hmbird_sched_change_guard_init(struct rq *rq, struct task_struct *p, int flags)
+{
+	struct hmbird_sched_change_guard cg = {
+		.rq = rq,
+		.p = p,
+		.queued = task_on_rq_queued(p),
+		.running = task_current(rq, p),
+	};
+
+	if (cg.queued) {
+		/*
+		 * __kthread_bind() may call this on blocked tasks without
+		 * holding rq->lock through __do_set_cpus_allowed(). Assert @rq
+		 * locked iff @p is queued.
+		 */
+		lockdep_assert_rq_held(rq);
+		dequeue_task(rq, p, flags);
+	}
+	if (cg.running)
+		put_prev_task(rq, p);
+
+	return cg;
+}
+
+void hmbird_sched_change_guard_fini(struct hmbird_sched_change_guard *cg, int flags)
+{
+	if (cg->queued)
+		enqueue_task(cg->rq, cg->p, flags | ENQUEUE_NOCLOCK);
+	if (cg->running)
+		set_next_task(cg->rq, cg->p);
+	cg->done = true;
+}
+#endif
+
 static inline int __normal_prio(int policy, int rt_prio, int nice)
 {
 	int prio;
@@ -3731,7 +3795,11 @@ int select_task_rq(struct task_struct *p, int cpu, int wake_flags)
 	 * [ this allows ->select_task() to simply return task_cpu(p) and
 	 *   not worry about this generic constraint ]
 	 */
+#ifdef CONFIG_HMBIRD_SCHED
+	if (unlikely(!is_cpu_allowed(p, cpu)) && (p->sched_class != &hmbird_sched_class))
+#else
 	if (unlikely(!is_cpu_allowed(p, cpu)))
+#endif
 		cpu = select_fallback_rq(task_cpu(p), p);
 
 	return cpu;
@@ -4850,6 +4918,9 @@ late_initcall(sched_core_sysctl_init);
 int sched_fork(unsigned long clone_flags, struct task_struct *p)
 {
 
+#ifdef CONFIG_HMBIRD_SCHED
+	int ret;
+#endif
 
 	trace_android_rvh_sched_fork(p);
 
@@ -4890,13 +4961,29 @@ int sched_fork(unsigned long clone_flags, struct task_struct *p)
 		p->sched_reset_on_fork = 0;
 	}
 
+#ifdef CONFIG_HMBIRD_SCHED
+	ret = hmbird_pre_fork(p);
+	if (ret)
+		goto out_cancel;
+
+	if (dl_prio(p->prio)) {
+		ret = -EAGAIN;
+		goto out_cancel;
+	} else if (task_on_hmbird(p)) {
+		p->sched_class = &hmbird_sched_class;
+	} else if (rt_prio(p->prio)) {
+		p->sched_class = &rt_sched_class;
+	else
+		p->sched_class = &fair_sched_class;
+	}
+#else
 	if (dl_prio(p->prio))
 		return -EAGAIN;
 	else if (rt_prio(p->prio))
 		p->sched_class = &rt_sched_class;
 	else
 		p->sched_class = &fair_sched_class;
-
+#endif
 	init_entity_runnable_average(&p->se);
 	trace_android_rvh_finish_prio_fork(p);
 
@@ -4915,6 +5002,11 @@ int sched_fork(unsigned long clone_flags, struct task_struct *p)
 #endif
 	return 0;
 
+#ifdef CONFIG_HMBIRD_SCHED
+out_cancel:
+	hmbird_cancel_fork(p);
+	return ret;
+#endif
 }
 
 void sched_cgroup_fork(struct task_struct *p, struct kernel_clone_args *kargs)
@@ -4944,12 +5036,17 @@ void sched_cgroup_fork(struct task_struct *p, struct kernel_clone_args *kargs)
 	if (p->sched_class->task_fork)
 		p->sched_class->task_fork(p);
 	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
+#ifdef CONFIG_HMBIRD_SCHED
+	hmbird_fork(p);
+#endif
 }
 
 void sched_post_fork(struct task_struct *p)
 {
 	uclamp_post_fork(p);
-
+#ifdef CONFIG_HMBIRD_SCHED
+	hmbird_post_fork(p);
+#endif
 }
 
 unsigned long to_ratio(u64 period, u64 runtime)
@@ -5814,17 +5911,28 @@ void scheduler_tick(void)
 	if (sched_feat(LATENCY_WARN) && resched_latency)
 		resched_latency_warn(cpu, resched_latency);
 
+#ifdef CONFIG_HMBIRD_SCHED
+	hmbird_notify_sched_tick();
+#endif
 	perf_event_task_tick();
 
 	if (curr->flags & PF_WQ_WORKER)
 		wq_worker_tick(curr);
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_HMBIRD_SCHED
+	if (!hmbird_enabled()) {
+#endif
 		rq->idle_balance = idle_cpu(cpu);
 		trigger_load_balance(rq);
+#ifdef CONFIG_HMBIRD_SCHED
+	}
+#endif
 #endif
 	trace_android_vh_scheduler_tick(rq);
-
+#ifdef CONFIG_HMBIRD_SCHED
+	scheduler_tick_handler(NULL, NULL);
+#endif
 }
 
 #ifdef CONFIG_NO_HZ_FULL
@@ -6126,8 +6234,11 @@ static void put_prev_task_balance(struct rq *rq, struct task_struct *prev,
 	 * We can terminate the balance pass as soon as we know there is
 	 * a runnable task of @class priority or higher.
 	 */
-
+#ifdef CONFIG_HMBIRD_SCHED
+	for_balance_class_range(class, prev->sched_class, &idle_sched_class) {
+#else
 	for_class_range(class, prev->sched_class, &idle_sched_class) {
+#endif
 		if (class->balance(rq, prev, rf))
 			break;
 	}
@@ -6145,6 +6256,10 @@ __pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
 	const struct sched_class *class;
 	struct task_struct *p;
 
+#ifdef CONFIG_HMBIRD_SCHED
+	if (hmbird_enabled())
+		goto restart;
+#endif
 	/*
 	 * Optimization: we know that if all tasks are in the fair class we can
 	 * call that function directly, but only if the @prev task wasn't of a
@@ -6170,11 +6285,20 @@ __pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
 restart:
 	put_prev_task_balance(rq, prev, rf);
 
+#ifdef CONFIG_HMBIRD_SCHED
+	for_each_active_class(class) {
+		p = class->pick_next_task(rq);
+		if (p) {
+			hmbird_notify_pick_next_task(rq, p, class);
+			return p;
+	}
+#else
 	for_each_class(class) {
 		p = class->pick_next_task(rq);
 		if (p)
 			return p;
 	}
+#endif
 
 	BUG(); /* The idle class should always have a runnable task. */
 }
@@ -6203,8 +6327,11 @@ static inline struct task_struct *pick_task(struct rq *rq)
 	const struct sched_class *class;
 	struct task_struct *p;
 
-
+#ifdef CONFIG_HMBIRD_SCHED
+	for_each_active_class(class) {
+#else
 	for_each_class(class) {
+#endif
 		p = class->pick_task(rq);
 		if (p)
 			return p;
@@ -6848,6 +6975,9 @@ static void __sched notrace __schedule(unsigned int sched_mode)
 		psi_sched_switch(prev, next, !task_on_rq_queued(prev));
 
 		trace_sched_switch(sched_mode & SM_MASK_PREEMPT, prev, next, prev_state);
+#ifdef CONFIG_HMBIRD_SCHED
+		sched_switch_handler(NULL, sched_mode & SM_MASK_PREEMPT, prev, next, prev_state);
+#endif
 
 		/* Also unlocks the rq: */
 		rq = context_switch(rq, prev, next, &rf);
@@ -7178,12 +7308,29 @@ EXPORT_SYMBOL(default_wake_function);
 
 static void __setscheduler_prio(struct task_struct *p, int prio)
 {
+#ifdef CONFIG_HMBIRD_SCHED
+	bool on_hmbird = task_on_hmbird(p);
+
+	if (p->sched_class == &stop_sched_class)
+		;
+	else if (dl_prio(prio))
+		p->sched_class = &dl_sched_class;
+	else if (rt_prio(prio) && on_hmbird)
+		p->sched_class = &hmbird_sched_class;
+	else if (rt_prio(prio))
+		p->sched_class = &rt_sched_class;
+	else if (on_hmbird)
+		p->sched_class = &hmbird_sched_class;
+	else
+		p->sched_class = &fair_sched_class;
+#else
 	if (dl_prio(prio))
 		p->sched_class = &dl_sched_class;
 	else if (rt_prio(prio))
 		p->sched_class = &rt_sched_class;
 	else
 		p->sched_class = &fair_sched_class;
+#endif
 
 	p->prio = prio;
 }
@@ -7808,6 +7955,9 @@ static int __sched_setscheduler(struct task_struct *p,
 	int queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;
 	struct rq *rq;
 	bool cpuset_locked = false;
+#ifdef CONFIG_HMBIRD_SCHED
+	unsigned long flags;
+#endif
 
 
 	/* The pi code expects interrupts enabled */
@@ -7874,7 +8024,9 @@ static int __sched_setscheduler(struct task_struct *p,
 	 * To be able to change p->policy safely, the appropriate
 	 * runqueue lock must be held.
 	 */
-
+#ifdef CONFIG_HMBIRD_SCHED
+	spin_lock_irqsave(&hmbird_tasks_lock, flags);
+#endif
 	rq = task_rq_lock(p, &rf);
 	update_rq_clock(rq);
 
@@ -7886,6 +8038,11 @@ static int __sched_setscheduler(struct task_struct *p,
 		goto unlock;
 	}
 
+#ifdef CONFIG_HMBIRD_SCHED
+	retval = hmbird_check_setscheduler(p, policy);
+	if (retval)
+		goto unlock;
+#endif
 	/*
 	 * If not changing anything there's no need to proceed further,
 	 * but store a possible modification of reset_on_fork.
@@ -7942,7 +8099,9 @@ static int __sched_setscheduler(struct task_struct *p,
 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {
 		policy = oldpolicy = -1;
 		task_rq_unlock(rq, p, &rf);
-
+#ifdef CONFIG_HMBIRD_SCHED
+		spin_unlock_irqrestore(&hmbird_tasks_lock, flags);
+#endif
 		if (cpuset_locked)
 			cpuset_unlock();
 		goto recheck;
@@ -8010,7 +8169,9 @@ static int __sched_setscheduler(struct task_struct *p,
 	preempt_disable();
 	head = splice_balance_callbacks(rq);
 	task_rq_unlock(rq, p, &rf);
-
+#ifdef CONFIG_HMBIRD_SCHED
+	spin_unlock_irqrestore(&hmbird_tasks_lock, flags);
+#endif
 	if (pi) {
 		if (cpuset_locked)
 			cpuset_unlock();
@@ -8025,7 +8186,9 @@ static int __sched_setscheduler(struct task_struct *p,
 
 unlock:
 	task_rq_unlock(rq, p, &rf);
-
+#ifdef CONFIG_HMBIRD_SCHED
+	spin_unlock_irqrestore(&hmbird_tasks_lock, flags);
+#endif
 	if (cpuset_locked)
 		cpuset_unlock();
 	return retval;
@@ -9247,6 +9410,9 @@ SYSCALL_DEFINE1(sched_get_priority_max, int, policy)
 	case SCHED_NORMAL:
 	case SCHED_BATCH:
 	case SCHED_IDLE:
+#ifdef CONFIG_HMBIRD_SCHED
+	case SCHED_HMBIRD:
+#endif
 		ret = 0;
 		break;
 	}
@@ -9274,6 +9440,9 @@ SYSCALL_DEFINE1(sched_get_priority_min, int, policy)
 	case SCHED_NORMAL:
 	case SCHED_BATCH:
 	case SCHED_IDLE:
+#ifdef CONFIG_HMBIRD_SCHED
+	case SCHED_HMBIRD:
+#endif
 		ret = 0;
 	}
 	return ret;
@@ -10162,11 +10331,22 @@ void __init sched_init(void)
 	int i;
 
 	/* Make sure the linker didn't screw up */
+#ifdef CONFIG_HMBIRD_SCHED
+#ifdef CONFIG_SMP
+	WARN_ON_ONCE(!sched_class_above(&stop_sched_class, &dl_sched_class));
+#endif
+	WARN_ON_ONCE(!sched_class_above(&dl_sched_class, &rt_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&rt_sched_class, &fair_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&fair_sched_class, &idle_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&fair_sched_class, &hmbird_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&hmbird_sched_class, &idle_sched_class));
+#else
 	BUG_ON(&idle_sched_class != &fair_sched_class + 1 ||
 	       &fair_sched_class != &rt_sched_class + 1 ||
 	       &rt_sched_class   != &dl_sched_class + 1);
 #ifdef CONFIG_SMP
 	BUG_ON(&dl_sched_class != &stop_sched_class + 1);
+#endif
 #endif
 
 	wait_bit_init();
@@ -10337,7 +10517,9 @@ void __init sched_init(void)
 	balance_push_set(smp_processor_id(), false);
 #endif
 	init_sched_fair_class();
-
+#ifdef CONFIG_HMBIRD_SCHED
+	init_sched_hmbird_class();
+#endif
 	psi_init();
 
 	init_uclamp();
@@ -10823,6 +11005,10 @@ static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)
 	struct task_group *tg = css_tg(css);
 	struct task_group *parent = css_tg(css->parent);
 
+#ifdef CONFIG_HMBIRD_SCHED
+	hmbird_tg_online(tg);
+#endif
+
 	if (parent)
 		sched_online_group(tg, parent);
 
@@ -10872,13 +11058,77 @@ static int cpu_cgroup_can_attach(struct cgroup_taskset *tset)
 }
 #endif
 
+#ifdef CONFIG_HMBIRD_SCHED
+static inline void update_cgroup_ids_table(int ids, u8 hmbird_cgroup_deadline_idx)
+{
+	if (ids < 0 || ids >= NUMS_CGROUP_KINDS) {
+		pr_err("update_cgroup_ids_tab idx err!\n");
+		return;
+	}
+	cgroup_ids_table[ids] = hmbird_cgroup_deadline_idx;
+}
+
+static int cgroup_write_hmbird_deadline(struct cgroup_subsys_state *css,
+						struct cftype *cftype, u64 dl)
+{
+	int i;
+
+	for (i = MIN_CGROUP_DL_IDX; i < MAX_GLOBAL_DSQS; ++i) {
+		if (dl < HMBIRD_BPF_DSQS_DEADLINE[i])
+			break;
+	}
+
+	i = max_t(int, i-1, MIN_CGROUP_DL_IDX);
+	if (!css || !css->cgroup || !css->cgroup->kn)
+		return 0;
+	update_cgroup_ids_table(css->cgroup->kn->id, i);
+
+	return 0;
+}
+
+static u64 cgroup_read_hmbird_deadline(struct cgroup_subsys_state *css,
+						struct cftype *cft)
+{
+	u8 i;
+
+	if (!css || !css->cgroup || !css->cgroup->kn)
+		return (u64) HMBIRD_BPF_DSQS_DEADLINE[DEFAULT_CGROUP_DL_IDX];
+	i = min_t(u8, cgroup_ids_table[css->cgroup->kn->id], MAX_GLOBAL_DSQS-1);
+	if (i < 0) {
+		pr_err("<sched_ext> <%s> i is %d, less than 0, name is %s\n",
+			__func__, i, css->cgroup->kn->name);
+		i = DEFAULT_CGROUP_DL_IDX;
+	}
+
+	return (u64) HMBIRD_BPF_DSQS_DEADLINE[i];
+}
+
+static void hmbird_change_rt_sched_prop(struct cgroup_subsys_state *css,
+						struct task_struct *p, int prio)
+{
+	if (!css || !rt_prio(prio))
+		return;
+
+	if (!(hmbird_get_sched_prop(p) & SCHED_PROP_DEADLINE_MASK)) {
+		if (!strcmp(css->cgroup->kn->name, "display"))
+			hmbird_set_sched_prop(p, SCHED_PROP_DEADLINE_LEVEL3);
+		else if (!strcmp(css->cgroup->kn->name, "touch"))
+			hmbird_set_sched_prop(p, SCHED_PROP_DEADLINE_LEVEL2);
+		else if (!strcmp(css->cgroup->kn->name, "multimedia"))
+			hmbird_set_sched_prop(p, SCHED_PROP_DEADLINE_LEVEL1);
+	}
+}
+#endif
+
 static void cpu_cgroup_attach(struct cgroup_taskset *tset)
 {
 	struct task_struct *task;
 	struct cgroup_subsys_state *css;
 
 	cgroup_taskset_for_each(task, css, tset) {
-
+#ifdef CONFIG_HMBIRD_SCHED
+		hmbird_change_rt_sched_prop(css, task, task->prio);
+#endif
 		sched_move_task(task);
 	}
 
@@ -11560,7 +11810,13 @@ static struct cftype cpu_legacy_files[] = {
 		.write_u64 = cpu_uclamp_ls_write_u64,
 	},
 #endif
-
+#ifdef CONFIG_HMBIRD_SCHED
+	{
+		.name = "hmbird.deadline",
+		.read_u64 = cgroup_read_hmbird_deadline,
+		.write_u64 = cgroup_write_hmbird_deadline,
+	},
+#endif
 	{ }	/* Terminate */
 };
 
diff --git a/kernel/sched/debug.c b/kernel/sched/debug.c
index 0926c682cbae..2fe1a734e640 100755
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@ -375,6 +375,10 @@ static __init int sched_init_debug(void)
 #endif
 
 	debugfs_create_file("debug", 0444, debugfs_sched, NULL, &sched_debug_fops);
+
+#ifdef CONFIG_HMBIRD_SCHED
+	debugfs_create_file("hmbird", 0444, debugfs_sched, NULL, &sched_hmbird_fops);
+#endif
 	return 0;
 }
 late_initcall(sched_init_debug);
@@ -1095,6 +1099,11 @@ void proc_sched_show_task(struct task_struct *p, struct pid_namespace *ns,
 		P(dl.runtime);
 		P(dl.deadline);
 	}
+#ifdef CONFIG_HMBIRD_SCHED
+	__PS("hmbird.enabled", p->sched_class == &hmbird_sched_class);
+	__PS("sched_prop", get_hmbird_ts(p)->sched_prop);
+	__PS("top_task_prop", get_hmbird_ts(p)->top_task_prop);
+#endif
 #undef PN_SCHEDSTAT
 #undef P_SCHEDSTAT
 
diff --git a/kernel/sched/hmbird.h b/kernel/sched/hmbird.h
new file mode 100755
index 000000000000..d0d84ddee13d
--- /dev/null
+++ b/kernel/sched/hmbird.h
@@ -0,0 +1,343 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * HMBIRD scheduler class
+ *
+ * Copyright (c) 2024 OPlus.
+ * Copyright (c) 2024 Dao Huang
+ * Copyright (c) 2024 Yuxing Wang
+ * Copyright (c) 2024 Taiyu Li
+ */
+
+#ifndef _HMBIRD_H_
+#define _HMBIRD_H_
+
+/*
+ * Tag marking a kernel function as a kfunc. This is meant to minimize the
+ * amount of copy-paste that kfunc authors have to include for correctness so
+ * as to avoid issues such as the compiler inlining or eliding either a static
+ * kfunc, or a global kfunc in an LTO build.
+ */
+
+#define DEBUG_INTERNAL		(1 << 0)
+#define	DEBUG_INFO_TRACE	(1 << 1)
+#define DEBUG_INFO_SYSTRACE	(1 << 2)
+
+#define NUMS_CGROUP_KINDS	(512)
+#define SLIM_FOR_SGAME		(1 << 0)
+#define SLIM_FOR_GENSHIN	(1 << 1)
+
+#ifdef MAX_TASK_NR
+#define MAX_KEY_THREAD_RECORD		((MAX_TASK_NR + 1) >> 1)
+#else
+#define MAX_KEY_THREAD_RECORD		(1 << 3)
+#endif /* MAX_TASK_NR */
+
+#define TOP_TASK_SHIFT				(8)
+#define TOP_TASK_MAX				(1 << TOP_TASK_SHIFT)
+#ifndef TOP_TASK_BITS_MASK
+#define	TOP_TASK_BITS_MASK			(TOP_TASK_MAX - 1)
+#endif /* TOP_TASK_BITS_MASK */
+
+extern struct md_info_t *md_info;
+
+#define debug_enabled()	\
+	(unlikely(hmbirdcore_debug))
+
+#define hmbird_debug(fmt, ...)	\
+	pr_info("<hmbird_sched>:"fmt, ##__VA_ARGS__)
+
+#define hmbird_err(id, fmt, ...) \
+do {							\
+	pr_err("<hmbird_sched>"fmt, ##__VA_ARGS__);	\
+	exceps_update(md_info, id, jiffies);	\
+} while (0)
+
+#define hmbird_deferred_err(id, fmt, ...) \
+do {					\
+	printk_deferred("<hmbird_sched>"fmt, ##__VA_ARGS__);	\
+	exceps_update(md_info, id, jiffies);	\
+} while (0)
+
+#define hmbird_cond_deferred_err(id, cond, fmt, ...) \
+do {							\
+	if (unlikely(cond)) {				\
+		hmbird_deferred_err(id, #cond","fmt, ##__VA_ARGS__);	\
+		exceps_update(md_info, id, jiffies);	\
+	}							\
+} while (0)
+
+#ifdef CONFIG_HMBIRD_DEBUG_MODE
+#define hmbird_info_trace(fmt, ...)			\
+do {						\
+	if (unlikely(hmbirdcore_debug & DEBUG_INFO_TRACE))		\
+		trace_printk("<hmbird_sched>:"fmt, ##__VA_ARGS__); \
+} while (0)
+#else
+#define hmbird_info_trace(fmt, ...)
+#endif
+
+#define hmbird_info_systrace(fmt, ...)	\
+do {					\
+	if (unlikely(hmbirdcore_debug & DEBUG_INFO_SYSTRACE)) {	\
+		char buf[256];		\
+		snprintf(buf, sizeof(buf), fmt, ##__VA_ARGS__);	\
+		tracing_mark_write(buf);			\
+	}				\
+} while (0)
+
+#define hmbird_output_systrace(fmt, ...)	\
+do {					\
+	char buf[256];		\
+	snprintf(buf, sizeof(buf), fmt, ##__VA_ARGS__);	\
+	tracing_mark_write(buf);			\
+} while (0)
+
+#ifdef CONFIG_HMBIRD_DEBUG_MODE
+#define hmbird_internal_trace(fmt, ...)			\
+do {						\
+	if (unlikely(hmbirdcore_debug & DEBUG_INTERNAL))		\
+		trace_printk("<hmbird_sched>:"fmt, ##__VA_ARGS__); \
+} while (0)
+#else
+#define hmbird_internal_trace(fmt, ...)
+#endif
+
+#define hmbird_internal_systrace(fmt, ...)			\
+do {								\
+	if (unlikely(hmbirdcore_debug & DEBUG_INTERNAL)) {	\
+		hmbird_output_systrace(fmt, ##__VA_ARGS__);	\
+	}							\
+} while (0)
+
+enum hmbird_wake_flags {
+	/* expose select WF_* flags as enums */
+	HMBIRD_WAKE_EXEC		= WF_EXEC,
+	HMBIRD_WAKE_FORK		= WF_FORK,
+	HMBIRD_WAKE_TTWU		= WF_TTWU,
+	HMBIRD_WAKE_SYNC		= WF_SYNC,
+};
+
+enum hmbird_enq_flags {
+	/* expose select ENQUEUE_* flags as enums */
+	HMBIRD_ENQ_WAKEUP		= ENQUEUE_WAKEUP,
+	HMBIRD_ENQ_HEAD		= ENQUEUE_HEAD,
+
+	/* high 32bits are HMBIRD specific */
+
+	/*
+	 * Set the following to trigger preemption when calling
+	 * hmbird_bpf_dispatch() with a local dsq as the target. The slice of the
+	 * current task is cleared to zero and the CPU is kicked into the
+	 * scheduling path. Implies %HMBIRD_ENQ_HEAD.
+	 */
+	HMBIRD_ENQ_PREEMPT		= 1LLU << 32,
+	HMBIRD_ENQ_REENQ		= 1LLU << 40,
+	HMBIRD_ENQ_LAST		= 1LLU << 41,
+
+	/*
+	 * A hint indicating that it's advisable to enqueue the task on the
+	 * local dsq of the currently selected CPU. Currently used by
+	 * select_cpu_dfl() and together with %HMBIRD_ENQ_LAST.
+	 */
+	HMBIRD_ENQ_LOCAL		= 1LLU << 42,
+
+	/* high 8 bits are internal */
+	__HMBIRD_ENQ_INTERNAL_MASK	= 0xffLLU << 56,
+
+	HMBIRD_ENQ_CLEAR_OPSS	= 1LLU << 56,
+	HMBIRD_ENQ_DSQ_PRIQ	= 1LLU << 57,
+};
+
+enum hmbird_deq_flags {
+	/* expose select DEQUEUE_* flags as enums */
+	HMBIRD_DEQ_SLEEP		= DEQUEUE_SLEEP,
+
+	/* high 32bits are HMBIRD specific */
+
+	/*
+	 * The generic core-sched layer decided to execute the task even though
+	 * it hasn't been dispatched yet. Dequeue from the BPF side.
+	 */
+	HMBIRD_DEQ_CORE_SCHED_EXEC	= 1LLU << 32,
+};
+
+enum hmbird_kick_flags {
+	HMBIRD_KICK_PREEMPT	= 1LLU << 0,	/* force scheduling on the CPU */
+	HMBIRD_KICK_WAIT		= 1LLU << 1,	/* wait for the CPU to be rescheduled */
+};
+
+enum hmbird_task_prop_type {
+	HMBIRD_TASK_PROP_COMMON,
+	HMBIRD_TASK_PROP_PIPELINE,
+	HMBIRD_TASK_PROP_DEBUG_OR_LOG,
+	HMBIRD_TASK_PROP_HIGH_LOAD,
+	HMBIRD_TASK_PROP_IO,
+	HMBIRD_TASK_PROP_NETWORK,
+	HMBIRD_TASK_PROP_PERIODIC,
+	HMBIRD_TASK_PROP_PERIODIC_AND_CRITICAL,
+	HMBIRD_TASK_PROP_TRANSIENT_AND_CRITICAL,
+	HMBIRD_TASK_PROP_ISOLATE,
+	HMBIRD_TASK_PROP_MAX,
+};
+
+enum hmbird_preempt_policy_id {
+	HMBIRD_PREEMPT_POLICY_NONE,
+	HMBIRD_PREEMPT_POLICY_PRIO_BASED,
+};
+
+extern const struct sched_class hmbird_sched_class;
+extern const struct bpf_verifier_ops bpf_sched_hmbird_verifier_ops;
+extern const struct file_operations sched_hmbird_fops;
+extern unsigned long hmbird_watchdog_timeout;
+extern unsigned long hmbird_watchdog_timestamp;
+
+enum scx_rq_flags {
+	HMBIRD_RQ_CAN_STOP_TICK	= 1 << 0,
+};
+
+struct hmbird_rq {
+	struct hmbird_dispatch_q	local_dsq;
+	struct list_head	watchdog_list;
+	u64			ops_qseq;
+	u64			extra_enq_flags;	/* see move_task_to_local_dsq() */
+	u32			nr_running;
+	u32			flags;
+	bool			cpu_released;
+	cpumask_var_t		cpus_to_kick;
+	cpumask_var_t		cpus_to_preempt;
+	cpumask_var_t		cpus_to_wait;
+	u64			pnt_seq;
+	u64			*prev_runnable_sum_fixed;
+	u32			*prev_window_size;
+	struct irq_work		kick_cpus_irq_work;
+	bool			pipeline;
+	bool			exclusive;
+	bool			period_disallow;
+	bool			nonperiod_disallow;
+	struct rq		*rq;
+	struct hmbird_sched_rq_stats	*srq;
+};
+
+struct hmbird_sched_change_guard {
+	struct task_struct		*p;
+	struct rq				*rq;
+	bool					queued;
+	bool					running;
+	bool					done;
+};
+
+extern struct hmbird_sched_change_guard
+hmbird_sched_change_guard_init(struct rq *rq, struct task_struct *p, int flags);
+
+extern void hmbird_sched_change_guard_fini(struct hmbird_sched_change_guard *cg, int flags);
+
+#define SCHED_CHANGE_BLOCK(__rq, __p, __flags)				\
+	for (struct hmbird_sched_change_guard __cg =			\
+			hmbird_sched_change_guard_init(__rq, __p, __flags);			\
+		!__cg.done; hmbird_sched_change_guard_fini(&__cg, __flags))
+
+DECLARE_STATIC_KEY_FALSE(hmbird_ops_cpu_preempt);
+
+bool task_on_hmbird(struct task_struct *p);
+int hmbird_pre_fork(struct task_struct *p);
+int hmbird_fork(struct task_struct *p);
+void hmbird_post_fork(struct task_struct *p);
+void hmbird_cancel_fork(struct task_struct *p);
+int hmbird_check_setscheduler(struct task_struct *p, int policy);
+bool hmbird_can_stop_tick(struct rq *rq);
+void init_sched_hmbird_class(void);
+
+void hmbird_ops_exit(void);
+#define hmbird_ops_error(fmt, ...)						\
+do {										\
+	hmbird_deferred_err(HMBIRD_OPS_ERR, fmt, ##__VA_ARGS__);                      \
+	hmbird_ops_exit();				\
+} while (0)
+
+void __hmbird_notify_pick_next_task(struct rq *rq,
+				 struct task_struct *p,
+				 const struct sched_class *active);
+
+static inline unsigned long hmbird_sched_weight_to_cgroup(unsigned long weight)
+{
+	return clamp_t(unsigned long,
+			DIV_ROUND_CLOSEST_ULL(weight * CGROUP_WEIGHT_DFL, 1024),
+			CGROUP_WEIGHT_MIN, CGROUP_WEIGHT_MAX);
+}
+
+static inline void hmbird_notify_pick_next_task(struct rq *rq,
+						struct task_struct *p,
+						const struct sched_class *active)
+{
+	if (!hmbird_enabled())
+		return;
+#ifdef CONFIG_SMP
+	/*
+	 * Pairs with the smp_load_acquire() issued by a CPU in
+	 * kick_cpus_irq_workfn() who is waiting for this CPU to perform a
+	 * resched.
+	 */
+	smp_store_release(&get_hmbird_rq(rq)->pnt_seq, get_hmbird_rq(rq)->pnt_seq + 1);
+#endif
+	if (!static_branch_unlikely(&hmbird_ops_cpu_preempt))
+		return;
+	__hmbird_notify_pick_next_task(rq, p, active);
+}
+
+extern void hmbird_scheduler_tick(void);
+void scan_timeout(struct rq *rq);
+void hmbird_notify_sched_tick(void);
+
+static inline const struct sched_class *next_active_class(const struct sched_class *class)
+{
+	class++;
+
+	if (hmbird_enabled() && class == &fair_sched_class)
+		class++;
+	if (!hmbird_enabled() && class == &hmbird_sched_class)
+		class++;
+	return class;
+}
+
+#define for_active_class_range(class, _from, _to)				\
+	for (class = (_from); class != (_to); class = next_active_class(class))
+
+#define for_each_active_class(class)						\
+	for_active_class_range(class, __sched_class_highest, __sched_class_lowest)
+
+/*
+ * HMBIRD requires a balance() call before every pick_next_task() call including
+ * when waking up from idle.
+ */
+#define for_balance_class_range(class, prev_class, end_class)			\
+	for_active_class_range(class, (prev_class) > &hmbird_sched_class ?		\
+				&hmbird_sched_class : (prev_class), (end_class))
+
+#define MIN_CGROUP_DL_IDX (5)      /* 8ms */
+#define DEFAULT_CGROUP_DL_IDX (8)  /* 64ms */
+extern u32 HMBIRD_BPF_DSQS_DEADLINE[MAX_GLOBAL_DSQS];
+
+
+void __hmbird_update_idle(struct rq *rq, bool idle);
+
+static inline void hmbird_update_idle(struct rq *rq, bool idle)
+{
+	if (hmbird_enabled())
+		__hmbird_update_idle(rq, idle);
+}
+
+int hmbird_ctrl(bool enable);
+
+int hmbird_tg_online(struct task_group *tg);
+
+
+static inline u16 hmbird_task_util(struct task_struct *p)
+{
+	return (p->sched_class == &hmbird_sched_class) ? get_hmbird_ts(p)->sts.demand_scaled : 0;
+}
+u16 hmbird_cpu_util(int cpu);
+
+bool get_hmbird_ops_enabled(void);
+bool get_non_hmbird_task(void);
+void set_cpu_cluster(u64 cpu_cluster);
+#endif /*_EXT_H_*/
diff --git a/kernel/sched/hmbird/hmbird.c b/kernel/sched/hmbird/hmbird.c
new file mode 100755
index 000000000000..ce05928392bf
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird.c
@@ -0,0 +1,4313 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ * HMBIRD scheduler class
+ *
+ * Copyright (c) 2024 OPlus.
+ * Copyright (c) 2024 Dao Huang
+ * Copyright (c) 2024 Yuxing Wang
+ * Copyright (c) 2024 Taiyu Li
+ */
+
+#include <linux/notifier.h>
+#include <linux/panic_notifier.h>
+
+#include "slim.h"
+#include "hmbird_sched.h"
+#include "hmbird_util_track.h"
+#include <linux/sched/hmbird_proc_val.h>
+
+#define CLUSTER_SEPARATE
+
+atomic_t __hmbird_ops_enabled = ATOMIC_INIT(0);
+atomic_t non_hmbird_task;
+atomic_t hmbird_module_loaded = ATOMIC_INIT(0);
+int cgroup_ids_table[NUMS_CGROUP_KINDS];
+static int sched_prop_to_preempt_prio[HMBIRD_TASK_PROP_MAX] = {0};
+
+enum hmbird_internal_consts {
+	HMBIRD_WATCHDOG_MAX_TIMEOUT = 30 * HZ,
+};
+
+enum hmbird_ops_enable_state {
+	HMBIRD_OPS_PREPPING,
+	HMBIRD_OPS_ENABLING,
+	HMBIRD_OPS_ENABLED,
+	HMBIRD_OPS_DISABLING,
+	HMBIRD_OPS_DISABLED,
+};
+
+static inline struct task_group *css_tg(struct cgroup_subsys_state *css)
+{
+	return css ? container_of(css, struct task_group, css) : NULL;
+}
+
+static inline void check_class_changed(struct rq *rq, struct task_struct *p,
+							const struct sched_class *prev_class,
+							int oldprio)
+{
+	if (prev_class != p->sched_class) {
+		if (prev_class->switched_from)
+			prev_class->switched_from(rq, p);
+
+		p->sched_class->switched_to(rq, p);
+	} else if (oldprio != p->prio || dl_task(p))
+		p->sched_class->prio_changed(rq, p, oldprio);
+}
+
+/*
+ * hmbird_entity->ops_state
+ *
+ * Used to track the task ownership between the HMBIRD core and the BPF scheduler.
+ * State transitions look as follows:
+ *
+ * NONE -> QUEUEING -> QUEUED -> DISPATCHING
+ *   ^              |                 |
+ *   |              v                 v
+ *   \-------------------------------/
+ *
+ * QUEUEING and DISPATCHING states can be waited upon. See wait_ops_state() call
+ * sites for explanations on the conditions being waited upon and why they are
+ * safe. Transitions out of them into NONE or QUEUED must store_release and the
+ * waiters should load_acquire.
+ *
+ * Tracking hmbird_ops_state enables hmbird core to reliably determine whether
+ * any given task can be dispatched by the BPF scheduler at all times and thus
+ * relaxes the requirements on the BPF scheduler. This allows the BPF scheduler
+ * to try to dispatch any task anytime regardless of its state as the HMBIRD core
+ * can safely reject invalid dispatches.
+ */
+enum hmbird_ops_state {
+	HMBIRD_OPSS_NONE,		/* owned by the HMBIRD core */
+	HMBIRD_OPSS_QUEUEING,	/* in transit to the BPF scheduler */
+	HMBIRD_OPSS_QUEUED,	/* owned by the BPF scheduler */
+	HMBIRD_OPSS_DISPATCHING,	/* in transit back to the HMBIRD core */
+
+	/*
+	 * QSEQ brands each QUEUED instance so that, when dispatch races
+	 * dequeue/requeue, the dispatcher can tell whether it still has a claim
+	 * on the task being dispatched.
+	 */
+	HMBIRD_OPSS_QSEQ_SHIFT	= 2,
+	HMBIRD_OPSS_STATE_MASK	= (1LLU << HMBIRD_OPSS_QSEQ_SHIFT) - 1,
+	HMBIRD_OPSS_QSEQ_MASK	= ~HMBIRD_OPSS_STATE_MASK,
+};
+
+enum switch_stat {
+	HMBIRD_DISABLED,
+	HMBIRD_SWITCH_PREP,
+	HMBIRD_RQ_SWITCH_BEGIN,
+	HMBIRD_RQ_SWITCH_DONE,
+	HMBIRD_ENABLED,
+};
+enum switch_stat curr_ss;
+
+/*
+ * During exit, a task may schedule after losing its PIDs. When disabling the
+ * BPF scheduler, we need to be able to iterate tasks in every state to
+ * guarantee system safety. Maintain a dedicated task list which contains every
+ * task between its fork and eventual free.
+ */
+DEFINE_SPINLOCK(hmbird_tasks_lock);
+static LIST_HEAD(hmbird_tasks);
+
+/* ops enable/disable */
+static struct kthread_worker *hmbird_ops_helper;
+static DEFINE_MUTEX(hmbird_ops_enable_mutex);
+DEFINE_STATIC_PERCPU_RWSEM(hmbird_fork_rwsem);
+static atomic_t hmbird_ops_enable_state_var = ATOMIC_INIT(HMBIRD_OPS_DISABLED);
+
+static bool hmbird_warned_zero_slice;
+enum hmbird_switch_type sw_type;
+static int skip_num[MAX_GLOBAL_DSQS];
+static int big_distribute_mask_prev;
+static int little_distribute_mask_prev;
+
+DEFINE_STATIC_KEY_FALSE(hmbird_ops_cpu_preempt);
+
+static atomic64_t hmbird_nr_rejected = ATOMIC64_INIT(0);
+
+/*
+ * The maximum amount of time in jiffies that a task may be runnable without
+ * being scheduled on a CPU. If this timeout is exceeded, it will trigger
+ * hmbird_ops_error().
+ */
+unsigned long hmbird_watchdog_timeout;
+
+/*
+ * The last time the delayed work was run. This delayed work relies on
+ * ksoftirqd being able to run to service timer interrupts, so it's possible
+ * that this work itself could get wedged. To account for this, we check that
+ * it's not stalled in the timer tick, and trigger an error if it is.
+ */
+unsigned long hmbird_watchdog_timestamp = INITIAL_JIFFIES;
+
+static struct delayed_work hmbird_watchdog_work;
+static struct work_struct hmbird_err_exit_work;
+
+/* idle tracking */
+#ifdef CONFIG_SMP
+#ifdef CONFIG_CPUMASK_OFFSTACK
+#define CL_ALIGNED_IF_ONSTACK
+#else
+#define CL_ALIGNED_IF_ONSTACK __cacheline_aligned_in_smp
+#endif
+
+static struct {
+	cpumask_var_t cpu;
+	cpumask_var_t smt;
+} idle_masks CL_ALIGNED_IF_ONSTACK;
+
+static bool __cacheline_aligned_in_smp hmbird_has_idle_cpus;
+#endif	/* CONFIG_SMP */
+
+/* dispatch queues */
+static struct hmbird_dispatch_q __cacheline_aligned_in_smp hmbird_dsq_global;
+
+u32 HMBIRD_BPF_DSQS_DEADLINE[MAX_GLOBAL_DSQS] = {0, 1, 2, 4, 6, 8, 16, 32, 64, 128};
+u32 pcp_dsq_deadline = 20;
+static struct hmbird_dispatch_q __cacheline_aligned_in_smp gdsqs[MAX_GLOBAL_DSQS];
+static DEFINE_PER_CPU(struct hmbird_dispatch_q, pcp_ldsq);
+
+static u64 max_hmbird_dsq_internal_id;
+
+/* a dsq idx, whether task push to little domain cpu or bit domain cpu*/
+#define CLUSTER_SEPARATE_IDX	(8)
+#define GDSQS_ID_BASE		(3)
+#define UX_COMPATIBLE_IDX	(4)
+#define NON_PERIOD_START	(5)
+#define NON_PERIOD_END		(MAX_GLOBAL_DSQS)
+#define CREATE_DSQ_LEVEL_WITHIN	(1)
+
+struct hmbird_sched_info {
+	spinlock_t lock;
+	int curr_idx[2];
+	int rtime[MAX_GLOBAL_DSQS];
+};
+
+struct pcp_sched_info {
+	s64 pcp_seq;
+	int rtime;
+	bool pcp_round;
+};
+
+/*
+ * pcp_info may rw by another cpu.
+ * protected by rq->lock.
+ */
+atomic64_t pcp_dsq_round;
+static DEFINE_PER_CPU(struct pcp_sched_info, pcp_info);
+
+struct md_info_t *md_info;
+
+static int b_rescue_l, l_rescue_b;
+static struct hmbird_sched_info sinfo;
+
+static unsigned long pcp_dsq_quota __read_mostly = 3 * NSEC_PER_MSEC;
+static unsigned long dsq_quota[MAX_GLOBAL_DSQS] = {
+					0, 0, 0, 0, 0,
+					32 * NSEC_PER_MSEC,
+					20 * NSEC_PER_MSEC,
+					14 * NSEC_PER_MSEC,
+					8 * NSEC_PER_MSEC,
+					6 * NSEC_PER_MSEC
+};
+
+struct cluster_ctx {
+	/* cpu-dsq map must within [lower, upper) */
+	int upper;
+	int lower;
+	int tidx;
+};
+
+enum stat_items {
+	GLOBAL_STAT,
+	CPU_ALLOW_FAIL,
+	RT_CNT,
+	KEY_TASK_CNT,
+	SWITCH_IDX,
+	TIMEOUT_CNT,
+
+	TOTAL_DSP_CNT,
+	MOVE_RQ_CNT,
+	SELECT_CPU,
+
+	DWORD_STAT_END = SELECT_CPU,
+
+	GDSQ_CNT,
+	ERR_IDX,
+	PCP_TIMEOUT_CNT,
+	PCP_LDSQ_CNT,
+	PCP_ENQL_CNT,
+
+	MAX_ITEMS,
+};
+static DEFINE_SPINLOCK(stats_lock);
+static char *stats_str[MAX_ITEMS] = {
+	"global stat", "cpu_allow_fail", "rt_cnt", "key_task_cnt",
+	"switch_idx", "timeout_cnt", "total_dsp_cnt", "move_rq_cnt",
+	"select_cpu", "gdsq_cnt", "err_idx", "pcp_timeout_cnt",
+	"pcp_ldsq_cnt", "pcp_enql_cnt"
+};
+
+
+struct stats_struct {
+	u64 global_stat[2];
+	u64 cpu_allow_fail[2];
+	u64 rt_cnt[2];
+	u64 key_task_cnt[2];
+	u64 switch_idx[2];
+	u64 timeout_cnt[2];
+
+	u64 total_dsp_cnt[2];
+	u64 move_rq_cnt[2];
+	u64 select_cpu[2];
+
+	u64 gdsq_count[MAX_GLOBAL_DSQS][2];
+	u64 err_idx[5];
+	u64 pcp_timeout_cnt[NR_CPUS];
+	u64 pcp_ldsq_count[NR_CPUS][2];
+	u64 pcp_enql_cnt[NR_CPUS];
+} stats_data;
+
+static struct {
+	cpumask_var_t ex_free;
+	cpumask_var_t exclusive;
+	cpumask_var_t partial;
+	cpumask_var_t big;
+	cpumask_var_t little;
+} iso_masks __read_mostly;
+
+/*
+ * Need more synchronization for these two variables?
+ * I choose not to.
+ */
+static int l_need_rescue, b_need_rescue;
+
+#define HMBIRD_FATAL_INFO_FN(type, fmt, args...)				\
+{										\
+	char buf[MAX_FATAL_INFO];						\
+										\
+	scnprintf(buf, MAX_FATAL_INFO, fmt, ##args);				\
+	hmbird_err(HMBIRD_OPS_ERR, "type(%d) %s\n", type, buf);			\
+	trace_hmbird_fatal_info((unsigned int)type, READ_ONCE(partial_enable),	\
+		READ_ONCE(l_need_rescue), READ_ONCE(b_need_rescue), buf);	\
+	queue_work(system_unbound_wq, &hmbird_err_exit_work);			\
+}										\
+
+static bool cpu_same_cluster_stat(struct task_struct *p, struct rq *rq1, struct rq *rq2)
+{
+	int c1, c2;
+	struct cpumask mask = {.bits = {0}};
+	struct cpumask tmp = {.bits = {0}};
+
+	if (!slim_stats)
+		return false;
+
+	if (!rq1 || !rq2)
+		return false;
+
+	c1 = cpu_of(rq1);
+	c2 = cpu_of(rq2);
+	cpumask_set_cpu(c1, &mask);
+	cpumask_set_cpu(c2, &mask);
+
+	if (cpumask_and(&tmp, iso_masks.little, &mask))
+		if (cpumask_equal(&tmp, &mask))
+			return true;
+
+	if (cpumask_and(&tmp, iso_masks.big, &mask))
+		if (cpumask_equal(&tmp, &mask))
+			return true;
+
+	if (cpumask_and(&tmp, iso_masks.partial, &mask))
+		if (cpumask_equal(&tmp, &mask))
+			return true;
+
+	return false;
+}
+
+static void slim_stats_record(enum stat_items item, int idx, int dsq_id, int cpu)
+{
+	unsigned long flags;
+	u64 *pval;
+	u64 *pbase = (u64 *)&stats_data;
+
+	if (!slim_stats)
+		return;
+
+	switch (item) {
+	case GLOBAL_STAT:
+		fallthrough;
+	case CPU_ALLOW_FAIL:
+		fallthrough;
+	case RT_CNT:
+		fallthrough;
+	case KEY_TASK_CNT:
+		fallthrough;
+	case SWITCH_IDX:
+		fallthrough;
+	case TIMEOUT_CNT:
+		fallthrough;
+	case TOTAL_DSP_CNT:
+		fallthrough;
+	case MOVE_RQ_CNT:
+		fallthrough;
+	case SELECT_CPU:
+		pval = pbase + item * 2 + idx;
+		break;
+	case GDSQ_CNT:
+		pval = &stats_data.gdsq_count[dsq_id][idx];
+		break;
+	case ERR_IDX:
+		pval = &stats_data.err_idx[idx];
+		break;
+	case PCP_TIMEOUT_CNT:
+		pval = &stats_data.pcp_timeout_cnt[cpu];
+		break;
+	case PCP_LDSQ_CNT:
+		pval = &stats_data.pcp_ldsq_count[cpu][idx];
+		break;
+	case PCP_ENQL_CNT:
+		pval = &stats_data.pcp_enql_cnt[cpu];
+		break;
+	default:
+		return;
+	}
+
+	spin_lock_irqsave(&stats_lock, flags);
+	*pval += 1;
+	spin_unlock_irqrestore(&stats_lock, flags);
+}
+
+static inline bool handle_ret(int ret, int *idx, int len)
+{
+	if (ret < 0 || ret >= len - *idx)
+		return true;
+	*idx += ret;
+	return false;
+}
+
+#define PRINT_INTV	(5 * HZ)
+void stats_print(char *buf, int len)
+{
+	int idx = 0, i, j, ret;
+	int item = 0;
+	u64 *pval;
+	u64 *pbase = (u64 *)&stats_data;
+
+	ret = snprintf(&buf[idx], len - idx, "-------------schedinfo stats :---------------\n");
+	if (handle_ret(ret, &idx, len))
+		return;
+	for (item = 0; item < MAX_ITEMS; item++) {
+		if (item <= DWORD_STAT_END) {
+			pval = pbase + item * 2;
+			ret = snprintf(&buf[idx], len - idx, "%s:%llu, %llu\n",
+					stats_str[item], pval[0],  pval[1]);
+			if (handle_ret(ret, &idx, len))
+				return;
+		} else if (item == GDSQ_CNT) {
+			for (j = 0; j < MAX_GLOBAL_DSQS; j++) {
+				pval = (u64 *)&stats_data.gdsq_count[j];
+				ret = snprintf(&buf[idx], len - idx, "%s[%d]:%llu, %llu\n",
+						stats_str[item], j, pval[0], pval[1]);
+				if (handle_ret(ret, &idx, len))
+					return;
+			}
+		} else if (item == ERR_IDX) {
+			pval = (u64 *)&stats_data.err_idx;
+			ret = snprintf(&buf[idx], len - idx, "%s:%llu, %llu, %llu, %llu, %llu\n",
+						stats_str[item], pval[0],
+						pval[1], pval[2], pval[3], pval[4]);
+			if (handle_ret(ret, &idx, len))
+				return;
+		} else if (item == PCP_TIMEOUT_CNT) {
+			for (j = 0; j < nr_cpu_ids; j++) {
+				pval = (u64 *)&stats_data.pcp_timeout_cnt[j];
+				ret = snprintf(&buf[idx], len - idx, "%s[%d]:%llu\n",
+							stats_str[item], j, *pval);
+				if (handle_ret(ret, &idx, len))
+					return;
+			}
+		} else if (item == PCP_LDSQ_CNT) {
+			for (j = 0; j < nr_cpu_ids; j++) {
+				pval = (u64 *)&stats_data.pcp_ldsq_count[j];
+				ret = snprintf(&buf[idx], len - idx, "%s[%d]:%llu,%llu\n",
+						stats_str[item], j, pval[0], pval[1]);
+				if (handle_ret(ret, &idx, len))
+					return;
+			}
+		} else if (item == PCP_ENQL_CNT) {
+			for (j = 0; j < nr_cpu_ids; j++) {
+				pval = (u64 *)&stats_data.pcp_enql_cnt[j];
+				ret = snprintf(&buf[idx], len - idx, "%s[%d]:%llu\n",
+						stats_str[item], j, *pval);
+				if (handle_ret(ret, &idx, len))
+					return;
+			}
+		}
+	}
+
+	if (!md_info) {
+		buf[idx] = '\0';
+		return;
+	}
+
+	ret = snprintf(&buf[idx], len - idx, "\n\n------------minidump stats :---------------\n");
+	if (handle_ret(ret, &idx, len))
+		return;
+
+	for (i = 0; i < MAX_SWITCHS; i++) {
+		ret = snprintf(&buf[idx], len - idx,
+				"sw_rec[%d] = %llu %llu %llu %llu\n", i,
+				md_info->kern_dump.sw_rec[i].switch_at,
+				md_info->kern_dump.sw_rec[i].is_success,
+				md_info->kern_dump.sw_rec[i].end_state,
+				md_info->kern_dump.sw_rec[i].switch_reason);
+		if (handle_ret(ret, &idx, len))
+			return;
+	}
+	ret = snprintf(&buf[idx], len - idx, "sw_idx = %llu\n", md_info->kern_dump.sw_idx);
+	if (handle_ret(ret, &idx, len))
+		return;
+
+	for (i = 0; i < MAX_EXCEP_ID; i++) {
+		ret = snprintf(&buf[idx], len - idx,
+				"excep[%d] = %llu %llu %llu %llu %llu\n", i,
+				md_info->kern_dump.excep_rec[i][0],
+				md_info->kern_dump.excep_rec[i][1],
+				md_info->kern_dump.excep_rec[i][2],
+				md_info->kern_dump.excep_rec[i][3],
+				md_info->kern_dump.excep_rec[i][4]);
+		if (handle_ret(ret, &idx, len))
+			return;
+
+		ret = snprintf(&buf[idx], len - idx, "excep_idx[%d] = %llu\n",
+					i, md_info->kern_dump.excep_idx[i]);
+		if (handle_ret(ret, &idx, len))
+			return;
+	}
+
+	buf[idx] = '\0';
+}
+
+enum cpu_type {
+	LITTLE,
+	BIG,
+	PARTIAL,
+	EXCLUSIVE,
+	EX_FREE,
+	INVALID
+};
+
+enum dsq_type {
+	GLOBAL_DSQ,
+	PCP_DSQ,
+	OTHER,
+	MAX_DSQ_TYPE,
+};
+
+static enum cpu_type cpu_cluster(int cpu)
+{
+	struct rq *rq = cpu_rq(cpu);
+
+	if (get_hmbird_rq(rq)->exclusive) {
+		return EXCLUSIVE;
+	} else {
+		if (cpumask_test_cpu(cpu, iso_masks.little))
+			return LITTLE;
+		else if (cpumask_test_cpu(cpu, iso_masks.big))
+			return BIG;
+		else if (cpumask_test_cpu(cpu, iso_masks.partial))
+			return PARTIAL;
+		else if (cpumask_test_cpu(cpu, iso_masks.exclusive))
+			return EXCLUSIVE;
+		else if (cpumask_test_cpu(cpu, iso_masks.ex_free))
+			return EX_FREE;
+	}
+	return INVALID;
+}
+
+static enum dsq_type get_dsq_type(struct hmbird_dispatch_q *dsq)
+{
+	if (!dsq)
+		return OTHER;
+
+	if ((dsq->id & HMBIRD_DSQ_FLAG_BUILTIN) &&
+		((dsq->id & 0xff) >= GDSQS_ID_BASE) &&
+		((dsq->id & 0xff) < MAX_GLOBAL_DSQS))
+		return GLOBAL_DSQ;
+
+	if ((dsq->id & HMBIRD_DSQ_FLAG_BUILTIN) &&
+		((dsq->id & 0xff) >= MAX_GLOBAL_DSQS) &&
+		((dsq->id & 0xff) < max_hmbird_dsq_internal_id))
+		return PCP_DSQ;
+
+	return OTHER;
+}
+
+static int dsq_id_to_internal(struct hmbird_dispatch_q *dsq)
+{
+	enum dsq_type type;
+
+	type = get_dsq_type(dsq);
+	switch (type) {
+	case GLOBAL_DSQ:
+	case PCP_DSQ:
+		return (dsq->id & 0xff) - GDSQS_ID_BASE;
+	default:
+		return -1;
+	}
+	return -1;
+}
+
+static void update_cpus_idle(bool set, struct cpumask *mask)
+{
+	int cpu;
+	struct rq *rq;
+
+	if (set) {
+		for_each_cpu(cpu, mask) {
+			rq = cpu_rq(cpu);
+			if (is_idle_task(rq->curr))
+				cpumask_set_cpu(cpu, idle_masks.cpu);
+		}
+	} else
+		cpumask_andnot(idle_masks.cpu, idle_masks.cpu, mask);
+}
+
+static void set_partial_status(bool enable, bool little, bool big)
+{
+	WRITE_ONCE(partial_enable, enable);
+	WRITE_ONCE(l_need_rescue, little);
+	WRITE_ONCE(b_need_rescue, big);
+}
+
+static bool is_little_need_rescue(void)
+{
+	return READ_ONCE(l_need_rescue);
+}
+
+static bool is_big_need_rescue(void)
+{
+	return READ_ONCE(b_need_rescue);
+}
+
+static bool is_partial_enabled(void)
+{
+	return READ_ONCE(partial_enable);
+}
+
+static bool is_partial_cpu(int cpu)
+{
+	return cpumask_test_cpu(cpu, iso_masks.partial);
+}
+
+static void set_iso_par_free(bool enable)
+{
+	WRITE_ONCE(isolate_ctrl, enable);
+}
+
+static bool is_iso_par_free(void)
+{
+	return READ_ONCE(isolate_ctrl);
+}
+
+static bool skip_update_idle(void)
+{
+	int cpu = smp_processor_id();
+	enum cpu_type type = cpu_cluster(cpu);
+
+	if ((type == EXCLUSIVE && !is_iso_par_free()) ||
+		/* partial enable may changed during idle, it doesn't matter. */
+		(!is_partial_enabled() && type == PARTIAL))
+		return true;
+
+	return false;
+}
+
+static void init_isolate_cpus(void)
+{
+	WARN_ON(!alloc_cpumask_var(&iso_masks.ex_free, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&iso_masks.partial, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&iso_masks.exclusive, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&iso_masks.big, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&iso_masks.little, GFP_KERNEL));
+	cpumask_set_cpu(0, iso_masks.big);
+	cpumask_set_cpu(1, iso_masks.big);
+	cpumask_set_cpu(2, iso_masks.big);
+	cpumask_set_cpu(3, iso_masks.big);
+	cpumask_set_cpu(4, iso_masks.big);
+	cpumask_set_cpu(5, iso_masks.ex_free);
+	cpumask_set_cpu(6, iso_masks.partial);
+	cpumask_set_cpu(7, iso_masks.ex_free);
+}
+
+extern spinlock_t css_set_lock;
+
+static struct cgroup *cgroup_ancestor_l1(struct cgroup *cgrp)
+{
+	int i;
+	struct cgroup *anc;
+
+	spin_lock_irq(&css_set_lock);
+	for (i = 0; i < cgrp->level; i++) {
+		anc = cgrp->ancestors[i];
+		if (anc->level != CREATE_DSQ_LEVEL_WITHIN)
+			continue;
+		cgroup_get(anc);
+		spin_unlock_irq(&css_set_lock);
+		return anc;
+	}
+	spin_unlock_irq(&css_set_lock);
+	hmbird_err(NO_CGROUP_L1, "<fatal>:error cgroup = %s\n", cgrp->kn->name);
+	return NULL;
+}
+
+#define PCP_IDX_BIT    (1 << 31)
+
+static bool is_pcp_rt(struct task_struct *p)
+{
+	return rt_prio(p->prio) && (p->nr_cpus_allowed == 1);
+}
+
+static bool is_pcp_idx(int idx)
+{
+	return idx >= MAX_GLOBAL_DSQS;
+}
+
+static bool is_critical_system_task(struct task_struct *p)
+{
+	int sp_dl = get_hmbird_ts(p)->sched_prop & SCHED_PROP_DEADLINE_MASK;
+
+	return (p->prio < (MAX_RT_PRIO >> 1) &&
+		(sp_dl < SCHED_PROP_DEADLINE_LEVEL3));
+}
+
+#define ISOLATE_TASK_TOP_BIT	(1 << 17)
+#define PIPELINE_TASK_TOP_BIT	(1 << 9)
+static bool is_pipeline_task(struct task_struct *p)
+{
+	return (get_top_task_prop(p) & PIPELINE_TASK_TOP_BIT);
+}
+
+static bool is_isolate_task(struct task_struct *p)
+{
+	return (get_top_task_prop(p) & ISOLATE_TASK_TOP_BIT);
+}
+
+static bool is_critical_app_task_without_isolate(struct task_struct *p)
+{
+	return task_is_top_task(p) && !is_isolate_task(p);
+}
+
+static int find_idx_from_task(struct task_struct *p)
+{
+	int idx, cpu;
+	int sp_dl;
+	struct task_group *tg = p->sched_task_group;
+
+	if (p->nr_cpus_allowed == 1 || is_migration_disabled(p)) {
+		cpu = cpumask_any(p->cpus_ptr);
+		idx = cpu + MAX_GLOBAL_DSQS;
+		return idx;
+	}
+
+	if (is_critical_system_task(p)) {
+		idx = SCHED_PROP_DEADLINE_LEVEL0;
+		goto done;
+	}
+
+	if (is_critical_app_task_without_isolate(p)) {
+		idx = SCHED_PROP_DEADLINE_LEVEL1;
+		goto done;
+	}
+
+	sp_dl = hmbird_get_dsq_id(p);
+	if (sp_dl) {
+		idx = sp_dl;
+		goto done;
+	}
+
+	if (rt_prio(p->prio)) {
+		idx = SCHED_PROP_DEADLINE_LEVEL3;
+		goto done;
+	}
+
+	if (tg && tg->css.cgroup && tg->css.cgroup->kn) {
+		if (likely(tg->css.cgroup->kn->id >= 0 &&
+			tg->css.cgroup->kn->id < NUMS_CGROUP_KINDS))
+			idx = cgroup_ids_table[tg->css.cgroup->kn->id];
+		else
+			idx = DEFAULT_CGROUP_DL_IDX;
+	} else
+		idx = DEFAULT_CGROUP_DL_IDX;
+
+done:
+	if (idx < 0 || idx >= MAX_GLOBAL_DSQS) {
+		hmbird_err(DSQ_ID_ERR, "<slim_sched><error> : idx error, idx = %d-----\n", idx);
+		idx = DEFAULT_CGROUP_DL_IDX;
+	}
+	return idx;
+}
+
+static struct hmbird_dispatch_q *find_dsq_from_task(struct task_struct *p)
+{
+	int idx;
+	unsigned long flags;
+	struct hmbird_dispatch_q *dsq;
+
+	if (!p)
+		return NULL;
+
+	idx = find_idx_from_task(p);
+	if (is_pcp_idx(idx)) {
+		idx -= MAX_GLOBAL_DSQS;
+		dsq = &per_cpu(pcp_ldsq, idx);
+		get_hmbird_ts(p)->gdsq_idx = dsq_id_to_internal(dsq);
+		slim_stats_record(PCP_LDSQ_CNT, 0, 0, idx);
+	} else {
+		dsq = &gdsqs[idx];
+		get_hmbird_ts(p)->gdsq_idx = idx;
+		slim_stats_record(GDSQ_CNT, 0, idx, 0);
+	}
+
+	raw_spin_lock_irqsave(&dsq->lock, flags);
+	if (list_empty(&dsq->fifo))
+		dsq->last_consume_at = jiffies;
+
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+
+	return dsq;
+}
+
+
+bool consume_dispatch_q(struct rq *rq, struct rq_flags *rf,
+						struct hmbird_dispatch_q *dsq);
+
+static void set_partial_rescue(bool p_state, bool l_over, bool b_over)
+{
+	set_partial_status(p_state, l_over, b_over);
+	update_cpus_idle(p_state, iso_masks.partial);
+	hmbird_internal_systrace("C|9999|partial_enable|%d\n", is_partial_enabled());
+	hmbird_internal_systrace("C|9999|l_need_rescue|%d\n", is_little_need_rescue());
+	hmbird_internal_systrace("C|9999|b_need_rescue|%d\n", is_big_need_rescue());
+}
+
+static void free_isocpu(bool enable)
+{
+	set_iso_par_free(enable);
+	update_cpus_idle(enable, iso_masks.ex_free);
+	hmbird_internal_systrace("C|9999|free_iso|%d\n", is_iso_par_free());
+}
+
+inline u64 get_hmbird_cpu_util(int cpu)
+{
+	struct rq *rq = cpu_rq(cpu);
+
+	if (!get_hmbird_rq(rq)->prev_runnable_sum_fixed)
+		return 0;
+	u64 prev_runnable_sum_fixed = *(u64 *)(get_hmbird_rq(rq)->prev_runnable_sum_fixed);
+	u32 prev_window_size = *(u32 *)(get_hmbird_rq(rq)->prev_window_size);
+
+	do_div(prev_runnable_sum_fixed, prev_window_size >> SCHED_CAPACITY_SHIFT);
+
+	return prev_runnable_sum_fixed;
+}
+
+static inline unsigned int get_scaling_max_freq(unsigned int cpu)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);
+
+	return (policy == NULL) ? 0 : policy->max;
+}
+
+static inline unsigned int get_cpuinfo_max_freq(unsigned int cpu)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);
+
+	return (policy == NULL) ? 0 : policy->cpuinfo.max_freq;
+}
+
+static u64 get_cpus_max_util(struct cpumask *mask)
+{
+	int cpu;
+	u64 max = 0;
+	u64 util, ratio;
+	unsigned long effective_cap = 0;
+	for_each_cpu(cpu, mask) {
+		if (slim_walt_ctrl)
+			slim_get_cpu_util(cpu, &util);
+		else
+			util = get_hmbird_cpu_util(cpu);
+
+		/* if max freq is 0, effective_cap use arch_scale_cpu_capacity*/
+		if (unlikely(!get_scaling_max_freq(cpu) || !get_cpuinfo_max_freq(cpu)))
+			effective_cap = arch_scale_cpu_capacity(cpu);
+		else
+			effective_cap = arch_scale_cpu_capacity(cpu) *
+					get_scaling_max_freq(cpu) / get_cpuinfo_max_freq(cpu);
+
+		ratio = util * 100 / effective_cap;
+		hmbird_info_systrace("C|9999|Cpu%d_util|%llu\n", cpu, util);
+		hmbird_info_systrace("C|9999|Cpu%d_cap|%llu\n",
+				cpu, (u64)arch_scale_cpu_capacity(cpu));
+		hmbird_info_systrace("C|9999|Cpu%d_effective_cap|%llu\n",
+				cpu, (u64)effective_cap);
+
+		if (ratio > 100)
+			ratio = 100;
+
+		if (ratio > max)
+			max = ratio;
+	}
+	return max;
+}
+
+static bool cluster_need_rescue(struct cpumask *mask, int hres)
+{
+	return get_cpus_max_util(mask) > hres;
+}
+
+void partial_dynamic_ctrl(void)
+{
+	u64 lmax = 0, bmax = 0;
+	bool l_over, l_under, b_over, b_under;
+	static bool last_l_over, last_b_over;
+	static unsigned long last_check;
+
+	/* Check partial every jiffies. need lock? */
+	if (time_before_eq(jiffies, READ_ONCE(last_check)))
+		return;
+
+	WRITE_ONCE(last_check, jiffies);
+
+	lmax = get_cpus_max_util(iso_masks.little);
+	l_over = lmax > parctrl_high_ratio_l;
+	l_under = lmax < parctrl_low_ratio_l;
+
+	bmax = get_cpus_max_util(iso_masks.big);
+	b_over = bmax > parctrl_high_ratio;
+	b_under = bmax < parctrl_low_ratio;
+
+	if (is_partial_enabled() && (l_over || b_over)) {
+		if (last_l_over != l_over || last_b_over != b_over)
+			set_partial_rescue(true, l_over, b_over);
+	} else if (!is_partial_enabled() && (l_over || b_over)) {
+		set_partial_rescue(true, l_over, b_over);
+	} else if (is_partial_enabled() && l_under && b_under) {
+		set_partial_rescue(false, false, false);
+	}
+	last_l_over = l_over;
+	last_b_over = b_over;
+
+	if (is_partial_enabled()) {
+		bmax = get_cpus_max_util(iso_masks.partial);
+		if (!is_iso_par_free() && bmax > isoctrl_high_ratio) {
+			hmbird_info_trace("<par>partial max = %llu\n", bmax);
+			free_isocpu(true);
+		} else if (is_iso_par_free() && bmax < isoctrl_low_ratio)
+			free_isocpu(false);
+	} else if (is_iso_par_free()) {
+		free_isocpu(false);
+	}
+}
+
+static inline void slim_trace_show_cpu_consume_dsq_idx(unsigned int cpu, unsigned int idx)
+{
+	hmbird_internal_systrace("C|9999|Cpu%d_dsq_id|%d\n", cpu, idx);
+}
+
+static int consume_target_dsq(struct rq *rq, struct rq_flags *rf, unsigned int idx)
+{
+	if (idx < 0 || idx >= MAX_GLOBAL_DSQS)
+		return 0;
+
+	if (consume_dispatch_q(rq, rf, &gdsqs[idx])) {
+		slim_stats_record(GDSQ_CNT, 1, idx, 0);
+		return 1;
+	}
+	return 0;
+}
+
+static int consume_period_dsq(struct rq *rq, struct rq_flags *rf)
+{
+	int i;
+
+	for (i = 0; i < UX_COMPATIBLE_IDX; i++) {
+		if (consume_dispatch_q(rq, rf, &gdsqs[i])) {
+			slim_stats_record(GDSQ_CNT, 1, i, 0);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int consume_ux_dsq(struct rq *rq, struct rq_flags *rf)
+{
+	if (consume_dispatch_q(rq, rf, &gdsqs[UX_COMPATIBLE_IDX])) {
+		slim_stats_record(GDSQ_CNT, 1, UX_COMPATIBLE_IDX, 0);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void update_timeout_stats(struct rq *rq, struct hmbird_dispatch_q *dsq, u64 deadline)
+{
+	struct hmbird_entity *entity;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&dsq->lock, flags);
+	if (list_empty(&dsq->fifo))
+		goto clear_timeout;
+
+	entity = list_first_entry(&dsq->fifo, struct hmbird_entity, dsq_node.fifo);
+	if (time_before_eq(jiffies, entity->runnable_at + msecs_to_jiffies(deadline)))
+		goto clear_timeout;
+
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+	hmbird_info_trace(
+				"dsq[%d] still timeout task-%s, jiffies = %lu, deadline = %lu, runnable at = %lu\n",
+				dsq_id_to_internal(dsq), entity->task->comm,
+				jiffies, msecs_to_jiffies(deadline), entity->runnable_at);
+	hmbird_info_systrace("C|9999|dsq_%d_timeout|%d\n", dsq_id_to_internal(dsq), 1);
+	return;
+
+clear_timeout:
+	hmbird_info_trace("dsq[%d] clear timeout\n",
+				dsq_id_to_internal(dsq));
+	hmbird_info_systrace("C|9999|dsq_%d_timeout|%d\n", dsq_id_to_internal(dsq), 0);
+	dsq->is_timeout = false;
+	slim_stats_record(PCP_TIMEOUT_CNT, 0, 0, cpu_of(rq));
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+}
+
+static void systrace_output_rtime_state(struct hmbird_dispatch_q *dsq, int rtime)
+{
+	hmbird_info_systrace("C|9999|dsq%d_rtime|%d\n", dsq_id_to_internal(dsq), rtime);
+}
+
+static int consume_pcp_dsq(struct rq *rq, struct rq_flags *rf, bool any)
+{
+	bool is_timeout;
+	int cpu = cpu_of(rq);
+	unsigned long flags;
+	struct hmbird_dispatch_q *dsq = &per_cpu(pcp_ldsq, cpu);
+
+	raw_spin_lock_irqsave(&dsq->lock, flags);
+	is_timeout = dsq->is_timeout;
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+
+	/*
+	 * dsq->is_timeout may change here, let it be.
+	 * it won't cause serious problems.
+	 * the same for consume_dispatch_q later.
+	 */
+	if (!is_timeout && !any)
+		return 0;
+
+	if (consume_dispatch_q(rq, rf, dsq)) {
+		if (is_timeout) {
+			hmbird_info_trace("dsq[%d] consume a pcp timeout task\n",
+						dsq_id_to_internal(dsq));
+			update_timeout_stats(rq, dsq, pcp_dsq_deadline);
+			slim_stats_record(PCP_TIMEOUT_CNT, 0, 0, cpu);
+		}
+		slim_stats_record(PCP_LDSQ_CNT, 1, 0, cpu);
+		return 1;
+	}
+	/*
+	 * No pcp task, clear quota.
+	 */
+	if (any) {
+		if (per_cpu(pcp_info, cpu_of(rq)).pcp_round) {
+			per_cpu(pcp_info, cpu).rtime = 0;
+			per_cpu(pcp_info, cpu).pcp_round = false;
+			hmbird_info_systrace("C|9999|pcp_%d_round|%d\n", cpu, false);
+			systrace_output_rtime_state(&per_cpu(pcp_ldsq, cpu),
+					per_cpu(pcp_info, cpu).rtime);
+		}
+	}
+	return 0;
+}
+
+static int check_pcp_dsq_round(struct rq *rq, struct rq_flags *rf)
+{
+	if (per_cpu(pcp_info, cpu_of(rq)).pcp_round) {
+		if (consume_pcp_dsq(rq, rf, true))
+			return 1;
+	}
+	return 0;
+}
+
+static int check_non_period_dsq_phase(struct rq *rq, struct rq_flags *rf,
+									int tmp, int cidx, int tidx)
+{
+	unsigned long flags;
+
+	if (consume_dispatch_q(rq, rf, &gdsqs[tmp])) {
+		if (tmp != cidx) {
+			spin_lock(&sinfo.lock);
+			sinfo.curr_idx[tidx] = tmp;
+			spin_unlock(&sinfo.lock);
+			hmbird_info_systrace("C|9999|cidx_%d|%d\n", tidx, sinfo.curr_idx[tidx]);
+			slim_stats_record(SWITCH_IDX, 0, 0, 0);
+		}
+		slim_stats_record(GDSQ_CNT, 1, tmp, 0);
+
+		raw_spin_lock_irqsave(&gdsqs[tmp].lock, flags);
+		gdsqs[tmp].last_consume_at = jiffies;
+		raw_spin_unlock_irqrestore(&gdsqs[tmp].lock, flags);
+		return 1;
+	}
+	return 0;
+
+}
+
+static int get_cidx(struct cluster_ctx *ctx)
+{
+	int cidx;
+
+	spin_lock(&sinfo.lock);
+	cidx = sinfo.curr_idx[ctx->tidx];
+	if (cidx < ctx->lower || cidx >= ctx->upper) {
+		sinfo.curr_idx[ctx->tidx] = ctx->lower;
+		hmbird_info_systrace("C|9999|cidx_%d|%d\n", ctx->tidx, sinfo.curr_idx[ctx->tidx]);
+		slim_stats_record(ERR_IDX, ctx->tidx + 3, 0, 0);
+		cidx = sinfo.curr_idx[ctx->tidx];
+	}
+	spin_unlock(&sinfo.lock);
+
+	return cidx;
+}
+
+static int gen_cluster_ctx_separate(struct cluster_ctx *ctx, enum cpu_type type)
+{
+	switch (type) {
+	case PARTIAL:
+		if (!is_partial_enabled())
+			return -1;
+		fallthrough;
+	case BIG:
+		ctx->lower = NON_PERIOD_START;
+		ctx->upper = CLUSTER_SEPARATE_IDX;
+		if (!cpumask_available(iso_masks.little) || cpumask_empty(iso_masks.little)) {
+			pr_debug("<hmbird sched> %s iso_masks.little first is %d\n",
+					__func__, cpumask_first(iso_masks.little));
+			ctx->upper = NON_PERIOD_END;
+		}
+		ctx->tidx = 0;
+		break;
+	case LITTLE:
+		ctx->lower = CLUSTER_SEPARATE_IDX;
+		ctx->upper = NON_PERIOD_END;
+		if (!cpumask_available(iso_masks.big) || cpumask_empty(iso_masks.big)) {
+			pr_debug("<hmbird sched> %s iso_masks.big first is %d",
+					__func__, cpumask_first(iso_masks.big));
+			ctx->lower = NON_PERIOD_START;
+		}
+		ctx->tidx = 1;
+		break;
+	default:
+		hmbird_deferred_err(CPU_NO_MASK, "can't find cpu cluster\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int gen_cluster_ctx_common(struct cluster_ctx *ctx, enum cpu_type type)
+{
+	switch (type) {
+	case PARTIAL:
+		if (!is_partial_enabled())
+			return -1;
+		fallthrough;
+	case BIG:
+	case LITTLE:
+		ctx->lower = NON_PERIOD_START;
+		ctx->upper = NON_PERIOD_END;
+		ctx->tidx = 0;
+		break;
+	default:
+		hmbird_deferred_err(CPU_NO_MASK, "can't find cpu cluster\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int gen_cluster_ctx(struct cluster_ctx *ctx, enum cpu_type type)
+{
+	if (cluster_separate) {
+		return gen_cluster_ctx_separate(ctx, type);
+	} else {
+		return gen_cluster_ctx_common(ctx, type);
+	}
+}
+
+static int consume_timeout_dsq(struct rq *rq, struct rq_flags *rf, enum cpu_type type)
+{
+	int i;
+	bool is_timeout;
+	unsigned long flags;
+	struct cluster_ctx ctx;
+
+	if (gen_cluster_ctx(&ctx, type))
+		return 0;
+
+	/* Third param <false> means only consume timeout pcp dsq. */
+	if (consume_pcp_dsq(rq, rf, false))
+		return 1;
+
+	for (i = ctx.lower; i < ctx.upper; i++) {
+		raw_spin_lock_irqsave(&gdsqs[i].lock, flags);
+		is_timeout = gdsqs[i].is_timeout;
+		raw_spin_unlock_irqrestore(&gdsqs[i].lock, flags);
+		/* gdsqs[i].is_timeout may change here, let it be... */
+		if (is_timeout) {
+			/*
+			 * consume_dispatch_q will acquire dsq-lock,
+			 * So cannot keep lock here, annoy enough.
+			 * may rewrite a consume_dispatch_q_locked, TODO.
+			 */
+			if (consume_dispatch_q(rq, rf, &gdsqs[i])) {
+				hmbird_info_trace("dsq[%d] consume a timeout task\n", i);
+				slim_stats_record(TIMEOUT_CNT, ctx.tidx, 0, 0);
+				update_timeout_stats(rq, &gdsqs[i], HMBIRD_BPF_DSQS_DEADLINE[i]);
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+static int consume_non_period_dsq(struct rq *rq, struct rq_flags *rf, enum cpu_type type)
+{
+	struct cluster_ctx ctx;
+	int cidx;
+	int tmp;
+
+	if (gen_cluster_ctx(&ctx, type))
+		return 0;
+
+	cidx = get_cidx(&ctx);
+	tmp = cidx;
+	do {
+		if (check_pcp_dsq_round(rq, rf))
+			return 1;
+		if (check_non_period_dsq_phase(rq, rf, tmp, cidx, ctx.tidx))
+			return 1;
+		spin_lock(&sinfo.lock);
+		sinfo.rtime[tmp] = 0;
+		systrace_output_rtime_state(&gdsqs[tmp], sinfo.rtime[tmp]);
+		tmp++;
+		if (tmp >= ctx.upper) {
+			atomic64_inc(&pcp_dsq_round);
+			hmbird_info_systrace("C|9999|pcp_dsq_round|%lld\n",
+							atomic64_read(&pcp_dsq_round));
+			tmp = ctx.lower;
+		}
+		spin_unlock(&sinfo.lock);
+	} while (tmp != cidx);
+
+	return consume_pcp_dsq(rq, rf, true);
+}
+
+static bool consume_hmbird_global_dsq(struct rq *rq, struct rq_flags *rf)
+{
+	enum cpu_type type = cpu_cluster(cpu_of(rq));
+	bool period_allowed = !get_hmbird_rq(rq)->period_disallow;
+	bool non_period_allowed = !get_hmbird_rq(rq)->nonperiod_disallow;
+
+	switch (type) {
+	case EX_FREE:
+		if (consume_period_dsq(rq, rf))
+			return 1;
+		if (consume_timeout_dsq(rq, rf, BIG))
+			return 1;
+		if (consume_ux_dsq(rq, rf))
+			return 1;
+		if (consume_non_period_dsq(rq, rf, BIG))
+			return 1;
+		if (is_little_need_rescue()) {
+			if (consume_timeout_dsq(rq, rf, LITTLE))
+				return 1;
+			if (consume_ux_dsq(rq, rf))
+				return 1;
+			if (consume_non_period_dsq(rq, rf, LITTLE))
+				return 1;
+		}
+		break;
+	case EXCLUSIVE:
+		if (!is_iso_par_free()) {
+			if (consume_pcp_dsq(rq, rf, true))
+				return 1;
+			break;
+		}
+		/* Only non-period task can run on isolate cpus */
+		if (!READ_ONCE(iso_free_rescue)) {
+			if (is_big_need_rescue()) {
+				if (consume_timeout_dsq(rq, rf, BIG))
+					return 1;
+				if (consume_non_period_dsq(rq, rf, BIG))
+					return 1;
+			}
+			if (is_little_need_rescue()) {
+				if (consume_timeout_dsq(rq, rf, LITTLE))
+					return 1;
+				if (consume_non_period_dsq(rq, rf, LITTLE))
+					return 1;
+			}
+		} else {
+			/* Free run, can run on any task. */
+			if (consume_period_dsq(rq, rf))
+				return 1;
+			if (consume_timeout_dsq(rq, rf, BIG))
+				return 1;
+			if (consume_timeout_dsq(rq, rf, LITTLE))
+				return 1;
+			if (consume_ux_dsq(rq, rf))
+				return 1;
+			if (consume_non_period_dsq(rq, rf, BIG))
+				return 1;
+			if (consume_non_period_dsq(rq, rf, LITTLE))
+				return 1;
+		}
+		if (consume_pcp_dsq(rq, rf, true))
+			return 1;
+		break;
+	case PARTIAL:
+		if (!is_partial_enabled()) {
+			if (consume_pcp_dsq(rq, rf, true))
+				return 1;
+			return 0;
+		}
+		if (is_big_need_rescue()) {
+			if (period_allowed && consume_period_dsq(rq, rf))
+				return 1;
+			if (non_period_allowed && consume_timeout_dsq(rq, rf, BIG))
+				return 1;
+			if (period_allowed && consume_ux_dsq(rq, rf))
+				return 1;
+			if (non_period_allowed && consume_non_period_dsq(rq, rf, BIG))
+				return 1;
+		}
+		if (is_little_need_rescue()) {
+			if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL0))
+				return 1;
+			if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL2))
+				return 1;
+			if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL3))
+				return 1;
+			if (non_period_allowed && consume_timeout_dsq(rq, rf, LITTLE))
+				return 1;
+			if (consume_ux_dsq(rq, rf))
+				return 1;
+			if (non_period_allowed && consume_non_period_dsq(rq, rf, LITTLE))
+				return 1;
+		}
+		if (consume_pcp_dsq(rq, rf, true))
+			return 1;
+		break;
+
+	case BIG:
+		if (period_allowed && consume_period_dsq(rq, rf))
+			return 1;
+		if (non_period_allowed && consume_timeout_dsq(rq, rf, type))
+			return 1;
+		if (period_allowed && consume_ux_dsq(rq, rf))
+			return 1;
+		if (non_period_allowed && consume_non_period_dsq(rq, rf, type))
+			return 1;
+		if (is_iso_par_free() || (is_little_need_rescue() &&
+				!cluster_need_rescue(iso_masks.big, parctrl_high_ratio))) {
+			if (consume_timeout_dsq(rq, rf, LITTLE))
+				return 1;
+			if (consume_non_period_dsq(rq, rf, LITTLE)) {
+				hmbird_internal_systrace("C|9999|b_rescue_l|%d\n", b_rescue_l++);
+				return 1;
+			}
+		}
+		break;
+
+	case LITTLE:
+		if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL0))
+			return 1;
+		if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL2))
+			return 1;
+		if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL3))
+			return 1;
+		if (non_period_allowed && consume_timeout_dsq(rq, rf, type))
+			return 1;
+		if (consume_ux_dsq(rq, rf))
+			return 1;
+		if (non_period_allowed && consume_non_period_dsq(rq, rf, type))
+			return 1;
+
+		if (is_iso_par_free() || (is_big_need_rescue() &&
+			!cluster_need_rescue(iso_masks.little, parctrl_high_ratio_l))) {
+			if (consume_timeout_dsq(rq, rf, BIG))
+				return 1;
+			if (consume_non_period_dsq(rq, rf, BIG)) {
+				hmbird_internal_systrace("C|9999|l_rescue_b|%d\n", l_rescue_b++);
+				return 1;
+			}
+		}
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int consume_dispatch_global(struct rq *rq, struct rq_flags *rf)
+{
+	return consume_hmbird_global_dsq(rq, rf);
+}
+
+
+static void update_runningtime(struct rq *rq, struct task_struct *p, unsigned long exec_time)
+{
+	int idx;
+
+	/* which dsq belongs to while task enqueue, task will consume its running time. */
+	idx = get_hmbird_ts(p)->gdsq_idx;
+	/* Only non-period dsq share running time between each other. */
+	if (idx < NON_PERIOD_START || idx >= max_hmbird_dsq_internal_id)
+		return;
+
+	if (idx >= MAX_GLOBAL_DSQS) {
+		per_cpu(pcp_info, cpu_of(rq)).rtime += exec_time;
+		systrace_output_rtime_state(&per_cpu(pcp_ldsq, cpu_of(rq)),
+					per_cpu(pcp_info, cpu_of(rq)).rtime);
+	} else {
+		spin_lock(&sinfo.lock);
+		sinfo.rtime[idx] += exec_time;
+		spin_unlock(&sinfo.lock);
+		systrace_output_rtime_state(&gdsqs[idx], sinfo.rtime[idx]);
+	}
+}
+
+static void update_dsq_idx(struct rq *rq, struct task_struct *p, enum cpu_type type)
+{
+	int cidx;
+	struct cluster_ctx ctx;
+	int cpu = cpu_of(rq);
+
+	if (gen_cluster_ctx(&ctx, type))
+		return;
+
+	spin_lock(&sinfo.lock);
+	cidx = sinfo.curr_idx[ctx.tidx];
+	if (cidx < ctx.lower || cidx >= ctx.upper) {
+		sinfo.curr_idx[ctx.tidx] = ctx.lower;
+		hmbird_info_systrace("C|9999|cidx_%d|%d\n", ctx.tidx, sinfo.curr_idx[ctx.tidx]);
+		slim_stats_record(ERR_IDX, ctx.tidx, 0, 0);
+		cidx = sinfo.curr_idx[ctx.tidx];
+	}
+
+	while (1) {
+		if (per_cpu(pcp_info, cpu).pcp_round) {
+			if (per_cpu(pcp_info, cpu).rtime >= pcp_dsq_quota) {
+				hmbird_info_trace("cpu[%d] pcp_dsq_round is full, rtime = %d\n",
+								cpu, per_cpu(pcp_info, cpu).rtime);
+				per_cpu(pcp_info, cpu).rtime = 0;
+				per_cpu(pcp_info, cpu).pcp_round = false;
+				hmbird_info_systrace("C|9999|pcp_%d_round|%d\n", cpu, false);
+				systrace_output_rtime_state(&per_cpu(pcp_ldsq, cpu),
+						per_cpu(pcp_info, cpu_of(rq)).rtime);
+			}
+		}
+		if (sinfo.rtime[cidx] < dsq_quota[cidx])
+			break;
+
+		/* clear current dsq rtime */
+		sinfo.rtime[cidx] = 0;
+		systrace_output_rtime_state(&gdsqs[cidx], sinfo.rtime[cidx]);
+
+		sinfo.curr_idx[ctx.tidx]++;
+		hmbird_info_systrace("C|9999|cidx_%d|%d\n", ctx.tidx, sinfo.curr_idx[ctx.tidx]);
+		if (sinfo.curr_idx[ctx.tidx] >= ctx.upper) {
+			atomic64_inc(&pcp_dsq_round);
+			hmbird_info_systrace("C|9999|pcp_dsq_round|%lld\n",
+								atomic64_read(&pcp_dsq_round));
+			sinfo.curr_idx[ctx.tidx] = ctx.lower;
+			hmbird_info_systrace("C|9999|cidx_%d|%d\n",
+								ctx.tidx, sinfo.curr_idx[ctx.tidx]);
+		}
+		cidx = sinfo.curr_idx[ctx.tidx];
+		slim_stats_record(SWITCH_IDX, 1, 0, 0);
+	}
+	spin_unlock(&sinfo.lock);
+}
+
+
+static void update_dispatch_dsq_info(struct rq *rq, struct task_struct *p)
+{
+	enum cpu_type type;
+
+	if (!rq || !p)
+		return;
+
+	type = cpu_cluster(cpu_of(rq));
+	switch (type) {
+	case PARTIAL:
+		return;
+	case EXCLUSIVE:
+		return;
+	case EX_FREE:
+		return;
+	default:
+		break;
+	}
+	update_dsq_idx(rq, p, type);
+}
+
+
+static bool scan_dsq_timeout(struct rq *rq, struct hmbird_dispatch_q *dsq, u64 deadline)
+{
+	struct hmbird_entity *entity;
+	int dsq_id;
+
+	raw_spin_lock(&dsq->lock);
+	if (list_empty(&dsq->fifo) || dsq->is_timeout) {
+		raw_spin_unlock(&dsq->lock);
+		return false;
+	}
+
+	entity = list_first_entry(&dsq->fifo, struct hmbird_entity, dsq_node.fifo);
+	if (!entity) {
+		hmbird_deferred_err(SCAN_ENTITY_NULL,
+				"<error> : entity is NULL, dsq->id = %llu\n", dsq->id);
+		raw_spin_unlock(&dsq->lock);
+		return false;
+	}
+
+	if (time_before_eq(jiffies, entity->runnable_at + msecs_to_jiffies(deadline))) {
+		raw_spin_unlock(&dsq->lock);
+		return false;
+	}
+
+	dsq->is_timeout = true;
+	dsq_id = dsq_id_to_internal(dsq);
+	hmbird_info_trace("dsq[%d] has timeout task-%s, jiffies = %lu, runnable at = %lu\n",
+			dsq_id, entity->task->comm, jiffies, entity->runnable_at);
+	hmbird_info_systrace("C|9999|dsq_%d_timeout|%d\n", dsq_id, 1);
+	raw_spin_unlock(&dsq->lock);
+
+	return true;
+}
+
+void scan_timeout(struct rq *rq)
+{
+	int i;
+	int cpu = cpu_of(rq);
+	struct hmbird_dispatch_q *dsq;
+	static u64 last_scan_at;
+	static DEFINE_PER_CPU(u64, pcp_last_scan_at);
+
+	if (time_before_eq(jiffies, (unsigned long)per_cpu(pcp_last_scan_at, cpu)))
+		return;
+	per_cpu(pcp_last_scan_at, cpu) = jiffies;
+
+	dsq = &per_cpu(pcp_ldsq, cpu);
+	scan_dsq_timeout(rq, dsq, pcp_dsq_deadline);
+
+	if (time_before_eq(jiffies, (unsigned long)last_scan_at))
+		return;
+	last_scan_at = jiffies;
+
+	for (i = NON_PERIOD_START; i < NON_PERIOD_END; i++) {
+		dsq = &gdsqs[i];
+		scan_dsq_timeout(rq, dsq, HMBIRD_BPF_DSQS_DEADLINE[i]);
+	}
+}
+
+/*******************************Initialize***********************************/
+
+void init_dsq(struct hmbird_dispatch_q *dsq, u64 dsq_id);
+static void init_dsq_at_boot(void)
+{
+	int i, cpu;
+
+	for (i = 0; i < MAX_GLOBAL_DSQS; i++) {
+		init_dsq(&gdsqs[i], (u64)HMBIRD_DSQ_FLAG_BUILTIN |
+				(GDSQS_ID_BASE + i));
+	}
+	for_each_possible_cpu(cpu)
+		init_dsq(&per_cpu(pcp_ldsq, cpu), (u64)HMBIRD_DSQ_FLAG_BUILTIN |
+				(GDSQS_ID_BASE + i + cpu));
+
+	max_hmbird_dsq_internal_id = GDSQS_ID_BASE + i + cpu;
+	spin_lock_init(&sinfo.lock);
+}
+
+static inline void update_cgroup_ids_table(u64 ids, int hmbird_cgroup_deadline_idx)
+{
+	if (ids < 0 || ids >= NUMS_CGROUP_KINDS) {
+		pr_err("update_cgroup_ids_tab idx err!\n");
+		return;
+	}
+	cgroup_ids_table[ids] = hmbird_cgroup_deadline_idx;
+}
+
+static int cgrp_name_to_idx(struct cgroup *cgrp)
+{
+	int idx;
+
+	if (!cgrp)
+		return -1;
+
+	if (!strcmp(cgrp->kn->name, "display")
+			|| !strcmp(cgrp->kn->name, "multimedia"))
+		idx = 5; /* 8ms */
+	else if (!strcmp(cgrp->kn->name, "top-app")
+			|| !strcmp(cgrp->kn->name, "ss-top"))
+		idx = 6; /* 16ms */
+	else if (!strcmp(cgrp->kn->name, "ssfg")
+			|| !strcmp(cgrp->kn->name, "foreground"))
+		idx = 7; /* 32ms */
+	else if (!strcmp(cgrp->kn->name, "bg")
+			|| !strcmp(cgrp->kn->name, "log")
+			|| !strcmp(cgrp->kn->name, "dex2oat")
+			|| !strcmp(cgrp->kn->name, "background"))
+		idx = 9; /* 128ms */
+	else
+		idx = DEFAULT_CGROUP_DL_IDX; /* 64ms */
+
+	return idx;
+}
+
+static void init_root_tg(struct cgroup  *cgrp, struct task_group *tg)
+{
+	if (!cgrp || !tg || !(cgrp->kn))
+		return;
+	update_cgroup_ids_table(cgrp->kn->id, DEFAULT_CGROUP_DL_IDX);
+}
+
+static void init_level1_tg(struct cgroup *cgrp, struct task_group *tg)
+{
+	if (!cgrp || !tg || !(cgrp->kn))
+		return;
+
+	if (cgrp->kn->id < 0 || cgrp->kn->id >= NUMS_CGROUP_KINDS) {
+		pr_err("%s idx err!\n", __func__);
+		return;
+	}
+
+	if (cgroup_ids_table[cgrp->kn->id] == -1)
+		update_cgroup_ids_table(cgrp->kn->id, cgrp_name_to_idx(cgrp));
+}
+
+static void init_child_tg(struct cgroup *cgrp, struct task_group *tg)
+{
+	struct cgroup *l1cgrp;
+
+	if (!cgrp || !tg || !(cgrp->kn))
+		return;
+
+	l1cgrp = cgroup_ancestor_l1(cgrp);
+	if (l1cgrp)
+		update_cgroup_ids_table(cgrp->kn->id, cgrp_name_to_idx(l1cgrp));
+	cgroup_put(l1cgrp);
+}
+
+static void cgrp_dsq_idx_init(struct cgroup *cgrp, struct task_group *tg)
+{
+	switch (cgrp->level) {
+	case 0:
+		init_root_tg(cgrp, tg);
+		break;
+	case 1:
+		init_level1_tg(cgrp, tg);
+		break;
+	default:
+		init_child_tg(cgrp, tg);
+		break;
+	}
+}
+
+/**************************************************************************/
+
+struct hmbird_task_iter {
+	struct hmbird_entity		cursor;
+	struct task_struct		*locked;
+	struct rq			*rq;
+	struct rq_flags			rf;
+};
+
+/**
+ * hmbird_task_iter_init - Initialize a task iterator
+ * @iter: iterator to init
+ *
+ * Initialize @iter. Must be called with hmbird_tasks_lock held. Once initialized,
+ * @iter must eventually be exited with hmbird_task_iter_exit().
+ *
+ * hmbird_tasks_lock may be released between this and the first next() call or
+ * between any two next() calls. If hmbird_tasks_lock is released between two
+ * next() calls, the caller is responsible for ensuring that the task being
+ * iterated remains accessible either through RCU read lock or obtaining a
+ * reference count.
+ *
+ * All tasks which existed when the iteration started are guaranteed to be
+ * visited as long as they still exist.
+ */
+static void hmbird_task_iter_init(struct hmbird_task_iter *iter)
+{
+	lockdep_assert_held(&hmbird_tasks_lock);
+
+	iter->cursor = (struct hmbird_entity){ .flags = HMBIRD_TASK_CURSOR };
+	list_add(&iter->cursor.tasks_node, &hmbird_tasks);
+	iter->locked = NULL;
+}
+
+/**
+ * hmbird_task_iter_exit - Exit a task iterator
+ * @iter: iterator to exit
+ *
+ * Exit a previously initialized @iter. Must be called with hmbird_tasks_lock held.
+ * If the iterator holds a task's rq lock, that rq lock is released. See
+ * hmbird_task_iter_init() for details.
+ */
+static void hmbird_task_iter_exit(struct hmbird_task_iter *iter)
+{
+	struct list_head *cursor = &iter->cursor.tasks_node;
+
+	lockdep_assert_held(&hmbird_tasks_lock);
+
+	if (iter->locked) {
+		task_rq_unlock(iter->rq, iter->locked, &iter->rf);
+		iter->locked = NULL;
+	}
+
+	if (list_empty(cursor))
+		return;
+
+	list_del_init(cursor);
+}
+
+/**
+ * hmbird_task_iter_next - Next task
+ * @iter: iterator to walk
+ *
+ * Visit the next task. See hmbird_task_iter_init() for details.
+ */
+static struct task_struct *hmbird_task_iter_next(struct hmbird_task_iter *iter)
+{
+	struct list_head *cursor = &iter->cursor.tasks_node;
+	struct hmbird_entity *pos;
+
+	lockdep_assert_held(&hmbird_tasks_lock);
+
+	list_for_each_entry(pos, cursor, tasks_node) {
+		if (&pos->tasks_node == &hmbird_tasks)
+			return NULL;
+		if (!(pos->flags & HMBIRD_TASK_CURSOR)) {
+			list_move(cursor, &pos->tasks_node);
+			return pos->task;
+		}
+	}
+
+	/* can't happen, should always terminate at hmbird_tasks above */
+	hmbird_deferred_err(ITER_RET_NULL, "<error> : unreachable path in scx_task_iter_next\n");
+	return NULL;
+}
+
+/**
+ * hmbird_task_iter_next_filtered - Next non-idle task
+ * @iter: iterator to walk
+ *
+ * Visit the next non-idle task. See hmbird_task_iter_init() for details.
+ */
+static struct task_struct *
+hmbird_task_iter_next_filtered(struct hmbird_task_iter *iter)
+{
+	struct task_struct *p;
+
+	while ((p = hmbird_task_iter_next(iter))) {
+		if (!is_idle_task(p))
+			return p;
+	}
+	return NULL;
+}
+
+/**
+ * hmbird_task_iter_next_filtered_locked - Next non-idle task with its rq locked
+ * @iter: iterator to walk
+ *
+ * Visit the next non-idle task with its rq lock held. See hmbird_task_iter_init()
+ * for details.
+ */
+static struct task_struct *
+hmbird_task_iter_next_filtered_locked(struct hmbird_task_iter *iter)
+{
+	struct task_struct *p;
+
+	if (iter->locked) {
+		task_rq_unlock(iter->rq, iter->locked, &iter->rf);
+		iter->locked = NULL;
+	}
+
+	p = hmbird_task_iter_next_filtered(iter);
+	if (!p)
+		return NULL;
+
+	iter->rq = task_rq_lock(p, &iter->rf);
+	iter->locked = p;
+	return p;
+}
+
+static enum hmbird_ops_enable_state hmbird_ops_enable_state(void)
+{
+	return atomic_read(&hmbird_ops_enable_state_var);
+}
+
+static enum hmbird_ops_enable_state
+hmbird_ops_set_enable_state(enum hmbird_ops_enable_state to)
+{
+	return atomic_xchg(&hmbird_ops_enable_state_var, to);
+}
+
+static bool hmbird_ops_tryset_enable_state(enum hmbird_ops_enable_state to,
+					enum hmbird_ops_enable_state from)
+{
+	int from_v = from;
+
+	return atomic_try_cmpxchg(&hmbird_ops_enable_state_var, &from_v, to);
+}
+
+static bool hmbird_ops_disabling(void)
+{
+	return false;
+}
+
+/**
+ * wait_ops_state - Busy-wait the specified ops state to end
+ * @p: target task
+ * @opss: state to wait the end of
+ *
+ * Busy-wait for @p to transition out of @opss. This can only be used when the
+ * state part of @opss is %HMBIRD_QUEUEING or %HMBIRD_DISPATCHING. This function also
+ * has load_acquire semantics to ensure that the caller can see the updates made
+ * in the enqueueing and dispatching paths.
+ */
+static void wait_ops_state(struct task_struct *p, u64 opss)
+{
+	do {
+		cpu_relax();
+	} while (atomic64_read_acquire(&(get_hmbird_ts(p)->ops_state)) == opss);
+}
+
+
+static void update_curr_hmbird(struct rq *rq)
+{
+	struct task_struct *curr = rq->curr;
+	u64 now = rq_clock_task(rq);
+	u64 delta_exec;
+
+	if (time_before_eq64(now, curr->se.exec_start))
+		return;
+
+	delta_exec = now - curr->se.exec_start;
+	curr->se.exec_start = now;
+	update_runningtime(rq, curr, delta_exec);
+	curr->se.sum_exec_runtime += delta_exec;
+	account_group_exec_runtime(curr, delta_exec);
+	cgroup_account_cputime(curr, delta_exec);
+
+	if (get_hmbird_ts(curr)->slice != HMBIRD_SLICE_INF)
+		get_hmbird_ts(curr)->slice -= min(get_hmbird_ts(curr)->slice, delta_exec);
+
+	trace_sched_stat_runtime(curr, delta_exec, 0);
+}
+
+static bool hmbird_dsq_priq_less(struct rb_node *node_a,
+					const struct rb_node *node_b)
+{
+	const struct hmbird_entity *a =
+		container_of(node_a, struct hmbird_entity, dsq_node.priq);
+	const struct hmbird_entity *b =
+		container_of(node_b, struct hmbird_entity, dsq_node.priq);
+
+	return time_before64(a->dsq_vtime, b->dsq_vtime);
+}
+
+static void dispatch_enqueue(struct hmbird_dispatch_q *dsq, struct task_struct *p,
+							u64 enq_flags)
+{
+	bool is_local = dsq->id == HMBIRD_DSQ_LOCAL;
+	unsigned long flags;
+
+	hmbird_cond_deferred_err(ENQ_EXIST1, get_hmbird_ts(p)->dsq ||
+				!list_empty(&get_hmbird_ts(p)->dsq_node.fifo),
+				"task = %s, dsq->id = %llu\n", p->comm, dsq->id);
+	hmbird_cond_deferred_err(ENQ_EXIST2,
+				(get_hmbird_ts(p)->dsq_flags & HMBIRD_TASK_DSQ_ON_PRIQ) ||
+				!RB_EMPTY_NODE(&get_hmbird_ts(p)->dsq_node.priq),
+				"task = %s\n", p->comm);
+
+	if (!is_local) {
+		raw_spin_lock_irqsave(&dsq->lock, flags);
+		if (unlikely(dsq->id == HMBIRD_DSQ_INVALID)) {
+			WRITE_ONCE(sw_type, HMBIRD_SWITCH_ERR_DSQ);
+			hmbird_ops_error("<hmbird_sched>: %s\n",
+					"attempting to dispatch to a destroyed dsq");
+			/* fall back to the global dsq */
+			raw_spin_unlock_irqrestore(&dsq->lock, flags);
+			dsq = &hmbird_dsq_global;
+			raw_spin_lock_irqsave(&dsq->lock, flags);
+		}
+	}
+
+	if (enq_flags & HMBIRD_ENQ_DSQ_PRIQ) {
+		get_hmbird_ts(p)->dsq_flags |= HMBIRD_TASK_DSQ_ON_PRIQ;
+		rb_add_cached(&get_hmbird_ts(p)->dsq_node.priq, &dsq->priq,
+					hmbird_dsq_priq_less);
+	} else {
+		if (enq_flags & (HMBIRD_ENQ_HEAD | HMBIRD_ENQ_PREEMPT))
+			list_add(&get_hmbird_ts(p)->dsq_node.fifo, &dsq->fifo);
+		else
+			list_add_tail(&get_hmbird_ts(p)->dsq_node.fifo, &dsq->fifo);
+	}
+	dsq->nr++;
+	get_hmbird_ts(p)->dsq = dsq;
+
+	/*
+	 * We're transitioning out of QUEUEING or DISPATCHING. store_release to
+	 * match waiters' load_acquire.
+	 */
+	if (enq_flags & HMBIRD_ENQ_CLEAR_OPSS)
+		atomic64_set_release(&get_hmbird_ts(p)->ops_state, HMBIRD_OPSS_NONE);
+
+	if (is_local) {
+		struct hmbird_rq *hmbird = container_of(dsq, struct hmbird_rq, local_dsq);
+		struct rq *rq = hmbird->rq;
+		bool preempt = false;
+
+		if ((enq_flags & HMBIRD_ENQ_PREEMPT) && p != rq->curr &&
+			rq->curr->sched_class == &hmbird_sched_class) {
+			get_hmbird_ts(rq->curr)->slice = 0;
+			preempt = true;
+		}
+
+		if (preempt || sched_class_above(&hmbird_sched_class,
+						rq->curr->sched_class))
+			resched_curr(rq);
+	} else {
+		raw_spin_unlock_irqrestore(&dsq->lock, flags);
+	}
+}
+
+static void task_unlink_from_dsq(struct task_struct *p,
+				struct hmbird_dispatch_q *dsq)
+{
+	if (get_hmbird_ts(p)->dsq_flags & HMBIRD_TASK_DSQ_ON_PRIQ) {
+		rb_erase_cached(&get_hmbird_ts(p)->dsq_node.priq, &dsq->priq);
+		RB_CLEAR_NODE(&get_hmbird_ts(p)->dsq_node.priq);
+		get_hmbird_ts(p)->dsq_flags &= ~HMBIRD_TASK_DSQ_ON_PRIQ;
+	} else {
+		list_del_init(&get_hmbird_ts(p)->dsq_node.fifo);
+	}
+}
+
+static bool task_linked_on_dsq(struct task_struct *p)
+{
+	return !list_empty(&get_hmbird_ts(p)->dsq_node.fifo) ||
+		!RB_EMPTY_NODE(&get_hmbird_ts(p)->dsq_node.priq);
+}
+
+static void dispatch_dequeue(struct hmbird_rq *hmbird_rq, struct task_struct *p)
+{
+	unsigned long flags;
+	struct hmbird_dispatch_q *dsq = get_hmbird_ts(p)->dsq;
+	bool is_local = dsq == &hmbird_rq->local_dsq;
+
+	if (!dsq) {
+		hmbird_cond_deferred_err(TASK_LINKED1,
+						task_linked_on_dsq(p), "task = %s\n", p->comm);
+		/*
+		 * When dispatching directly from the BPF scheduler to a local
+		 * DSQ, the task isn't associated with any DSQ but
+		 * @get_hmbird_ts(p)->holding_cpu may be set under the protection of
+		 * %HMBIRD_OPSS_DISPATCHING.
+		 */
+		if (get_hmbird_ts(p)->holding_cpu >= 0)
+			get_hmbird_ts(p)->holding_cpu = -1;
+		return;
+	}
+
+	if (!is_local)
+		raw_spin_lock_irqsave(&dsq->lock, flags);
+
+	/*
+	 * Now that we hold @dsq->lock, @p->holding_cpu and @get_hmbird_ts(p)->dsq_node
+	 * can't change underneath us.
+	 */
+	if (get_hmbird_ts(p)->holding_cpu < 0) {
+		/* @p must still be on @dsq, dequeue */
+		hmbird_cond_deferred_err(TASK_UNLINKED,
+						!task_linked_on_dsq(p), "task = %s\n", p->comm);
+		task_unlink_from_dsq(p, dsq);
+		dsq->nr--;
+	} else {
+		/*
+		 * We're racing against dispatch_to_local_dsq() which already
+		 * removed @p from @dsq and set @get_hmbird_ts(p)->holding_cpu. Clear the
+		 * holding_cpu which tells dispatch_to_local_dsq() that it lost
+		 * the race.
+		 */
+		hmbird_cond_deferred_err(TASK_LINKED2,
+						task_linked_on_dsq(p), "task = %s\n", p->comm);
+		get_hmbird_ts(p)->holding_cpu = -1;
+	}
+	get_hmbird_ts(p)->dsq = NULL;
+
+	if (!is_local)
+		raw_spin_unlock_irqrestore(&dsq->lock, flags);
+}
+
+
+static bool test_rq_online(struct rq *rq)
+{
+#ifdef CONFIG_SMP
+	return rq->online;
+#else
+	return true;
+#endif
+}
+
+static void refill_task_slice(struct task_struct *p)
+{
+	if (is_isolate_task(p))
+		get_hmbird_ts(p)->slice = HMBIRD_SLICE_ISO;
+	else if (is_pipeline_task(p))
+		get_hmbird_ts(p)->slice = HMBIRD_SLICE_ISO / 2;
+	else
+		get_hmbird_ts(p)->slice = HMBIRD_SLICE_DFL;
+}
+
+static void do_enqueue_task(struct rq *rq, struct task_struct *p, u64 enq_flags,
+				int sticky_cpu)
+{
+	struct hmbird_dispatch_q *d;
+	s32 cpu = -1;
+
+	hmbird_cond_deferred_err(TASK_UNQUED, !test_bit(ffs(HMBIRD_TASK_QUEUED),
+				(unsigned long *)&get_hmbird_ts(p)->flags),
+				"task = %s\n", p->comm);
+
+	if (is_pcp_rt(p)) {
+		/* Enqueue percpu rt task to local directly. */
+		/* Or cause a bug when disable dispatch. */
+		if (cpumask_test_cpu(cpu_of(rq), p->cpus_ptr))
+			enq_flags |= HMBIRD_ENQ_LOCAL;
+	}
+
+	cpu = get_hmbird_ts(p)->critical_affinity_cpu;
+	if (cpu >= 0) {
+		set_bit(ffs(HMBIRD_TASK_ENQ_LOCAL), (unsigned long *)&get_hmbird_ts(p)->flags);
+	}
+
+	if (test_bit(ffs(HMBIRD_TASK_ENQ_LOCAL), (unsigned long *)&get_hmbird_ts(p)->flags)) {
+		enq_flags |= HMBIRD_ENQ_LOCAL;
+		clear_bit(ffs(HMBIRD_TASK_ENQ_LOCAL), (unsigned long *)&get_hmbird_ts(p)->flags);
+	}
+	/* rq migration */
+	if (sticky_cpu == cpu_of(rq))
+		goto local_norefill;
+	/*
+	 * If !rq->online, we already told the BPF scheduler that the CPU is
+	 * offline. We're just trying to on/offline the CPU. Don't bother the
+	 * BPF scheduler.
+	 */
+	if (unlikely(!test_rq_online(rq)))
+		goto local;
+
+	/* see %HMBIRD_OPS_ENQ_LAST */
+	if (enq_flags & HMBIRD_ENQ_LAST)
+		goto local;
+
+	if (enq_flags & HMBIRD_ENQ_LOCAL)
+		goto local;
+	else
+		goto global;
+local:
+	/*
+	 * For task-ordering, slice refill must be treated as implying the end
+	 * of the current slice. Otherwise, the longer @p stays on the CPU, the
+	 * higher priority it becomes from hmbird_prio_less()'s POV.
+	 */
+	refill_task_slice(p);
+local_norefill:
+	dispatch_enqueue(&get_hmbird_rq(rq)->local_dsq, p, enq_flags);
+	slim_stats_record(PCP_ENQL_CNT, 0, 0, cpu_of(rq));
+	return;
+
+global:
+	d = find_dsq_from_task(p);
+	if (d) {
+		refill_task_slice(p);
+		dispatch_enqueue(d, p, enq_flags);
+		return;
+	}
+	slim_stats_record(GLOBAL_STAT, 0, 0, 0);
+	refill_task_slice(p);
+	dispatch_enqueue(&hmbird_dsq_global, p, enq_flags);
+}
+
+static bool watchdog_task_watched(const struct task_struct *p)
+{
+	return !list_empty(&get_hmbird_ts(p)->watchdog_node);
+}
+
+static void watchdog_watch_task(struct rq *rq, struct task_struct *p)
+{
+	lockdep_assert_rq_held(rq);
+	if (test_bit(ffs(HMBIRD_TASK_WATCHDOG_RESET), (unsigned long *)&get_hmbird_ts(p)->flags))
+		get_hmbird_ts(p)->runnable_at = jiffies;
+	clear_bit(ffs(HMBIRD_TASK_WATCHDOG_RESET), (unsigned long *)&get_hmbird_ts(p)->flags);
+	list_add_tail(&get_hmbird_ts(p)->watchdog_node, &get_hmbird_rq(rq)->watchdog_list);
+}
+
+static void watchdog_unwatch_task(struct task_struct *p, bool reset_timeout)
+{
+	list_del_init(&get_hmbird_ts(p)->watchdog_node);
+	if (reset_timeout)
+		set_bit(ffs(HMBIRD_TASK_WATCHDOG_RESET), (unsigned long *)&get_hmbird_ts(p)->flags);
+}
+
+static void enqueue_task_hmbird(struct rq *rq, struct task_struct *p, int enq_flags)
+{
+	int sticky_cpu = get_hmbird_ts(p)->sticky_cpu;
+
+	enq_flags |= get_hmbird_rq(rq)->extra_enq_flags;
+
+	if (sticky_cpu >= 0)
+		get_hmbird_ts(p)->sticky_cpu = -1;
+
+	/*
+	 * Restoring a running task will be immediately followed by
+	 * set_next_task_hmbird() which expects the task to not be on the BPF
+	 * scheduler as tasks can only start running through local DSQs. Force
+	 * direct-dispatch into the local DSQ by setting the sticky_cpu.
+	 */
+	if (unlikely(enq_flags & ENQUEUE_RESTORE) && task_current(rq, p))
+		sticky_cpu = cpu_of(rq);
+
+	if (test_bit(ffs(HMBIRD_TASK_QUEUED), (unsigned long *)&get_hmbird_ts(p)->flags)) {
+		hmbird_cond_deferred_err(TASK_UNWATCHED,
+			!watchdog_task_watched(p), "task = %s\n", p->comm);
+		return;
+	}
+
+	watchdog_watch_task(rq, p);
+	set_bit(ffs(HMBIRD_TASK_QUEUED), (unsigned long *)&get_hmbird_ts(p)->flags);
+	get_hmbird_rq(rq)->nr_running++;
+	add_nr_running(rq, 1);
+
+	do_enqueue_task(rq, p, enq_flags, sticky_cpu);
+}
+
+static void ops_dequeue(struct task_struct *p, u64 deq_flags)
+{
+	u64 opss;
+
+	watchdog_unwatch_task(p, false);
+
+	/* acquire ensures that we see the preceding updates on QUEUED */
+	opss = atomic64_read_acquire(&get_hmbird_ts(p)->ops_state);
+
+	switch (opss & HMBIRD_OPSS_STATE_MASK) {
+	case HMBIRD_OPSS_NONE:
+		break;
+	case HMBIRD_OPSS_QUEUEING:
+		/*
+		 * QUEUEING is started and finished while holding @p's rq lock.
+		 * As we're holding the rq lock now, we shouldn't see QUEUEING.
+		 */
+		hmbird_deferred_err(DEQ_DEQING, "<error> : unreachable path in %s\n", __func__);
+		break;
+	case HMBIRD_OPSS_QUEUED:
+		if (atomic64_try_cmpxchg(&get_hmbird_ts(p)->ops_state, &opss,
+					 HMBIRD_OPSS_NONE))
+			break;
+		fallthrough;
+	case HMBIRD_OPSS_DISPATCHING:
+		/*
+		 * If @p is being dispatched from the BPF scheduler to a DSQ,
+		 * wait for the transfer to complete so that @p doesn't get
+		 * added to its DSQ after dequeueing is complete.
+		 *
+		 * As we're waiting on DISPATCHING with the rq locked, the
+		 * dispatching side shouldn't try to lock the rq while
+		 * DISPATCHING is set. See dispatch_to_local_dsq().
+		 *
+		 * DISPATCHING shouldn't have qseq set and control can reach
+		 * here with NONE @opss from the above QUEUED case block.
+		 * Explicitly wait on %HMBIRD_OPSS_DISPATCHING instead of @opss.
+		 */
+		wait_ops_state(p, HMBIRD_OPSS_DISPATCHING);
+		hmbird_cond_deferred_err(HMBIRD_OPN,
+			atomic64_read(&get_hmbird_ts(p)->ops_state) != HMBIRD_OPSS_NONE,
+						"task = %s\n", p->comm);
+		break;
+	}
+}
+
+static void dequeue_task_hmbird(struct rq *rq, struct task_struct *p, int deq_flags)
+{
+	struct hmbird_rq *hmbird_rq = get_hmbird_rq(rq);
+
+	if (!test_bit(ffs(HMBIRD_TASK_QUEUED), (unsigned long *)&get_hmbird_ts(p)->flags)) {
+		hmbird_cond_deferred_err(TASK_WATCHED, watchdog_task_watched(p),
+						"task = %s\n", p->comm);
+		return;
+	}
+
+	ops_dequeue(p, deq_flags);
+
+	if (slim_walt_ctrl) {
+		if (task_current(rq, p))
+			hmbird_update_task_ravg_rqclock_wrapper(p, rq, PUT_PREV_TASK);
+	}
+
+	if (deq_flags & HMBIRD_DEQ_SLEEP)
+		set_bit(ffs(HMBIRD_TASK_DEQD_FOR_SLEEP), (unsigned long *)&get_hmbird_ts(p)->flags);
+	else
+		clear_bit(ffs(HMBIRD_TASK_DEQD_FOR_SLEEP),
+			(unsigned long *)&get_hmbird_ts(p)->flags);
+
+	clear_bit(ffs(HMBIRD_TASK_QUEUED), (unsigned long *)&get_hmbird_ts(p)->flags);
+	hmbird_cond_deferred_err(RQ_NO_RUNNING, !hmbird_rq->nr_running, "task = %s\n", p->comm);
+	hmbird_rq->nr_running--;
+	sub_nr_running(rq, 1);
+	dispatch_dequeue(hmbird_rq, p);
+}
+
+static void yield_task_hmbird(struct rq *rq)
+{
+	struct task_struct *p = rq->curr;
+
+	get_hmbird_ts(p)->slice = 0;
+}
+
+static bool yield_to_task_hmbird(struct rq *rq, struct task_struct *to)
+{
+	return false;
+}
+
+#ifdef CONFIG_SMP
+/**
+ * move_task_to_local_dsq - Move a task from a different rq to a local DSQ
+ * @rq: rq to move the task into, currently locked
+ * @p: task to move
+ * @enq_flags: %HMBIRD_ENQ_*
+ *
+ * Move @p which is currently on a different rq to @rq's local DSQ. The caller
+ * must:
+ *
+ * 1. Start with exclusive access to @p either through its DSQ lock or
+ *    %HMBIRD_OPSS_DISPATCHING flag.
+ *
+ * 2. Set @get_hmbird_ts(p)->holding_cpu to raw_smp_processor_id().
+ *
+ * 3. Remember task_rq(@p). Release the exclusive access so that we don't
+ *    deadlock with dequeue.
+ *
+ * 4. Lock @rq and the task_rq from #3.
+ *
+ * 5. Call this function.
+ *
+ * Returns %true if @p was successfully moved. %false after racing dequeue and
+ * losing.
+ */
+static bool move_task_to_local_dsq(struct rq *rq, struct task_struct *p,
+					u64 enq_flags)
+{
+	struct rq *task_rq;
+
+	lockdep_assert_rq_held(rq);
+
+	/*
+	 * If dequeue got to @p while we were trying to lock both rq's, it'd
+	 * have cleared @get_hmbird_ts(p)->holding_cpu to -1. While other cpus may have
+	 * updated it to different values afterwards, as this operation can't be
+	 * preempted or recurse, @get_hmbird_ts(p)->holding_cpu can never become
+	 * raw_smp_processor_id() again before we're done. Thus, we can tell
+	 * whether we lost to dequeue by testing whether @get_hmbird_ts(p)->holding_cpu is
+	 * still raw_smp_processor_id().
+	 *
+	 * See dispatch_dequeue() for the counterpart.
+	 */
+	if (unlikely(get_hmbird_ts(p)->holding_cpu != raw_smp_processor_id()))
+		return false;
+
+	/* @p->rq couldn't have changed if we're still the holding cpu */
+	task_rq = task_rq(p);
+	lockdep_assert_rq_held(task_rq);
+	deactivate_task(task_rq, p, 0);
+	set_task_cpu(p, cpu_of(rq));
+	get_hmbird_ts(p)->sticky_cpu = cpu_of(rq);
+
+	/*
+	 * We want to pass hmbird-specific enq_flags but activate_task() will
+	 * truncate the upper 32 bit. As we own @rq, we can pass them through
+	 * @get_hmbird_rq(rq)->extra_enq_flags instead.
+	 */
+	hmbird_cond_deferred_err(EXTRA_FLAGS, get_hmbird_rq(rq)->extra_enq_flags,
+					"task = %s\n", p->comm);
+	get_hmbird_rq(rq)->extra_enq_flags = enq_flags;
+	activate_task(rq, p, 0);
+	get_hmbird_rq(rq)->extra_enq_flags = 0;
+
+	return true;
+}
+
+#endif	/* CONFIG_SMP */
+
+static int task_fits_cpu_hmbird(struct task_struct *p, int cpu)
+{
+	int fitable = 1;
+
+	return fitable;
+}
+
+static int check_misfit_task_on_little(struct task_struct *p, struct rq *rq,
+						struct hmbird_dispatch_q *dsq)
+{
+	bool dsq_misfit;
+	int cpu = cpu_of(rq);
+	u64 task_util = 0;
+	struct cluster_ctx ctx;
+	int dsq_int = dsq_id_to_internal(dsq);
+
+	if (!cpumask_test_cpu(cpu, iso_masks.little))
+		return false;
+
+	gen_cluster_ctx(&ctx, BIG);
+	dsq_misfit = (dsq_int >= SCHED_PROP_DEADLINE_LEVEL1 &&
+				dsq_int <= SCHED_PROP_DEADLINE_LEVEL4);
+#ifdef CLUSTER_SEPARATE
+	/* In rescue mode, little will consume big cluster's dsq.*/
+	dsq_misfit |= (dsq_int >= ctx.lower && dsq_int < ctx.upper);
+#endif
+	if (!dsq_misfit)
+		return false;
+
+	if (p) {
+		if (slim_walt_ctrl)
+			slim_get_task_util(p, &task_util);
+		else
+			task_util = get_hmbird_ts(p)->demand_scaled;
+	}
+
+	if (task_util <= misfit_ds)
+		return false;
+
+	hmbird_info_trace("<filter>:task %s can't run on cpu%d, util = %llu\n",
+							p->comm, cpu, task_util);
+	return true;
+}
+
+static bool task_can_run_on_rq(struct task_struct *p, struct rq *rq, struct hmbird_dispatch_q *dsq)
+{
+	if (!task_fits_cpu_hmbird(p, cpu_of(rq)))
+		return false;
+
+	if (check_misfit_task_on_little(p, rq, dsq))
+		return false;
+
+	return likely(test_rq_online(rq));
+}
+
+static void set_skip_num(struct hmbird_dispatch_q *dsq, int *skipn, bool add)
+{
+	int idx = dsq_id_to_internal(dsq);
+	int type = get_dsq_type(dsq);
+
+	if (type != GLOBAL_DSQ)
+		return;
+
+	if (add)
+		skipn[idx]++;
+	else
+		skipn[idx] = 0;
+}
+
+static bool skip_too_much(struct hmbird_dispatch_q *dsq)
+{
+	int idx = dsq_id_to_internal(dsq);
+	int type = get_dsq_type(dsq);
+
+	if (type != GLOBAL_DSQ)
+		return false;
+
+	if (skip_num[idx] > 3) {
+		skip_num[idx] = 0;
+		return true;
+	}
+
+	return false;
+}
+
+bool consume_dispatch_q(struct rq *rq, struct rq_flags *rf,
+					struct hmbird_dispatch_q *dsq)
+{
+	struct hmbird_rq *hmbird_rq = get_hmbird_rq(rq);
+	struct hmbird_entity *entity;
+	struct task_struct *p;
+	struct rb_node *rb_node;
+	struct rq *task_rq;
+	unsigned long flags;
+	bool moved = false;
+	struct task_struct *may_fit = NULL;
+	int skip = 0;
+
+retry:
+	if (list_empty(&dsq->fifo) && !rb_first_cached(&dsq->priq))
+		return false;
+
+	raw_spin_lock_irqsave(&dsq->lock, flags);
+
+	list_for_each_entry(entity, &dsq->fifo, dsq_node.fifo) {
+		p = entity->task;
+		task_rq = task_rq(p);
+		if (!task_can_run_on_rq(p, rq, dsq))
+			continue;
+		if (rq == task_rq) {
+			set_skip_num(dsq, skip_num, (bool)may_fit);
+			goto this_rq;
+		}
+		if (skip_too_much(dsq))
+			goto remote_rq;
+		if (!may_fit)
+			may_fit = p;
+		if (++skip <= 3)
+			continue;
+		/*
+		 * If the recent 3 tasks not fit, use the first one.
+		 * and clear the skip, because the first one is consumed.
+		 */
+		set_skip_num(dsq, skip_num, false);
+		p = may_fit;
+		task_rq = task_rq(p);
+		goto remote_rq;
+	}
+	/* No more task, use the first may fit task.*/
+	if (may_fit) {
+		p = may_fit;
+		task_rq = task_rq(p);
+		goto remote_rq;
+	}
+
+	for (rb_node = rb_first_cached(&dsq->priq); rb_node; rb_node = rb_next(rb_node)) {
+		entity = container_of(rb_node, struct hmbird_entity, dsq_node.priq);
+		p = entity->task;
+		task_rq = task_rq(p);
+		if (!task_can_run_on_rq(p, rq, dsq))
+			continue;
+		if (rq == task_rq)
+			goto this_rq;
+		goto remote_rq;
+	}
+
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+	return false;
+
+this_rq:
+	/* @dsq is locked and @p is on this rq */
+	hmbird_cond_deferred_err(HOLDING_CPU1, get_hmbird_ts(p)->holding_cpu >= 0,
+					"task = %s\n", p->comm);
+	task_unlink_from_dsq(p, dsq);
+	list_add_tail(&get_hmbird_ts(p)->dsq_node.fifo, &hmbird_rq->local_dsq.fifo);
+	dsq->nr--;
+	hmbird_rq->local_dsq.nr++;
+	get_hmbird_ts(p)->dsq = &hmbird_rq->local_dsq;
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+	slim_stats_record(TOTAL_DSP_CNT, 0, 0, 0);
+	return true;
+
+remote_rq:
+#ifdef CONFIG_SMP
+	if (cpu_same_cluster_stat(p, rq, task_rq))
+		slim_stats_record(MOVE_RQ_CNT, 0, 0, 0);
+	else
+		slim_stats_record(MOVE_RQ_CNT, 1, 0, 0);
+	/*
+	 * @dsq is locked and @p is on a remote rq. @p is currently protected by
+	 * @dsq->lock. We want to pull @p to @rq but may deadlock if we grab
+	 * @task_rq while holding @dsq and @rq locks. As dequeue can't drop the
+	 * rq lock or fail, do a little dancing from our side. See
+	 * move_task_to_local_dsq().
+	 */
+	hmbird_cond_deferred_err(HOLDING_CPU2, get_hmbird_ts(p)->holding_cpu >= 0,
+					"task = %s\n", p->comm);
+	task_unlink_from_dsq(p, dsq);
+	dsq->nr--;
+	get_hmbird_ts(p)->holding_cpu = raw_smp_processor_id();
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+
+	rq_unpin_lock(rq, rf);
+	double_lock_balance(rq, task_rq);
+	rq_repin_lock(rq, rf);
+
+	moved = move_task_to_local_dsq(rq, p, 0);
+
+	double_unlock_balance(rq, task_rq);
+#endif /* CONFIG_SMP */
+	if (likely(moved)) {
+		slim_stats_record(TOTAL_DSP_CNT, 0, 0, 0);
+		return true;
+	}
+	may_fit = NULL;
+	goto retry;
+}
+
+
+static int balance_one(struct rq *rq, struct task_struct *prev,
+				struct rq_flags *rf, bool local)
+{
+	struct hmbird_rq *hmbird_rq = get_hmbird_rq(rq);
+	bool prev_on_hmbird = prev->sched_class == &hmbird_sched_class;
+
+	if (!hmbird_rq)
+		return 1;
+
+	lockdep_assert_rq_held(rq);
+
+	if (static_branch_unlikely(&hmbird_ops_cpu_preempt) &&
+		unlikely(get_hmbird_rq(rq)->cpu_released)) {
+		/*
+		 * If the previous sched_class for the current CPU was not HMBIRD,
+		 * notify the BPF scheduler that it again has control of the
+		 * core. This callback complements ->cpu_release(), which is
+		 * emitted in hmbird_notify_pick_next_task().
+		 */
+		get_hmbird_rq(rq)->cpu_released = false;
+	}
+
+	if (prev_on_hmbird)
+		update_curr_hmbird(rq);
+	/* if there already are tasks to run, nothing to do */
+	if (hmbird_rq->local_dsq.nr)
+		return 1;
+
+	if (consume_dispatch_q(rq, rf, &hmbird_dsq_global)) {
+		slim_stats_record(GLOBAL_STAT, 1, 0, 0);
+		return 1;
+	}
+
+	if (consume_dispatch_global(rq, rf))
+		return 1;
+
+	return 0;
+}
+
+static int balance_hmbird(struct rq *rq, struct task_struct *prev,
+						struct rq_flags *rf)
+{
+	return balance_one(rq, prev, rf, true);
+}
+
+/*
+ * output task util to systrace, only for debug mode.
+ * we can not output too many logs to systrace buffer even in debug mode
+ * only output debug-info while it exceed misfit_ds.
+ */
+static void systrace_output_cpu_ds(struct rq *rq, struct task_struct *p)
+{
+	static DEFINE_PER_CPU(int, is_last_exceed);
+	int cpu = cpu_of(rq);
+	u64 util = 0;
+
+	if (likely(!debug_enabled()))
+		return;
+
+	if (!p)
+		return;
+
+	if (slim_walt_ctrl)
+		slim_get_task_util(p, &util);
+	else
+		util = get_hmbird_ts(p)->demand_scaled;
+	util = uclamp_rq_util_with(rq, util, p);
+
+	if (util >= misfit_ds) {
+		hmbird_internal_systrace("C|9999|cpu_%d_ds|%llu\n", cpu, util);
+		per_cpu(is_last_exceed, cpu) = true;
+	} else if (per_cpu(is_last_exceed, cpu) && (util < misfit_ds)) {
+		hmbird_internal_systrace("C|9999|cpu_%d_ds|%d\n", cpu, 0);
+		per_cpu(is_last_exceed, cpu) = false;
+	} else {
+	}
+}
+
+static void set_next_task_hmbird(struct rq *rq, struct task_struct *p, bool first)
+{
+	if (test_bit(ffs(HMBIRD_TASK_QUEUED), (unsigned long *)&get_hmbird_ts(p)->flags)) {
+		/*
+		 * Core-sched might decide to execute @p before it is
+		 * dispatched. Call ops_dequeue() to notify the BPF scheduler.
+		 */
+		ops_dequeue(p, HMBIRD_DEQ_CORE_SCHED_EXEC);
+		dispatch_dequeue(get_hmbird_rq(rq), p);
+	}
+
+	p->se.exec_start = rq_clock_task(rq);
+
+	if (slim_walt_ctrl) {
+		if (test_bit(ffs(HMBIRD_TASK_QUEUED), (unsigned long *)&get_hmbird_ts(p)->flags))
+			hmbird_update_task_ravg_rqclock_wrapper(p, rq, PICK_NEXT_TASK);
+	}
+
+	watchdog_unwatch_task(p, true);
+	slim_trace_show_cpu_consume_dsq_idx(smp_processor_id(), get_hmbird_ts(p)->gdsq_idx);
+	systrace_output_cpu_ds(rq, p);
+	/*
+	 * @p is getting newly scheduled or got kicked after someone updated its
+	 * slice. Refresh whether tick can be stopped. See can_stop_tick_hmbird().
+	 */
+	if ((get_hmbird_ts(p)->slice == HMBIRD_SLICE_INF) !=
+	    (bool)(get_hmbird_rq(rq)->flags & HMBIRD_RQ_CAN_STOP_TICK)) {
+		if (get_hmbird_ts(p)->slice == HMBIRD_SLICE_INF)
+			get_hmbird_rq(rq)->flags |= HMBIRD_RQ_CAN_STOP_TICK;
+		else
+			get_hmbird_rq(rq)->flags &= ~HMBIRD_RQ_CAN_STOP_TICK;
+
+		sched_update_tick_dependency(rq);
+	}
+
+	p->se.prev_sum_exec_runtime = p->se.sum_exec_runtime;
+}
+
+static void put_prev_task_hmbird(struct rq *rq, struct task_struct *p)
+{
+	update_curr_hmbird(rq);
+
+	update_dispatch_dsq_info(rq, p);
+
+	if (slim_walt_ctrl) {
+		if (test_bit(ffs(HMBIRD_TASK_QUEUED), (unsigned long *)&get_hmbird_ts(p)->flags))
+			hmbird_update_task_ravg_rqclock_wrapper(p, rq, PUT_PREV_TASK);
+	}
+
+	slim_trace_show_cpu_consume_dsq_idx(smp_processor_id(), 0);
+
+	if (test_bit(ffs(HMBIRD_TASK_QUEUED), (unsigned long *)&get_hmbird_ts(p)->flags)) {
+		watchdog_watch_task(rq, p);
+
+		if (is_pipeline_task(p)) {
+			do_enqueue_task(rq, p, HMBIRD_ENQ_LOCAL, -1);
+			return;
+		}
+
+		/*
+		 * If we're in the pick_next_task path, balance_hmbird() should
+		 * have already populated the local DSQ if there are any other
+		 * available tasks. If empty, tell ops.enqueue() that @p is the
+		 * only one available for this cpu. ops.enqueue() should put it
+		 * on the local DSQ so that the subsequent pick_next_task_hmbird()
+		 * can find the task unless it wants to trigger a separate
+		 * follow-up scheduling event.
+		 */
+		if (list_empty(&get_hmbird_rq(rq)->local_dsq.fifo))
+			do_enqueue_task(rq, p, HMBIRD_ENQ_LAST | HMBIRD_ENQ_LOCAL, -1);
+		else
+			do_enqueue_task(rq, p, 0, -1);
+	}
+}
+
+static struct task_struct *first_local_task(struct rq *rq)
+{
+	struct rb_node *rb_node;
+	struct hmbird_entity *entity;
+
+	if (!list_empty(&get_hmbird_rq(rq)->local_dsq.fifo)) {
+		entity = list_first_entry(&get_hmbird_rq(rq)->local_dsq.fifo,
+							struct hmbird_entity, dsq_node.fifo);
+		return entity->task;
+	}
+
+	rb_node = rb_first_cached(&get_hmbird_rq(rq)->local_dsq.priq);
+	if (rb_node) {
+		entity = container_of(rb_node, struct hmbird_entity, dsq_node.priq);
+		return entity->task;
+	}
+	return NULL;
+}
+
+static struct task_struct *pick_next_task_hmbird(struct rq *rq)
+{
+	struct task_struct *p;
+
+	p = first_local_task(rq);
+	if (!p)
+		return NULL;
+
+	if (unlikely(!get_hmbird_ts(p)->slice)) {
+		if (!hmbird_ops_disabling() && !hmbird_warned_zero_slice)
+			hmbird_warned_zero_slice = true;
+
+		refill_task_slice(p);
+	}
+
+	set_next_task_hmbird(rq, p, true);
+
+	return p;
+}
+
+void __hmbird_notify_pick_next_task(struct rq *rq, struct task_struct *task,
+				const struct sched_class *active)
+{
+	lockdep_assert_rq_held(rq);
+
+	/*
+	 * The callback is conceptually meant to convey that the CPU is no
+	 * longer under the control of HMBIRD. Therefore, don't invoke the
+	 * callback if the CPU is staying on HMBIRD, or going idle (in which
+	 * case the HMBIRD scheduler has actively decided not to schedule any
+	 * tasks on the CPU).
+	 */
+	if (likely(active >= &hmbird_sched_class))
+		return;
+
+	/*
+	 * At this point we know that HMBIRD was preempted by a higher priority
+	 * sched_class, so invoke the ->cpu_release() callback if we have not
+	 * done so already. We only send the callback once between HMBIRD being
+	 * preempted, and it regaining control of the CPU.
+	 *
+	 * ->cpu_release() complements ->cpu_acquire(), which is emitted the
+	 *  next time that balance_hmbird() is invoked.
+	 */
+	if (!get_hmbird_rq(rq)->cpu_released)
+		get_hmbird_rq(rq)->cpu_released = true;
+}
+
+#ifdef CONFIG_SMP
+
+static bool test_and_clear_cpu_idle(int cpu)
+{
+	if (cpumask_test_and_clear_cpu(cpu, idle_masks.cpu)) {
+		if (cpumask_empty(idle_masks.cpu))
+			hmbird_has_idle_cpus = false;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static s32 hmbird_pick_idle_cpu(const struct cpumask *cpus_allowed)
+{
+	int cpu;
+
+	do {
+		cpu = cpumask_any_and_distribute(idle_masks.cpu, cpus_allowed);
+		if (cpu >= nr_cpu_ids)
+			return -EBUSY;
+	} while (!test_and_clear_cpu_idle(cpu));
+
+	return cpu;
+}
+
+
+static bool prev_cpu_misfit(int prev)
+{
+	if (!is_partial_enabled() && is_partial_cpu(prev))
+		return true;
+
+	return false;
+}
+
+static int heavy_rt_placement(struct task_struct *p, int prev)
+{
+	struct cpumask tmp = {.bits = {0}};
+	int cpu;
+	u64 util = 0;
+
+	if (!rt_prio(p->prio))
+		return -EFAULT;
+
+	if (slim_walt_ctrl)
+		slim_get_task_util(p, &util);
+	else
+		util = get_hmbird_ts(p)->demand_scaled;
+
+	if (util < misfit_ds)
+		return -EFAULT;
+
+	if (is_partial_enabled())
+		cpumask_or(&tmp, iso_masks.big, iso_masks.partial);
+	else
+		cpumask_copy(&tmp, iso_masks.big);
+
+	cpu = hmbird_pick_idle_cpu(&tmp);
+	if (cpu >= 0)
+		return cpu;
+
+	if (cpumask_test_cpu(prev, iso_masks.big) ||
+		(is_partial_enabled() && is_partial_cpu(prev)))
+		return prev;
+
+	return cpumask_first(&tmp);
+}
+
+static int spec_task_before_pick_idle(struct task_struct *p, int prev)
+{
+	int cpu;
+
+	cpu = heavy_rt_placement(p, prev);
+	if (cpu >= 0)
+		return cpu;
+	return -EFAULT;
+}
+
+static int cpumask_distribute_next(struct cpumask *mask, int *prev)
+{
+	int p = *prev, n;
+
+	n = find_next_bit_wrap(cpumask_bits(mask), nr_cpumask_bits, p + 1);
+	if (n < nr_cpu_ids)
+		WRITE_ONCE(*prev, n);
+	return n;
+}
+
+static int repick_fallback_cpu(void)
+{
+	/*
+	 * partial cpu follow big cluster's Scheduling policy,
+	 * simply return first bit cpu.
+	 */
+	return cpumask_distribute_next(iso_masks.big, &big_distribute_mask_prev);
+}
+
+/*
+ * Must return a valid cpu num, as this task's cpu.
+ */
+static int select_cpu_from_cluster(struct task_struct *p, int prev_cpu,
+					struct cpumask *mask, int *prev_mask)
+{
+	int cpu;
+
+	cpu = hmbird_pick_idle_cpu(mask);
+	if (cpu >= 0)
+		return cpu;
+	return cpumask_distribute_next(mask, prev_mask);
+}
+
+static bool task_only_blongs_to_cluster(struct task_struct *p, enum cpu_type type)
+{
+	int idx;
+	struct cluster_ctx ctx;
+
+	idx = find_idx_from_task(p);
+	if (idx < NON_PERIOD_START || idx >= MAX_GLOBAL_DSQS)
+		return false;
+
+	gen_cluster_ctx(&ctx, type);
+	if (idx >= ctx.lower && idx < ctx.upper)
+		return true;
+	return false;
+}
+
+static bool is_valid_cpu(int cpu)
+{
+	return (cpu >= 0) && (cpu < nr_cpu_ids);
+}
+
+static s32 hmbird_select_cpu_dfl(struct task_struct *p, s32 prev_cpu, u64 wake_flags)
+{
+	s32 cpu = -1;
+	struct cpumask mask = {.bits = {0}};
+
+	cpu = get_hmbird_ts(p)->critical_affinity_cpu;
+	if (is_valid_cpu(cpu)) {
+		set_bit(ffs(HMBIRD_TASK_ENQ_LOCAL), (unsigned long *)&get_hmbird_ts(p)->flags);
+		slim_stats_record(SELECT_CPU, 0, 0, 0);
+		return cpu;
+	}
+
+	partial_dynamic_ctrl();
+
+	if (is_critical_app_task_without_isolate(p) && !cpumask_empty(iso_masks.big)) {
+		cpu = select_cpu_from_cluster(p, prev_cpu,
+				iso_masks.big, &big_distribute_mask_prev);
+		slim_stats_record(SELECT_CPU, 0, 0, 0);
+		if (is_valid_cpu(cpu))
+			return cpu;
+	}
+
+	if (p->nr_cpus_allowed == 1) {
+		cpu = cpumask_any(p->cpus_ptr);
+		slim_stats_record(SELECT_CPU, 0, 0, 0);
+		return cpu;
+	}
+
+	/* For non-period global dsq, not contain pcp task. */
+	if (task_only_blongs_to_cluster(p, LITTLE)) {
+		cpumask_copy(&mask, iso_masks.little);
+		if (unlikely(l_need_rescue))
+			cpumask_or(&mask, iso_masks.partial, &mask);
+		if (!cpumask_empty(&mask)) {
+			cpu = select_cpu_from_cluster(p, prev_cpu,
+					&mask, &little_distribute_mask_prev);
+			slim_stats_record(SELECT_CPU, 1, 0, 0);
+			if (is_valid_cpu(cpu))
+				return cpu;
+		}
+	}
+
+	if (task_only_blongs_to_cluster(p, BIG)) {
+		cpumask_copy(&mask, iso_masks.big);
+		if (unlikely(b_need_rescue))
+			cpumask_or(&mask, iso_masks.partial, &mask);
+		if (!cpumask_empty(&mask)) {
+			cpu = select_cpu_from_cluster(p, prev_cpu,
+					&mask, &big_distribute_mask_prev);
+			slim_stats_record(SELECT_CPU, 1, 0, 0);
+			if (is_valid_cpu(cpu))
+				return cpu;
+		}
+	}
+
+	cpu = spec_task_before_pick_idle(p, prev_cpu);
+	if (is_valid_cpu(cpu)) {
+		slim_stats_record(SELECT_CPU, 0, 0, 0);
+		return cpu;
+	}
+
+	/* if the previous CPU is idle, dispatch directly to it */
+	if (test_and_clear_cpu_idle(prev_cpu) || is_valid_cpu(prev_cpu)) {
+		slim_stats_record(SELECT_CPU, 0, 0, 0);
+		return prev_cpu;
+	}
+
+	cpu = hmbird_pick_idle_cpu(cpu_possible_mask);
+	if (is_valid_cpu(prev_cpu)) {
+		slim_stats_record(SELECT_CPU, 0, 0, 0);
+		return cpu;
+	}
+
+	if (prev_cpu_misfit(prev_cpu)) {
+		slim_stats_record(SELECT_CPU, 0, 0, 0);
+		cpu = repick_fallback_cpu();
+		if (is_valid_cpu(cpu))
+			return cpu;
+	}
+
+	slim_stats_record(SELECT_CPU, 0, 0, 0);
+	return prev_cpu;
+}
+
+static int select_task_rq_hmbird(struct task_struct *p, int prev_cpu, int wake_flags)
+{
+	return hmbird_select_cpu_dfl(p, prev_cpu, wake_flags);
+}
+
+static void set_cpus_allowed_hmbird(struct task_struct *p, struct affinity_context *ctx)
+{
+	set_cpus_allowed_common(p, ctx);
+}
+
+static void reset_idle_masks(void)
+{
+	cpumask_or(idle_masks.cpu, idle_masks.cpu, iso_masks.little);
+	cpumask_or(idle_masks.cpu, idle_masks.cpu, iso_masks.big);
+	if (is_partial_enabled())
+		cpumask_or(idle_masks.cpu, idle_masks.cpu, iso_masks.partial);
+	hmbird_has_idle_cpus = true;
+}
+
+void __hmbird_update_idle(struct rq *rq, bool idle)
+{
+	int cpu = cpu_of(rq);
+	struct cpumask *sib_mask = topology_sibling_cpumask(cpu);
+
+	if (skip_update_idle())
+		return;
+
+	if (idle) {
+		cpumask_set_cpu(cpu, idle_masks.cpu);
+		if (!hmbird_has_idle_cpus)
+			hmbird_has_idle_cpus = true;
+
+		/*
+		 * idle_masks.smt handling is racy but that's fine as it's only
+		 * for optimization and self-correcting.
+		 */
+		for_each_cpu(cpu, sib_mask) {
+			if (!cpumask_test_cpu(cpu, idle_masks.cpu))
+				return;
+		}
+		cpumask_or(idle_masks.smt, idle_masks.smt, sib_mask);
+	} else {
+		cpumask_clear_cpu(cpu, idle_masks.cpu);
+		if (hmbird_has_idle_cpus && cpumask_empty(idle_masks.cpu))
+			hmbird_has_idle_cpus = false;
+
+		cpumask_andnot(idle_masks.smt, idle_masks.smt, sib_mask);
+	}
+}
+
+#else /* !CONFIG_SMP */
+
+static bool test_and_clear_cpu_idle(int cpu) { return false; }
+static s32 hmbird_pick_idle_cpu(const struct cpumask *cpus_allowed) { return -EBUSY; }
+static void reset_idle_masks(void) {}
+
+#endif /* CONFIG_SMP */
+
+static bool check_rq_for_timeouts(struct rq *rq)
+{
+	struct hmbird_entity *entity;
+	struct task_struct *p;
+	struct rq_flags rf;
+
+	rq_lock_irqsave(rq, &rf);
+	list_for_each_entry(entity, &get_hmbird_rq(rq)->watchdog_list, watchdog_node) {
+		unsigned long last_runnable;
+
+		p = entity->task;
+		last_runnable = get_hmbird_ts(p)->runnable_at;
+
+		if (unlikely(time_after(jiffies,
+				last_runnable + hmbird_watchdog_timeout)) || watchdog_enable) {
+			u32 dur_ms = jiffies_to_msecs(jiffies - last_runnable);
+
+			rq_unlock_irqrestore(rq, &rf);
+			WRITE_ONCE(sw_type, HMBIRD_SWITCH_ERR_WDT);
+			HMBIRD_FATAL_INFO_FN(HMBIRD_EXIT_ERROR_STALL,
+					"%-12s[%d] failed to run for %u.%03us, dsq=%llu, mask=%*pb",
+					p->comm, p->pid,
+					dur_ms / 1000, dur_ms % 1000,
+					get_hmbird_ts(p)->dsq ? get_hmbird_ts(p)->dsq->id : 0,
+					cpumask_pr_args(&p->cpus_mask));
+			return 1;
+		}
+	}
+	rq_unlock_irqrestore(rq, &rf);
+	return 0;
+}
+
+static void hmbird_watchdog_workfn(struct work_struct *work)
+{
+	int cpu;
+	bool timeout;
+
+	hmbird_watchdog_timestamp = jiffies;
+
+	for_each_online_cpu(cpu) {
+		timeout = check_rq_for_timeouts(cpu_rq(cpu));
+		if (unlikely(timeout))
+			break;
+
+		cond_resched();
+	}
+	if (!timeout)
+		queue_delayed_work(system_unbound_wq, to_delayed_work(work),
+						hmbird_watchdog_timeout / 2);
+}
+
+static void set_pcp_round(struct rq *rq)
+{
+	int cpu = cpu_of(rq);
+
+	if (atomic64_read(&pcp_dsq_round) != per_cpu(pcp_info, cpu).pcp_seq) {
+		per_cpu(pcp_info, cpu).pcp_seq = atomic64_read(&pcp_dsq_round);
+		per_cpu(pcp_info, cpu).pcp_round = true;
+		hmbird_info_systrace("C|9999|pcp_%d_round|%d\n", cpu, true);
+		per_cpu(pcp_info, cpu).rtime = 0;
+		systrace_output_rtime_state(&per_cpu(pcp_ldsq, cpu),
+						per_cpu(pcp_info, cpu).rtime);
+	}
+}
+
+
+/*
+ * Just for debug: output hmbird on/off state per 10s.
+ */
+#define OUTPUT_INTVAL	(msecs_to_jiffies(10 * 1000))
+static void inform_hmbird_onoff_from_systrace(void)
+{
+	static unsigned long __read_mostly next_print;
+
+	if (time_before(jiffies, READ_ONCE(next_print)))
+		return;
+
+	WRITE_ONCE(next_print, jiffies + OUTPUT_INTVAL);
+	hmbird_output_systrace("C|9999|hmbird_status|%d\n", curr_ss);
+	hmbird_output_systrace("C|9999|parctrl_high_ratio_l|%d\n", parctrl_high_ratio_l);
+	hmbird_output_systrace("C|9999|parctrl_low_ratio_l|%d\n", parctrl_low_ratio_l);
+	hmbird_output_systrace("C|9999|parctrl_high_ratio|%d\n", parctrl_high_ratio);
+	hmbird_output_systrace("C|9999|parctrl_low_ratio|%d\n", parctrl_low_ratio);
+}
+
+void hmbird_notify_sched_tick(void)
+{
+	unsigned long last_check;
+	int cpu = smp_processor_id();
+	struct rq *rq = cpu_rq(cpu);
+
+	hmbird_scheduler_tick();
+
+	if (!hmbird_enabled())
+		return;
+
+	last_check = hmbird_watchdog_timestamp;
+	if (unlikely(time_after(jiffies, last_check + hmbird_watchdog_timeout))) {
+		u32 dur_ms = jiffies_to_msecs(jiffies - last_check);
+
+		HMBIRD_FATAL_INFO_FN(HMBIRD_EXIT_ERROR_STALL,
+				"watchdog failed to check in for %u.%03us",
+				dur_ms / 1000, dur_ms % 1000);
+	}
+	scan_timeout(rq);
+}
+
+static void task_tick_hmbird(struct rq *rq, struct task_struct *curr, int queued)
+{
+	update_curr_hmbird(rq);
+
+	set_pcp_round(rq);
+
+	if (slim_walt_ctrl)
+		hmbird_update_task_ravg_rqclock_wrapper(curr, rq, TASK_UPDATE);
+	/*
+	 * While disabling, always resched and refresh core-sched timestamp as
+	 * we can't trust the slice management or ops.core_sched_before().
+	 */
+	if (hmbird_ops_disabling())
+		get_hmbird_ts(curr)->slice = 0;
+
+	if (!get_hmbird_ts(curr)->slice)
+		resched_curr(rq);
+
+	inform_hmbird_onoff_from_systrace();
+}
+
+static int hmbird_ops_prepare_task(struct task_struct *p, struct task_group *tg)
+{
+	hmbird_cond_deferred_err(TASK_OPS_PREPPED, test_bit(ffs(HMBIRD_TASK_OPS_PREPPED),
+				(unsigned long *)&get_hmbird_ts(p)->flags), "task = %s\n", p->comm);
+
+	get_hmbird_ts(p)->disallow = false;
+
+	hmbird_sched_init_task(p);
+
+	set_bit(ffs(HMBIRD_TASK_OPS_PREPPED), (unsigned long *)&get_hmbird_ts(p)->flags);
+	set_bit(ffs(HMBIRD_TASK_WATCHDOG_RESET), (unsigned long *)&get_hmbird_ts(p)->flags);
+	return 0;
+}
+
+static void hmbird_ops_enable_task(struct task_struct *p)
+{
+	lockdep_assert_rq_held(task_rq(p));
+	hmbird_cond_deferred_err(TASK_OPS_UNPREPPED, !test_bit(ffs(HMBIRD_TASK_OPS_PREPPED),
+				(unsigned long *)&get_hmbird_ts(p)->flags), "task = %s\n", p->comm);
+
+	clear_bit(ffs(HMBIRD_TASK_OPS_PREPPED), (unsigned long *)&get_hmbird_ts(p)->flags);
+	set_bit(ffs(HMBIRD_TASK_OPS_ENABLED), (unsigned long *)&get_hmbird_ts(p)->flags);
+}
+
+static void hmbird_ops_disable_task(struct task_struct *p)
+{
+	lockdep_assert_rq_held(task_rq(p));
+
+	if (test_bit(ffs(HMBIRD_TASK_OPS_PREPPED), (unsigned long *)&get_hmbird_ts(p)->flags))
+		clear_bit(ffs(HMBIRD_TASK_OPS_PREPPED), (unsigned long *)&get_hmbird_ts(p)->flags);
+	else if (test_bit(ffs(HMBIRD_TASK_OPS_ENABLED), (unsigned long *)&get_hmbird_ts(p)->flags))
+		clear_bit(ffs(HMBIRD_TASK_OPS_ENABLED), (unsigned long *)&get_hmbird_ts(p)->flags);
+}
+
+static void set_task_hmbird_weight(struct task_struct *p)
+{
+	u32 weight = sched_prio_to_weight[p->static_prio - MAX_RT_PRIO];
+
+	get_hmbird_ts(p)->weight = hmbird_sched_weight_to_cgroup(weight);
+}
+
+/**
+ * refresh_hmbird_weight - Refresh a task's hmbird weight
+ * @p: task to refresh hmbird weight for
+ *
+ * @get_hmbird_ts(p)->weight carries the task's static priority in cgroup weight scale to
+ * enable easy access from the BPF scheduler. To keep it synchronized with the
+ * current task priority, this function should be called when a new task is
+ * created, priority is changed for a task on hmbird, and a task is switched
+ * to hmbird from other classes.
+ */
+static void refresh_hmbird_weight(struct task_struct *p)
+{
+	lockdep_assert_rq_held(task_rq(p));
+	set_task_hmbird_weight(p);
+}
+
+int hmbird_pre_fork(struct task_struct *p)
+{
+	int ret = 0;
+
+	p->android_oem_data1[HMBIRD_TS_IDX] =
+		(u64)(kmalloc(sizeof(struct hmbird_entity), GFP_KERNEL));
+	if (!get_hmbird_ts(p)) {
+		ret = -1;
+		goto lock;
+	}
+
+	get_hmbird_ts(p)->dsq              = NULL;
+	INIT_LIST_HEAD(&get_hmbird_ts(p)->dsq_node.fifo);
+	RB_CLEAR_NODE(&get_hmbird_ts(p)->dsq_node.priq);
+	INIT_LIST_HEAD(&get_hmbird_ts(p)->watchdog_node);
+	get_hmbird_ts(p)->flags            = 0;
+	get_hmbird_ts(p)->weight           = 0;
+	get_hmbird_ts(p)->sticky_cpu       = -1;
+	get_hmbird_ts(p)->holding_cpu      = -1;
+	get_hmbird_ts(p)->kf_mask          = 0;
+	atomic64_set(&get_hmbird_ts(p)->ops_state, 0);
+	get_hmbird_ts(p)->runnable_at      = INITIAL_JIFFIES;
+	get_hmbird_ts(p)->slice            = HMBIRD_SLICE_DFL;
+	get_hmbird_ts(p)->task             = p;
+	hmbird_set_sched_prop(p, 0);
+
+	get_hmbird_ts(p)->critical_affinity_cpu = -1;
+	get_hmbird_ts(p)->sched_class      = &hmbird_sched_class;
+
+	/*
+	 * BPF scheduler enable/disable paths want to be able to iterate and
+	 * update all tasks which can become complex when racing forks. As
+	 * enable/disable are very cold paths, let's use a percpu_rwsem to
+	 * exclude forks.
+	 */
+lock:
+	percpu_down_read(&hmbird_fork_rwsem);
+
+	return ret;
+}
+
+int hmbird_fork(struct task_struct *p)
+{
+	percpu_rwsem_assert_held(&hmbird_fork_rwsem);
+
+	if (hmbird_enabled())
+		return hmbird_ops_prepare_task(p, task_group(p));
+	else
+		return 0;
+}
+
+void hmbird_post_fork(struct task_struct *p)
+{
+	if (hmbird_enabled()) {
+		struct rq_flags rf;
+		struct rq *rq;
+
+		rq = task_rq_lock(p, &rf);
+		/*
+		 * Set the weight manually before calling ops.enable() so that
+		 * the scheduler doesn't see a stale value if they inspect the
+		 * task struct. We'll invoke ops.set_weight() afterwards, as it
+		 * would be odd to receive a callback on the task before we
+		 * tell the scheduler that it's been fully enabled.
+		 */
+		set_task_hmbird_weight(p);
+		hmbird_ops_enable_task(p);
+		refresh_hmbird_weight(p);
+		task_rq_unlock(rq, p, &rf);
+	}
+
+	spin_lock_irq(&hmbird_tasks_lock);
+	list_add_tail(&get_hmbird_ts(p)->tasks_node, &hmbird_tasks);
+	spin_unlock_irq(&hmbird_tasks_lock);
+
+	percpu_up_read(&hmbird_fork_rwsem);
+}
+
+void hmbird_cancel_fork(struct task_struct *p)
+{
+	struct hmbird_entity *see = get_hmbird_ts(p);
+
+	if (hmbird_enabled())
+		hmbird_ops_disable_task(p);
+
+	kfree(get_hmbird_ts(p));
+	see = NULL;
+
+	percpu_up_read(&hmbird_fork_rwsem);
+}
+
+void hmbird_free(struct task_struct *p)
+{
+	unsigned long flags;
+	struct hmbird_entity *see = get_hmbird_ts(p);
+
+	spin_lock_irqsave(&hmbird_tasks_lock, flags);
+	list_del_init(&get_hmbird_ts(p)->tasks_node);
+	spin_unlock_irqrestore(&hmbird_tasks_lock, flags);
+
+	/*
+	 * @p is off hmbird_tasks and wholly ours. hmbird_ops_enable()'s PREPPED ->
+	 * ENABLED transitions can't race us. Disable ops for @p.
+	 */
+	if (test_bit(ffs(HMBIRD_TASK_OPS_PREPPED), (unsigned long *)&get_hmbird_ts(p)->flags) ||
+		test_bit(ffs(HMBIRD_TASK_OPS_ENABLED), (unsigned long *)&get_hmbird_ts(p)->flags)) {
+		struct rq_flags rf;
+		struct rq *rq;
+
+		rq = task_rq_lock(p, &rf);
+		hmbird_ops_disable_task(p);
+		task_rq_unlock(rq, p, &rf);
+	}
+	kfree(get_hmbird_ts(p));
+	see = NULL;
+}
+
+static void prio_changed_hmbird(struct rq *rq, struct task_struct *p, int oldprio)
+{
+}
+
+static inline bool task_specific_type(uint32_t prop, enum hmbird_task_prop_type type)
+{
+	return (prop >> TOP_TASK_SHIFT) & (1 << type);
+}
+
+static inline enum hmbird_task_prop_type hmbird_get_task_type(struct task_struct *p)
+{
+	uint32_t prop = get_top_task_prop(p);
+
+	if (task_specific_type(prop, HMBIRD_TASK_PROP_TRANSIENT_AND_CRITICAL))
+		return HMBIRD_TASK_PROP_TRANSIENT_AND_CRITICAL;
+	if (task_specific_type(prop, HMBIRD_TASK_PROP_PERIODIC_AND_CRITICAL))
+		return HMBIRD_TASK_PROP_PERIODIC_AND_CRITICAL;
+	if (task_specific_type(prop, HMBIRD_TASK_PROP_PIPELINE))
+		return HMBIRD_TASK_PROP_PIPELINE;
+	if (task_specific_type(prop, HMBIRD_TASK_PROP_COMMON) ||
+			!task_specific_type(prop, HMBIRD_TASK_PROP_DEBUG_OR_LOG)) {
+		return HMBIRD_TASK_PROP_COMMON;
+	}
+	return HMBIRD_TASK_PROP_DEBUG_OR_LOG;
+}
+
+static inline bool hmbird_prio_higher(struct task_struct *a, struct task_struct *b)
+{
+	int type_a = hmbird_get_task_type(a);
+	int type_b = hmbird_get_task_type(b);
+
+	return sched_prop_to_preempt_prio[type_a] > sched_prop_to_preempt_prio[type_b];
+}
+
+static void check_preempt_curr_hmbird(struct rq *rq, struct task_struct *p, int wake_flags)
+{
+	enum cpu_type type;
+	int sp_dl;
+	struct task_struct *curr = NULL;
+
+	switch (hmbird_preempt_policy) {
+	case HMBIRD_PREEMPT_POLICY_PRIO_BASED:
+		curr = rq->curr;
+		if (curr && hmbird_prio_higher(p, curr))
+			goto preempt;
+		break;
+	default:
+		break;
+	}
+	if ((is_pipeline_task(p) && !is_pipeline_task(rq->curr)) ||
+		(is_critical_system_task(p) && !is_critical_system_task(rq->curr)))
+		goto preempt;
+
+	sp_dl = find_idx_from_task(p);
+	if (sp_dl >= SCHED_PROP_DEADLINE_LEVEL1)
+		return;
+
+	type = cpu_cluster(cpu_of(rq));
+	if (type == EXCLUSIVE || ((type == PARTIAL) && !is_partial_enabled()))
+		return;
+
+	if (rq->curr->prio > p->prio)
+		goto preempt;
+
+	return;
+
+preempt:
+	resched_curr(rq);
+}
+
+static void switched_to_hmbird(struct rq *rq, struct task_struct *p) {}
+
+int hmbird_check_setscheduler(struct task_struct *p, int policy)
+{
+	lockdep_assert_rq_held(task_rq(p));
+
+	/* if disallow, reject transitioning into HMBIRD */
+	if (hmbird_enabled() && READ_ONCE(get_hmbird_ts(p)->disallow) &&
+			p->policy != policy && policy == SCHED_HMBIRD)
+		return -EACCES;
+
+	return 0;
+}
+
+#ifdef CONFIG_NO_HZ_FULL
+bool hmbird_can_stop_tick(struct rq *rq)
+{
+	struct task_struct *p = rq->curr;
+
+	if (hmbird_ops_disabling())
+		return false;
+
+	if (p->sched_class != &hmbird_sched_class)
+		return true;
+
+	return get_hmbird_rq(rq)->flags & HMBIRD_RQ_CAN_STOP_TICK;
+}
+#endif
+
+int hmbird_tg_online(struct task_group *tg)
+{
+	struct cgroup *cgrp;
+
+	if (!tg)
+		return 0;
+	cgrp = tg->css.cgroup;
+	if (!cgrp || !(cgrp->kn))
+		return 0;
+	update_cgroup_ids_table(cgrp->kn->id, -1);
+	return 0;
+}
+
+/*
+ * Omitted operations:
+ *
+ * - check_preempt_curr: NOOP as it isn't useful in the wakeup path because the
+ *   task isn't tied to the CPU at that point. Preemption is implemented by
+ *   resetting the victim task's slice to 0 and triggering reschedule on the
+ *   target CPU.
+ *
+ * - migrate_task_rq: Unncessary as task to cpu mapping is transient.
+ *
+ * - task_fork/dead: We need fork/dead notifications for all tasks regardless of
+ *   their current sched_class. Call them directly from sched core instead.
+ *
+ * - task_woken, switched_from: Unnecessary.
+ */
+DEFINE_SCHED_CLASS(hmbird) = {
+	.enqueue_task		= enqueue_task_hmbird,
+	.dequeue_task		= dequeue_task_hmbird,
+	.yield_task		= yield_task_hmbird,
+	.yield_to_task		= yield_to_task_hmbird,
+
+	.check_preempt_curr	= check_preempt_curr_hmbird,
+
+	.pick_next_task		= pick_next_task_hmbird,
+
+	.put_prev_task		= put_prev_task_hmbird,
+	.set_next_task		= set_next_task_hmbird,
+
+#ifdef CONFIG_SMP
+	.balance		= balance_hmbird,
+	.select_task_rq		= select_task_rq_hmbird,
+	.set_cpus_allowed	= set_cpus_allowed_hmbird,
+#endif
+	.task_tick		= task_tick_hmbird,
+
+	.switched_to		= switched_to_hmbird,
+	.prio_changed		= prio_changed_hmbird,
+
+	.update_curr		= update_curr_hmbird,
+
+#ifdef CONFIG_UCLAMP_TASK
+	.uclamp_enabled		= 0,
+#endif
+};
+
+/*
+ * Must with rq lock held.
+ */
+bool task_is_hmbird(struct task_struct *p)
+{
+	return p->sched_class == &hmbird_sched_class;
+}
+
+
+void init_dsq(struct hmbird_dispatch_q *dsq, u64 dsq_id)
+{
+	memset(dsq, 0, sizeof(*dsq));
+
+	raw_spin_lock_init(&dsq->lock);
+	INIT_LIST_HEAD(&dsq->fifo);
+	dsq->id = dsq_id;
+}
+
+static int hmbird_cgroup_init(void)
+{
+	struct cgroup_subsys_state *css;
+
+	css_for_each_descendant_pre(css, &root_task_group.css) {
+		struct task_group *tg = css_tg(css);
+
+		cgrp_dsq_idx_init(css->cgroup, tg);
+	}
+	return 0;
+}
+
+/*
+ * Used by sched_fork() and __setscheduler_prio() to pick the matching
+ * sched_class. dl/rt are already handled.
+ */
+bool task_on_hmbird(struct task_struct *p)
+{
+	return hmbird_enabled();
+}
+
+static void __setscheduler_prio(struct task_struct *p, int prio)
+{
+	bool on_hmbird = task_on_hmbird(p);
+
+	if (p->sched_class == &stop_sched_class) {
+		p->prio = prio;
+		return;
+	} else if (dl_prio(prio))
+		p->sched_class = &dl_sched_class;
+	else if (on_hmbird && rt_prio(prio))
+		p->sched_class = &hmbird_sched_class;
+	else if (rt_prio(prio))
+		p->sched_class = &rt_sched_class;
+	else if (on_hmbird)
+		p->sched_class = &hmbird_sched_class;
+	else
+		p->sched_class = &fair_sched_class;
+
+	p->prio = prio;
+}
+
+/*
+ * Heartbeat, avoid humbird keep running while APP already exit.
+ * Check whether APP send alive-signal periodly.
+ */
+#define HEARTBEAT_TIMEOUT		(msecs_to_jiffies(2500))
+#define HEARTBEAT_CHECK_INTERVAL	(msecs_to_jiffies(1000))
+static struct timer_list hb_timer;
+static unsigned long next_hb;
+
+void hb_timer_handler(struct timer_list *timer)
+{
+	if (!heartbeat_enable)
+		goto refill;
+
+	pr_err("<hmbird_sched>: enter timer.\n");
+	if (heartbeat) {
+		heartbeat = 0;
+		WRITE_ONCE(next_hb, jiffies + HEARTBEAT_TIMEOUT);
+	}
+
+	/* can't detect heartbeat, disable ext. */
+	if (time_after(jiffies, READ_ONCE(next_hb))) {
+		WRITE_ONCE(sw_type, HMBIRD_SWITCH_ERR_HB);
+		HMBIRD_FATAL_INFO_FN(HMBIRD_EXIT_ERROR_HEARTBEAT,
+					"can't detect heartbeat, disable ext\n");
+	}
+refill:
+	mod_timer(&hb_timer, jiffies + HEARTBEAT_CHECK_INTERVAL);
+}
+
+static void hb_timer_start(void)
+{
+	mod_timer(&hb_timer, jiffies + HEARTBEAT_CHECK_INTERVAL);
+}
+
+static void hb_timer_init(void)
+{
+	timer_setup(&hb_timer, hb_timer_handler, 0);
+}
+
+static void hb_timer_exit(void)
+{
+	del_timer(&hb_timer);
+}
+
+static bool check_and_disable_cpuhp(void)
+{
+	struct rq *rq;
+	struct rq_flags rf;
+	int cpu;
+
+	cpu_hotplug_disable();
+	cpus_read_lock();
+	for_each_possible_cpu(cpu) {
+		rq = cpu_rq(cpu);
+		rq_lock_irqsave(rq, &rf);
+		if (!rq->online) {
+			rq_unlock_irqrestore(rq, &rf);
+			goto err_offline;
+		}
+		rq_unlock_irqrestore(rq, &rf);
+	}
+	cpus_read_unlock();
+	return true;
+
+err_offline:
+	cpus_read_unlock();
+	cpu_hotplug_enable();
+	return false;
+}
+
+static void reenable_cpuhp(void)
+{
+	cpu_hotplug_enable();
+}
+
+static void scheduler_switch_done(bool final_state)
+{
+	/* set scx_enable again, switch may fail. */
+	scx_enable = final_state;
+	/* reset heartbeat*/
+	WRITE_ONCE(next_hb, jiffies + HEARTBEAT_TIMEOUT);
+
+	if (final_state)
+		hb_timer_start();
+	else
+		hb_timer_exit();
+}
+
+/**
+ * ss : curr switch state
+ * finish : success or fail
+ * enable : curr operation is diabling or enabling?
+ * fail_reason : string output when failed, empty string when success.
+ */
+static void hmbird_switch_log(enum switch_stat ss, bool finish, bool enable, char *fail_reason)
+{
+	char *s1 = finish ? "finished" : "failed";
+	char *s2 = enable ? "enabled" : "disabled";
+
+	hmbird_internal_systrace("C|9999|hmbird_status|%d\n", ss);
+	if (ss == HMBIRD_DISABLED || ss == HMBIRD_ENABLED) {
+		sw_update(md_info, jiffies, finish, ss, READ_ONCE(sw_type));
+		hmbird_debug("hmbird %s %s at jiffies = %lu, clock = %lu, reason = %s\n",
+				s2, s1, jiffies, (unsigned long)sched_clock(), fail_reason);
+	}
+	curr_ss = ss;
+}
+
+bool get_hmbird_ops_enabled(void)
+{
+	return atomic_read(&__hmbird_ops_enabled);
+}
+
+bool get_non_hmbird_task(void)
+{
+	return atomic_read(&non_hmbird_task);
+}
+
+static void hmbird_ops_disable_workfn(struct kthread_work *work)
+{
+	struct hmbird_task_iter sti;
+	struct task_struct *p;
+	int cpu;
+
+	hmbird_switch_log(HMBIRD_SWITCH_PREP, 0, 0, "");
+	cancel_delayed_work_sync(&hmbird_watchdog_work);
+
+	mutex_lock(&hmbird_ops_enable_mutex);
+	switch (hmbird_ops_set_enable_state(HMBIRD_OPS_DISABLING)) {
+	case HMBIRD_OPS_DISABLED:
+		WARN_ON_ONCE(hmbird_ops_set_enable_state(HMBIRD_OPS_DISABLED) !=
+					HMBIRD_OPS_DISABLING);
+		hmbird_switch_log(HMBIRD_DISABLED, 0, 0, "already disabled");
+		scheduler_switch_done(false);
+		mutex_unlock(&hmbird_ops_enable_mutex);
+		return;
+	case HMBIRD_OPS_PREPPING:
+		fallthrough;
+	case HMBIRD_OPS_DISABLING:
+		/* shouldn't happen but handle it like ENABLING if it does */
+		WARN_ONCE(true, "hmbird: duplicate disabling instance?");
+		fallthrough;
+	case HMBIRD_OPS_ENABLING:
+	case HMBIRD_OPS_ENABLED:
+		break;
+	}
+
+	/* kick all CPUs to restore ticks */
+	for_each_possible_cpu(cpu)
+		resched_cpu(cpu);
+
+	/* avoid racing against fork and cgroup changes */
+	cpus_read_lock();
+	percpu_down_write(&hmbird_fork_rwsem);
+
+	hmbird_switch_log(HMBIRD_RQ_SWITCH_BEGIN, 0, 0, "");
+	spin_lock_irq(&hmbird_tasks_lock);
+	atomic_set(&__hmbird_ops_enabled, false);
+	hmbird_task_iter_init(&sti);
+	while ((p = hmbird_task_iter_next_filtered_locked(&sti))) {
+		const struct sched_class *old_class = p->sched_class;
+		struct rq *rq = task_rq(p);
+		bool alive = READ_ONCE(p->__state) != TASK_DEAD;
+
+		update_rq_clock(rq);
+
+		SCHED_CHANGE_BLOCK(rq, p, DEQUEUE_SAVE | DEQUEUE_MOVE |
+					DEQUEUE_NOCLOCK) {
+			get_hmbird_ts(p)->slice = min_t(u64,
+					get_hmbird_ts(p)->slice, HMBIRD_SLICE_DFL);
+
+			__setscheduler_prio(p, p->prio);
+		}
+
+		if (alive)
+			check_class_changed(task_rq(p), p, old_class, p->prio);
+
+		hmbird_ops_disable_task(p);
+	}
+	hmbird_task_iter_exit(&sti);
+	spin_unlock_irq(&hmbird_tasks_lock);
+	hmbird_switch_log(HMBIRD_RQ_SWITCH_DONE, 0, 0, "");
+
+	atomic_set(&non_hmbird_task, true);
+	/* no task is on hmbird, turn off all the switches and flush in-progress calls */
+	static_branch_disable_cpuslocked(&hmbird_ops_cpu_preempt);
+	synchronize_rcu();
+
+	percpu_up_write(&hmbird_fork_rwsem);
+	cpus_read_unlock();
+
+	if (slim_walt_ctrl)
+		slim_walt_enable(false);
+
+	mutex_unlock(&hmbird_ops_enable_mutex);
+
+	WARN_ON_ONCE(hmbird_ops_set_enable_state(HMBIRD_OPS_DISABLED) !=
+			HMBIRD_OPS_DISABLING);
+	hmbird_switch_log(HMBIRD_DISABLED, 1, 0, "");
+	scheduler_switch_done(false);
+	reenable_cpuhp();
+}
+
+static DEFINE_KTHREAD_WORK(hmbird_ops_disable_work, hmbird_ops_disable_workfn);
+
+static void schedule_hmbird_ops_disable_work(void)
+{
+	struct kthread_worker *helper = READ_ONCE(hmbird_ops_helper);
+
+	/*
+	 * We may be called spuriously before the first bpf_hmbird_reg(). If
+	 * hmbird_ops_helper isn't set up yet, there's nothing to do.
+	 */
+	if (helper)
+		kthread_queue_work(helper, &hmbird_ops_disable_work);
+}
+
+static void hmbird_ops_disable(void)
+{
+	schedule_hmbird_ops_disable_work();
+}
+
+static void hmbird_err_exit_workfn(struct work_struct *work)
+{
+	int cpu;
+	struct cpufreq_policy *policy;
+
+	hmbird_ctrl(false);
+
+	for_each_present_cpu(cpu) {
+		policy = cpufreq_cpu_get(cpu);
+		if (!policy)
+			continue;
+		if (cpu != policy->cpu)
+			goto put;
+		down_write(&policy->rwsem);
+		WARN_ON(store_scaling_governor(policy,
+				saved_gov[cpu], strlen(saved_gov[cpu])) <= 0);
+		up_write(&policy->rwsem);
+		hmbird_info_trace("<heartbeat>:restore origin gov : %s\n", saved_gov[cpu]);
+put:
+		cpufreq_cpu_put(policy);
+	}
+	memset((char *)saved_gov, 0, sizeof(saved_gov));
+}
+
+void hmbird_ops_exit(void)
+{
+	queue_work(system_unbound_wq, &hmbird_err_exit_work);
+}
+
+static struct kthread_worker *hmbird_create_rt_helper(const char *name)
+{
+	struct kthread_worker *helper;
+
+	helper = kthread_create_worker(0, name);
+	if (helper)
+		sched_set_fifo(helper->task);
+	return helper;
+}
+
+static inline void set_audio_thread_sched_prop(struct task_struct *p)
+{
+	struct cgroup_subsys_state *css;
+
+	if (likely(p->prio >= MAX_RT_PRIO))
+		return;
+
+	rcu_read_lock();
+	css = task_css(p, cpuset_cgrp_id);
+	if (!css) {
+		rcu_read_unlock();
+		return;
+	}
+	rcu_read_unlock();
+
+	if (!strcmp(css->cgroup->kn->name, "audio-app"))
+		hmbird_set_sched_prop(p, SCHED_PROP_DEADLINE_LEVEL1);
+}
+
+static int hmbird_ops_enable(void *unused)
+{
+	struct hmbird_task_iter sti;
+	struct task_struct *p;
+	int ret;
+	int tcnt = 0;
+	unsigned long long start = 0;
+
+	if (!check_and_disable_cpuhp()) {
+		hmbird_switch_log(HMBIRD_DISABLED, 0, 1, "cpu offline");
+		return -EBUSY;
+	}
+	hmbird_switch_log(HMBIRD_SWITCH_PREP, 0, 1, "");
+	mutex_lock(&hmbird_ops_enable_mutex);
+
+	if (!hmbird_ops_helper) {
+		WRITE_ONCE(hmbird_ops_helper,
+				hmbird_create_rt_helper("hmbird_ops_helper"));
+		if (!hmbird_ops_helper) {
+			ret = -ENOMEM;
+			goto err_unlock;
+		}
+	}
+
+	if (hmbird_ops_enable_state() != HMBIRD_OPS_DISABLED) {
+		ret = -EBUSY;
+		goto err_unlock;
+	}
+
+	WARN_ON_ONCE(hmbird_ops_set_enable_state(HMBIRD_OPS_PREPPING) !=
+				HMBIRD_OPS_DISABLED);
+
+	hmbird_warned_zero_slice = false;
+
+	atomic64_set(&hmbird_nr_rejected, 0);
+
+	/*
+	 * Keep CPUs stable during enable so that the BPF scheduler can track
+	 * online CPUs by watching ->on/offline_cpu() after ->init().
+	 */
+	cpus_read_lock();
+
+	hmbird_watchdog_timeout = HMBIRD_WATCHDOG_MAX_TIMEOUT;
+
+	hmbird_watchdog_timestamp = jiffies;
+	queue_delayed_work(system_unbound_wq, &hmbird_watchdog_work,
+				hmbird_watchdog_timeout / 2);
+
+	/*
+	 * Lock out forks, cgroup on/offlining and moves before opening the
+	 * floodgate so that they don't wander into the operations prematurely.
+	 */
+	percpu_down_write(&hmbird_fork_rwsem);
+
+	reset_idle_masks();
+
+	/*
+	 * All cgroups should be initialized before letting in tasks. cgroup
+	 * on/offlining and task migrations are already locked out.
+	 */
+	ret = hmbird_cgroup_init();
+	if (ret)
+		goto err_disable_unlock;
+
+	/*
+	 * Enable ops for every task. Fork is excluded by hmbird_fork_rwsem
+	 * preventing new tasks from being added. No need to exclude tasks
+	 * leaving as hmbird_free() can handle both prepped and enabled
+	 * tasks. Prep all tasks first and then enable them with preemption
+	 * disabled.
+	 */
+	spin_lock_irq(&hmbird_tasks_lock);
+
+	atomic_set(&non_hmbird_task, false);
+	atomic_set(&__hmbird_ops_enabled, true);
+
+	hmbird_task_iter_init(&sti);
+	while ((p = hmbird_task_iter_next_filtered(&sti)))
+		hmbird_ops_prepare_task(p, task_group(p));
+
+	hmbird_task_iter_exit(&sti);
+
+	/*
+	 * All tasks are prepped but are still ops-disabled. Ensure that
+	 * %current can't be scheduled out and switch everyone.
+	 * preempt_disable() is necessary because we can't guarantee that
+	 * %current won't be starved if scheduled out while switching.
+	 */
+	preempt_disable();
+
+	/*
+	 * From here on, the disable path must assume that tasks have ops
+	 * enabled and need to be recovered.
+	 */
+	if (!hmbird_ops_tryset_enable_state(HMBIRD_OPS_ENABLING, HMBIRD_OPS_PREPPING)) {
+		atomic_set(&non_hmbird_task, true);
+		atomic_set(&__hmbird_ops_enabled, false);
+		preempt_enable();
+		spin_unlock_irq(&hmbird_tasks_lock);
+		ret = -EBUSY;
+		goto err_disable_unlock;
+	}
+
+	/*
+	 * We're fully committed and can't fail. The PREPPED -> ENABLED
+	 * transitions here are synchronized against hmbird_free() through
+	 * hmbird_tasks_lock.
+	 */
+	start = sched_clock();
+	hmbird_switch_log(HMBIRD_RQ_SWITCH_BEGIN, 0, 1, "");
+	hmbird_task_iter_init(&sti);
+	while ((p = hmbird_task_iter_next_filtered_locked(&sti))) {
+		tcnt++;
+		if (READ_ONCE(p->__state) != TASK_DEAD) {
+			const struct sched_class *old_class = p->sched_class;
+			struct rq *rq = task_rq(p);
+
+			set_audio_thread_sched_prop(p);
+			update_rq_clock(rq);
+
+			SCHED_CHANGE_BLOCK(rq, p, DEQUEUE_SAVE | DEQUEUE_MOVE |
+						DEQUEUE_NOCLOCK) {
+				hmbird_ops_enable_task(p);
+				__setscheduler_prio(p, p->prio);
+			}
+
+			check_class_changed(task_rq(p), p, old_class, p->prio);
+		} else {
+			hmbird_ops_disable_task(p);
+		}
+	}
+	hmbird_task_iter_exit(&sti);
+
+	spin_unlock_irq(&hmbird_tasks_lock);
+	hmbird_switch_log(HMBIRD_RQ_SWITCH_DONE, 0, 1, "");
+	preempt_enable();
+	percpu_up_write(&hmbird_fork_rwsem);
+
+	if (!hmbird_ops_tryset_enable_state(HMBIRD_OPS_ENABLED, HMBIRD_OPS_ENABLING)) {
+		ret = -EBUSY;
+		goto err_disable;
+	}
+
+	cpus_read_unlock();
+	mutex_unlock(&hmbird_ops_enable_mutex);
+	hmbird_switch_log(HMBIRD_ENABLED, 1, 1, "");
+	scheduler_switch_done(true);
+
+	return 0;
+
+err_unlock:
+	mutex_unlock(&hmbird_ops_enable_mutex);
+	hmbird_switch_log(HMBIRD_DISABLED, 0, 1, "err_unlock");
+	scheduler_switch_done(false);
+	return ret;
+
+err_disable_unlock:
+	percpu_up_write(&hmbird_fork_rwsem);
+err_disable:
+	cpus_read_unlock();
+	mutex_unlock(&hmbird_ops_enable_mutex);
+	/* must be fully disabled before returning */
+	hmbird_ops_disable();
+	kthread_flush_work(&hmbird_ops_disable_work);
+	hmbird_switch_log(HMBIRD_DISABLED, 0, 1, "err_disable");
+	scheduler_switch_done(false);
+	return ret;
+}
+
+#ifdef CONFIG_SCHED_DEBUG
+static const char *hmbird_ops_enable_state_str[] = {
+	[HMBIRD_OPS_PREPPING]	= "prepping",
+	[HMBIRD_OPS_ENABLING]	= "enabling",
+	[HMBIRD_OPS_ENABLED]	= "enabled",
+	[HMBIRD_OPS_DISABLING]	= "disabling",
+	[HMBIRD_OPS_DISABLED]	= "disabled",
+};
+
+static int hmbird_debug_show(struct seq_file *m, void *v)
+{
+	mutex_lock(&hmbird_ops_enable_mutex);
+	seq_printf(m, "%-30s: %d\n", "enabled", hmbird_enabled());
+	seq_printf(m, "%-30s: %s\n", "enable_state",
+			hmbird_ops_enable_state_str[hmbird_ops_enable_state()]);
+	seq_printf(m, "%-30s: %llu\n", "nr_rejected",
+			atomic64_read(&hmbird_nr_rejected));
+	mutex_unlock(&hmbird_ops_enable_mutex);
+	return 0;
+}
+
+static int hmbird_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, hmbird_debug_show, NULL);
+}
+
+const struct file_operations sched_hmbird_fops = {
+	.open		= hmbird_debug_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+#endif
+
+
+static int bpf_hmbird_reg(void *kdata)
+{
+	return hmbird_ops_enable(kdata);
+}
+
+static int bpf_hmbird_unreg(void *kdata)
+{
+	hmbird_ops_disable();
+	kthread_flush_work(&hmbird_ops_disable_work);
+	return 0;
+}
+
+void set_hmbird_module_loaded(int is_loaded)
+{
+	atomic_set(&hmbird_module_loaded, is_loaded);
+}
+
+/*
+ * MUST load hmbird module before enable hmbird scheduler
+ * load track & hmbird gover implemented in hmbird module
+ */
+int hmbird_ctrl(bool enable)
+{
+	if (!atomic_read(&hmbird_module_loaded)) {
+		hmbird_switch_log(hmbird_enabled() ? HMBIRD_ENABLED : HMBIRD_DISABLED,
+					0, enable, "ext module unloaded\n");
+		return -EINVAL;
+	}
+
+	if (enable && (hmbird_ops_enable_state() == HMBIRD_OPS_ENABLED
+			|| hmbird_ops_enable_state() == HMBIRD_OPS_ENABLING
+			|| hmbird_ops_enable_state() == HMBIRD_OPS_PREPPING)) {
+		/* Executing or completed, no need to repeat. */
+		hmbird_switch_log(hmbird_enabled() ? HMBIRD_ENABLED : HMBIRD_DISABLED,
+					0, enable, "already enabled(ing)\n");
+		hmbird_err(ALREADY_ENABLED, "ext already in enable state, exit!\n");
+		return -EBUSY;
+	}
+	if (!enable && (hmbird_ops_enable_state() == HMBIRD_OPS_DISABLING ||
+			hmbird_ops_enable_state() == HMBIRD_OPS_DISABLED)) {
+		/* Executing or completed, no need to repeat. */
+		hmbird_switch_log(hmbird_enabled() ? HMBIRD_ENABLED : HMBIRD_DISABLED,
+					0, enable, "already disabled(ing)\n");
+		hmbird_err(ALREADY_DISABLED, "ext already in disable state, exit!\n");
+		return -EBUSY;
+	}
+	if (enable)
+		return bpf_hmbird_reg(NULL);
+	else
+		return bpf_hmbird_unreg(NULL);
+}
+
+void set_cpu_isomask(int cpu, cpumask_var_t *mask)
+{
+	cpumask_clear_cpu(cpu, iso_masks.ex_free);
+	cpumask_clear_cpu(cpu, iso_masks.exclusive);
+	cpumask_clear_cpu(cpu, iso_masks.partial);
+	cpumask_clear_cpu(cpu, iso_masks.big);
+	cpumask_clear_cpu(cpu, iso_masks.little);
+	cpumask_set_cpu(cpu, *mask);
+}
+
+void set_cpu_cluster(u64 cpu_cluster)
+{
+	int cpu;
+
+	for_each_present_cpu(cpu) {
+		u64 pos = 1 << cpu;
+
+		if ((pos & cpu_cluster) != 0) {
+			set_cpu_isomask(cpu, &(iso_masks.ex_free));
+			continue;
+		} else
+			pos = pos << 8;
+		if ((pos & cpu_cluster) != 0) {
+			set_cpu_isomask(cpu, &(iso_masks.exclusive));
+			continue;
+		} else
+			pos = pos << 8;
+		if ((pos & cpu_cluster) != 0) {
+			set_cpu_isomask(cpu, &(iso_masks.partial));
+			continue;
+		} else
+			pos = pos << 8;
+		if ((pos & cpu_cluster) != 0) {
+			set_cpu_isomask(cpu, &(iso_masks.big));
+			continue;
+		} else
+			pos = pos << 8;
+		if ((pos & cpu_cluster) != 0)
+			set_cpu_isomask(cpu, &(iso_masks.little));
+	}
+}
+
+static void get_hmbird_snapshot(struct panic_snapshot_t *p)
+{
+	struct hmbird_dispatch_q *dsq;
+	struct rq *rq;
+	int cpu, i;
+
+	for_each_possible_cpu(cpu) {
+		rq = cpu_rq(cpu);
+		p->rq_nr[cpu] = rq->nr_running;
+		p->scxrq_nr[cpu] = get_hmbird_rq(rq)->nr_running;
+	}
+
+	for (i = 0; i < MAX_GLOBAL_DSQS; i++) {
+		struct hmbird_entity *entity;
+
+		dsq = &gdsqs[i];
+		raw_spin_lock(&dsq->lock);
+		if (list_empty(&dsq->fifo)) {
+			raw_spin_unlock(&dsq->lock);
+			continue;
+		}
+
+		entity = list_first_entry(&dsq->fifo, struct hmbird_entity, dsq_node.fifo);
+		if (!entity) {
+			raw_spin_unlock(&dsq->lock);
+			continue;
+		}
+		p->runnable_at[i] = entity->runnable_at;
+		raw_spin_unlock(&dsq->lock);
+
+	}
+
+	p->snap_misc.hmbird_enabled = hmbird_enabled();
+	p->snap_misc.curr_ss = curr_ss;
+	p->snap_misc.hmbird_ops_enable_state_var = (u64)hmbird_ops_enable_state();
+	p->snap_misc.parctrl_high_ratio = parctrl_high_ratio;
+	p->snap_misc.parctrl_low_ratio = parctrl_low_ratio;
+	p->snap_misc.parctrl_high_ratio_l = parctrl_high_ratio_l;
+	p->snap_misc.parctrl_low_ratio_l = parctrl_low_ratio_l;
+	p->snap_misc.isoctrl_high_ratio = isoctrl_high_ratio;
+	p->snap_misc.isoctrl_low_ratio = isoctrl_low_ratio;
+	p->snap_misc.misfit_ds = misfit_ds;
+	p->snap_misc.partial_enable = partial_enable;
+	p->snap_misc.iso_free_rescue = iso_free_rescue;
+	p->snap_misc.isolate_ctrl = isolate_ctrl;
+	p->snap_misc.snap_jiffies = jiffies;
+	p->snap_misc.snap_time = local_clock();
+}
+
+// MTK minidump begin
+static void init_desc_meta(struct meta_desc_t *m, char *str, u64 d1, u64 d2, u64 d3)
+{
+	strscpy(m->desc_str, str, DESC_STR_LEN);
+	m->len = d1 * d2 * d3;
+	m->parse[0] = d1;
+	m->parse[1] = d2;
+	m->parse[2] = d3;
+}
+
+static void init_desc_metas(struct md_info_t *m)
+{
+	init_desc_meta(&m->kern_dump.sw_rec_meta, "switch record :",
+			1, MAX_SWITCHS, SWITCH_ITEMS);
+
+	init_desc_meta(&m->kern_dump.sw_idx_meta, "switch idx :", 1, 1, 1);
+
+	init_desc_meta(&m->kern_dump.excep_rec_meta,
+			"excep record :", 1, MAX_EXCEP_ID, MAX_EXCEPS);
+
+	init_desc_meta(&m->kern_dump.excep_idx_meta,
+			"excep idx :", 1, 1, MAX_EXCEP_ID);
+
+	init_desc_meta(&m->kern_dump.snap.runnable_at_meta,
+			"each dsq runnable at :", 1, 1, MAX_GLOBAL_DSQS);
+
+	init_desc_meta(&m->kern_dump.snap.rq_nr_meta,
+			"rq runnable task nr:", 1, 1, num_possible_cpus());
+
+	init_desc_meta(&m->kern_dump.snap.scxrq_nr_meta,
+			"scxrq runnable task nr :", 1, 1, num_possible_cpus());
+
+	init_desc_meta(&m->kern_dump.snap.snap_misc_meta,
+			"misc snap params :", 1, 1, SNAP_ITEMS);
+}
+
+static void init_md_meta(struct md_info_t *m)
+{
+	m->meta.desc_meta_len = sizeof(struct meta_desc_t) / sizeof(u64);
+	m->meta.desc_str_len = DESC_STR_LEN / sizeof(u64);
+	m->meta.unit_size = sizeof(u64);
+	m->meta.switches = MAX_SWITCHS;
+	m->meta.exceps = MAX_EXCEPS;
+	m->meta.global_dsqs = MAX_GLOBAL_DSQS;
+	m->meta.parse_dimens = PARSE_DIMENS;
+	m->meta.nr_cpus = num_possible_cpus();
+	m->meta.real_cpus = nr_cpu_ids;
+	m->meta.self_len = sizeof(struct md_meta_t) / sizeof(u64);
+	m->meta.nr_meta_desc = 8;
+	m->meta.dump_real_size = sizeof(struct md_info_t) / sizeof(u64);
+
+	init_desc_metas(m);
+}
+
+#define MINIDUMP_DFL_SIZE	(4 * 1024)
+
+struct notifier_block hmbird_panic_blk;
+static int hmbird_panic_handler(struct notifier_block *this,
+					unsigned long event, void *ptr)
+{
+	if (!md_info)
+		return NOTIFY_DONE;
+
+	get_hmbird_snapshot(&md_info->kern_dump.snap);
+
+	return NOTIFY_DONE;
+}
+
+static void panic_blk_init(void)
+{
+	int dump_size = max_t(u32, sizeof(struct md_info_t), MINIDUMP_DFL_SIZE);
+
+	md_info = kzalloc(dump_size, GFP_KERNEL);
+	if (!md_info)
+		return;
+	init_md_meta(md_info);
+
+	hmbird_panic_blk.notifier_call = hmbird_panic_handler;
+	/* make sure to execute before minidump. */
+	hmbird_panic_blk.priority = INT_MAX;
+	atomic_notifier_chain_register(&panic_notifier_list, &hmbird_panic_blk);
+
+	hmbird_debug("register minidump.\n");
+}
+
+void hmbird_get_md_info(unsigned long *vaddr, unsigned long *size)
+{
+	*vaddr = (unsigned long)md_info;
+	*size = sizeof(struct md_info_t);
+}
+// MTK minidump end
+
+static inline void init_sched_prop_to_preempt_prio(void)
+{
+	for (int i = 0; i < HMBIRD_TASK_PROP_MAX; i++) {
+		switch (i) {
+		case HMBIRD_TASK_PROP_TRANSIENT_AND_CRITICAL:
+			sched_prop_to_preempt_prio[i] = 5;
+			break;
+
+		case HMBIRD_TASK_PROP_PERIODIC_AND_CRITICAL:
+			sched_prop_to_preempt_prio[i] = 4;
+			break;
+
+		case HMBIRD_TASK_PROP_PIPELINE:
+		case HMBIRD_TASK_PROP_ISOLATE:
+			sched_prop_to_preempt_prio[i] = 3;
+			break;
+
+		case HMBIRD_TASK_PROP_COMMON:
+			sched_prop_to_preempt_prio[i] = 1;
+			break;
+
+		case HMBIRD_TASK_PROP_DEBUG_OR_LOG:
+			sched_prop_to_preempt_prio[i] = 0;
+			break;
+
+		default:
+			sched_prop_to_preempt_prio[i] = 2;
+			break;
+		}
+	}
+}
+
+void __init init_sched_hmbird_class(void)
+{
+	int cpu;
+	u32 v;
+	struct hmbird_entity *init_hmbird;
+
+	/*
+	 * The following is to prevent the compiler from optimizing out the enum
+	 * definitions so that BPF scheduler implementations can use them
+	 * through the generated vmlinux.h.
+	 */
+	WRITE_ONCE(v, HMBIRD_WAKE_EXEC | HMBIRD_ENQ_WAKEUP | HMBIRD_DEQ_SLEEP |
+			HMBIRD_KICK_PREEMPT);
+
+	init_dsq(&hmbird_dsq_global, HMBIRD_DSQ_GLOBAL);
+	init_dsq_at_boot();
+	init_isolate_cpus();
+	hb_timer_init();
+	init_sched_prop_to_preempt_prio();
+#ifdef CONFIG_SMP
+	WARN_ON(!alloc_cpumask_var(&idle_masks.cpu, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&idle_masks.smt, GFP_KERNEL));
+#endif
+
+	/*
+	 * we can't static init init_task's hmbird struct, init here.
+	 * init_task->hmbird would not use during boot.
+	 */
+	init_hmbird = kmalloc(sizeof(struct hmbird_entity), GFP_KERNEL);
+	init_task.android_oem_data1[HMBIRD_TS_IDX] = (u64)init_hmbird;
+	if (init_hmbird) {
+		INIT_LIST_HEAD(&init_hmbird->dsq_node.fifo);
+		INIT_LIST_HEAD(&init_hmbird->watchdog_node);
+		init_hmbird->sticky_cpu = -1;
+		init_hmbird->holding_cpu = -1;
+		atomic64_set(&init_hmbird->ops_state, 0);
+		init_hmbird->runnable_at = jiffies;
+		init_hmbird->slice = HMBIRD_SLICE_DFL;
+		init_hmbird->task = &init_task;
+		hmbird_set_sched_prop(&init_task, 0);
+	} else {
+		hmbird_err(INIT_TASK_FAIL, "<fatal>:alloc init_task.scx failed!!!\n");
+	}
+
+	for_each_possible_cpu(cpu) {
+		struct rq *rq = cpu_rq(cpu);
+
+		/*
+		 * exec during boot phase, no need to care about alloc failed.
+		 * lifecycle same to rq, no need to free.
+		 */
+		rq->android_oem_data1[HMBIRD_RQ_IDX] =
+			(u64)kmalloc(sizeof(struct hmbird_rq), GFP_KERNEL);
+		if (get_hmbird_rq(rq)) {
+			get_hmbird_rq(rq)->rq = rq;
+			get_hmbird_rq(rq)->srq = &per_cpu(hmbird_sched_rq_stats, cpu);
+			get_hmbird_rq(rq)->srq->sched_ravg_window_ptr = &hmbird_sched_ravg_window;
+		} else {
+			hmbird_err(ALLOC_RQSCX_FAIL, "<fatal>:alloc rq->scx failed!!!\n");
+		}
+
+		rq->android_oem_data1[HMBIRD_OPS_IDX] =
+				(u64)kzalloc(sizeof(struct hmbird_ops), GFP_KERNEL);
+		if (!get_hmbird_ops(rq))
+			pr_err("fatal error : alloc get_hmbird_ops(rq) failed!!!\n");
+		init_dsq(&get_hmbird_rq(rq)->local_dsq, HMBIRD_DSQ_LOCAL);
+		INIT_LIST_HEAD(&get_hmbird_rq(rq)->watchdog_list);
+
+		WARN_ON(!zalloc_cpumask_var(&get_hmbird_rq(rq)->cpus_to_kick, GFP_KERNEL));
+		WARN_ON(!zalloc_cpumask_var(&get_hmbird_rq(rq)->cpus_to_preempt, GFP_KERNEL));
+		WARN_ON(!zalloc_cpumask_var(&get_hmbird_rq(rq)->cpus_to_wait, GFP_KERNEL));
+
+		hmbird_ops_init(get_hmbird_ops(rq));
+	}
+
+	INIT_DELAYED_WORK(&hmbird_watchdog_work, hmbird_watchdog_workfn);
+	INIT_WORK(&hmbird_err_exit_work, hmbird_err_exit_workfn);
+	hmbird_misc_init();
+
+	panic_blk_init();
+}
+
diff --git a/kernel/sched/hmbird/hmbird_misc.c b/kernel/sched/hmbird/hmbird_misc.c
new file mode 100755
index 000000000000..52582c22052c
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_misc.c
@@ -0,0 +1,124 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/*
+ * @Description:
+ * @Version:
+ * @Author: wangrui8
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+
+#include <linux/kprobes.h>
+#include "hmbird_sched.h"
+#include <linux/sched/hmbird.h>
+#include <linux/kernel.h>
+#include "slim.h"
+
+noinline int tracing_mark_write(const char *buf)
+{
+	trace_printk(buf);
+	return 0;
+}
+
+struct yield_opt_params yield_opt_params = {
+	.enable = 0,
+	.frame_per_sec = 120,
+	.frame_time_ns = NSEC_PER_SEC / 120,
+	.yield_headroom = 10,
+};
+
+DEFINE_PER_CPU(struct sched_yield_state, ystate);
+
+static inline void hmbird_yield_state_update(struct sched_yield_state *ys)
+{
+	if (!raw_spin_is_locked(&ys->lock))
+		return;
+	int yield_headroom = yield_opt_params.yield_headroom;
+
+	if (ys->yield_cnt >= DEFAULT_YIELD_SLEEP_TH || ys->sleep_times > 1
+						|| ys->yield_cnt_after_sleep > yield_headroom) {
+		ys->sleep = min(ys->sleep + yield_headroom * YIELD_DURATION, MAX_YIELD_SLEEP);
+	} else if (!ys->yield_cnt && (ys->sleep_times == 1) && !ys->yield_cnt_after_sleep) {
+		ys->sleep = max(ys->sleep - yield_headroom * YIELD_DURATION, MIN_YIELD_SLEEP);
+	}
+	ys->yield_cnt = 0;
+	ys->sleep_times = 0;
+	ys->yield_cnt_after_sleep = 0;
+}
+
+void hmbird_skip_yield(long *skip)
+{
+	if (!get_hmbird_ops_enabled() || !yield_opt_params.enable)
+		return;
+	unsigned long flags, sleep_now = 0;
+	struct sched_yield_state *ys;
+	int cpu = raw_smp_processor_id(), cont_yield, new_frame;
+	int frame_time_ns = yield_opt_params.frame_time_ns;
+	int yield_headroom = yield_opt_params.yield_headroom;
+	u64 wc;
+
+	if (!(*skip)) {
+		wc = sched_clock();
+		ys = &per_cpu(ystate, cpu);
+		raw_spin_lock_irqsave(&ys->lock, flags);
+
+		cont_yield = (wc - ys->last_yield_time) < MIN_YIELD_SLEEP;
+		new_frame = (wc - ys->last_update_time) > (frame_time_ns >> 1);
+
+		if (!cont_yield && new_frame) {
+			hmbird_yield_state_update(ys);
+			ys->last_update_time = wc;
+			ys->sleep_end = ys->last_yield_time + frame_time_ns
+						- yield_headroom * YIELD_DURATION;
+		}
+
+		if (ys->sleep > MIN_YIELD_SLEEP || ys->yield_cnt >= DEFAULT_YIELD_SLEEP_TH) {
+			*skip = true;
+
+			sleep_now = ys->sleep_times ?
+				max(ys->sleep >> ys->sleep_times, MIN_YIELD_SLEEP):ys->sleep;
+			if (wc + sleep_now > ys->sleep_end) {
+				u64 delta = ys->sleep_end - wc;
+
+				if (ys->sleep_end > wc && delta > 3 * YIELD_DURATION)
+					sleep_now = delta;
+				else
+					sleep_now = 0;
+			}
+			raw_spin_unlock_irqrestore(&ys->lock, flags);
+			if (sleep_now) {
+				sleep_now = div64_u64(sleep_now, 1000);
+				usleep_range_state(sleep_now, sleep_now, TASK_IDLE);
+			}
+			ys->sleep_times++;
+			ys->last_yield_time = sched_clock();
+			return;
+		}
+		if (ys->sleep_times)
+			ys->yield_cnt_after_sleep++;
+		else
+			(ys->yield_cnt)++;
+		ys->last_yield_time = wc;
+		raw_spin_unlock_irqrestore(&ys->lock, flags);
+	}
+}
+
+void hmbird_ops_init(struct hmbird_ops *hmbird_ops)
+{
+	hmbird_ops->scx_enable = get_hmbird_ops_enabled;
+	hmbird_ops->check_non_task = get_non_hmbird_task;
+	hmbird_ops->hmbird_get_md_info = hmbird_get_md_info;
+}
+
+void hmbird_misc_init(void)
+{
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct sched_yield_state *ys = &per_cpu(ystate, cpu);
+
+		raw_spin_lock_init(&ys->lock);
+	}
+
+	set_hmbird_module_loaded(1);
+}
+
diff --git a/kernel/sched/hmbird/hmbird_sched.h b/kernel/sched/hmbird/hmbird_sched.h
new file mode 100755
index 000000000000..6b5ef43cb827
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_sched.h
@@ -0,0 +1,85 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+#ifndef __HMBIRD_SCHED__
+#define __HMBIRD_SCHED__
+
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/tick.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include <linux/irq_work.h>
+#include <linux/cpufreq.h>
+#include <linux/kthread.h>
+#include <linux/sched/clock.h>
+#include <uapi/linux/sched/types.h>
+#include "../../time/tick-sched.h"
+#include "../../sched/sched.h"
+#include <trace/hooks/sched.h>
+#include <linux/delay.h>
+#include <linux/sched/hmbird.h>
+
+#define REGISTER_TRACE_VH(vender_hook, handler) \
+{ \
+	ret = register_trace_##vender_hook(handler, NULL); \
+	if (ret) { \
+		pr_err("failed to register_trace_"#vender_hook", ret=%d\n", ret); \
+	} \
+}
+#define REGISTER_TRACE(vendor_hook, handler, data, err)	\
+do {								\
+	ret = register_trace_##vendor_hook(handler, data);				\
+	if (ret) {						\
+		pr_err("sched_ext:failed to register_trace_"#vendor_hook", ret=%d\n", ret);	\
+		goto err;					\
+	}							\
+} while (0)
+
+#define UNREGISTER_TRACE(vendor_hook, handler, data)	\
+	unregister_trace_##vendor_hook(handler, data)				\
+
+extern unsigned int highres_tick_ctrl;
+extern unsigned int highres_tick_ctrl_dbg;
+
+extern int slim_walt_ctrl;
+extern int slim_walt_dump;
+extern int slim_walt_policy;
+extern int sched_ravg_window_frame_per_sec;
+extern int slim_gov_debug;
+extern int cpu7_tl;
+extern int scx_gov_ctrl;
+extern spinlock_t new_sched_ravg_window_lock;
+extern int cluster_separate;
+
+#define HMBIRD_CPUFREQ_WINDOW_ROLLOVER	BIT(31)
+#define MAX_YIELD_SLEEP		(2000000ULL)
+#define MIN_YIELD_SLEEP		(200000ULL)
+#define YIELD_DURATION		(5000ULL)
+#define DEFAULT_YIELD_SLEEP_TH	(10)
+
+struct sched_yield_state {
+	raw_spinlock_t	lock;
+	u64				last_yield_time;
+	u64				last_update_time;
+	u64				sleep_end;
+	unsigned long	yield_cnt;
+	unsigned long	yield_cnt_after_sleep;
+	unsigned long	sleep;
+	int sleep_times;
+};
+
+DECLARE_PER_CPU(struct sched_yield_state, ystate);
+
+void hmbird_window_rollover_run_once(struct rq *rq);
+void hmbird_yield_state_update_per_frame(void);
+void hmbird_misc_init(void);
+
+void hmbird_ops_init(struct hmbird_ops *hmbird_ops);
+#endif /*__HMBIRD_SCHED__*/
diff --git a/kernel/sched/hmbird/hmbird_sched_proc.c b/kernel/sched/hmbird/hmbird_sched_proc.c
new file mode 100755
index 000000000000..234768fc767a
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_sched_proc.c
@@ -0,0 +1,527 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+#include "hmbird_sched_proc.h"
+#include <linux/sched/hmbird_version.h>
+
+#include "hmbird_util_track.h"
+#include "slim.h"
+
+#define HMBIRD_SCHED_PROC_DIR "hmbird_sched"
+#define SLIM_FREQ_GOV_DIR       "slim_freq_gov"
+#define LOAD_TRACK_DIR          "slim_walt"
+#define HMBIRD_PROC_PERMISSION  0666
+
+int scx_enable;
+int partial_enable;
+int cpuctrl_high_ratio = 55;
+int cpuctrl_low_ratio = 40;
+int slim_stats;
+int hmbirdcore_debug;
+int slim_for_app;
+int misfit_ds = 90;
+unsigned int highres_tick_ctrl;
+unsigned int highres_tick_ctrl_dbg;
+int cpu7_tl = 70;
+int slim_walt_ctrl;
+int slim_walt_dump;
+int slim_walt_policy;
+int slim_gov_debug;
+int scx_gov_ctrl = 1;
+int sched_ravg_window_frame_per_sec = 125;
+int parctrl_high_ratio = 55;
+int parctrl_low_ratio = 40;
+int parctrl_high_ratio_l = 65;
+int parctrl_low_ratio_l = 50;
+int isoctrl_high_ratio = 75;
+int isoctrl_low_ratio = 60;
+int isolate_ctrl;
+int iso_free_rescue;
+int heartbeat;
+int heartbeat_enable = 1;
+int watchdog_enable;
+int save_gov;
+u64 cpu_cluster_masks;
+int hmbird_preempt_policy;
+int cluster_separate;
+
+char saved_gov[NR_CPUS][MAX_GOV_LEN];
+
+static int set_proc_buf_val(struct file *file, const char __user *buf, size_t count, int *val)
+{
+	char kbuf[32] = {0};
+	int err;
+
+	if (count >= 32)
+		return -EFAULT;
+
+	if (copy_from_user(kbuf, buf, count)) {
+		pr_err("hmbird_sched : Failed to copy_from_user\n");
+		return -EFAULT;
+	}
+
+	err = kstrtoint(strstrip(kbuf), 0, val);
+	if (err < 0) {
+		pr_err("hmbird_sched: Failed to exec kstrtoint\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int set_proc_buf_val_u64(struct file *file, const char __user *buf,
+				size_t count, u64 *val)
+{
+	char kbuf[32] = {0};
+	int err;
+
+	if (count >= sizeof(kbuf))
+		return -EFAULT;
+
+	if (copy_from_user(kbuf, buf, count)) {
+		pr_err("hmbird_sched : Failed to copy_from_user\n");
+		return -EFAULT;
+	}
+
+	err = kstrtou64(strstrip(kbuf), 0, val);
+	if (err < 0) {
+		pr_err("hmbird_sched: Failed to exec kstrtoul\n");
+	return -EFAULT;
+	}
+
+	return 0;
+}
+
+/* common ops begin */
+static ssize_t hmbird_common_write(struct file *file,
+				   const char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	int *pval = (int *)pde_data(file_inode(file));
+
+	if (set_proc_buf_val(file, buf, count, pval))
+		return -EFAULT;
+
+	return count;
+}
+
+static int hmbird_common_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%d\n", *(int *) m->private);
+	return 0;
+}
+
+static int hmbird_common_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, hmbird_common_show, pde_data(inode));
+}
+
+static int hmbird_common_ul_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%lu\n", *(unsigned long *) m->private);
+	return 0;
+}
+
+static int hmbird_common_ul_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, hmbird_common_ul_show, pde_data(inode));
+}
+
+HMBIRD_PROC_OPS(hmbird_common, hmbird_common_open, hmbird_common_write);
+/* common ops end */
+
+/* scx_enable ops begin */
+static ssize_t scx_enable_proc_write(struct file *file, const char __user *buf,
+								size_t count, loff_t *ppos)
+{
+	int *pval = (int *)pde_data(file_inode(file));
+
+	if (set_proc_buf_val(file, buf, count, pval))
+		return -EFAULT;
+
+	WRITE_ONCE(sw_type, HMBIRD_SWITCH_PROC);
+	if (hmbird_ctrl(*pval))
+		return -EFAULT;
+
+	return count;
+}
+HMBIRD_PROC_OPS(scx_enable, hmbird_common_open, scx_enable_proc_write);
+/* scx_enable ops end */
+
+/* hmbird_stats ops begin */
+#define MAX_STATS_BUF	(4096)
+static int hmbird_stats_proc_show(struct seq_file *m, void *v)
+{
+	char *buf;
+
+	buf = kmalloc(MAX_STATS_BUF, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	stats_print(buf, MAX_STATS_BUF);
+
+	seq_printf(m, "%s\n", buf);
+
+	kfree(buf);
+	return 0;
+}
+
+static int hmbird_stats_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, hmbird_stats_proc_show, inode);
+}
+HMBIRD_PROC_OPS(hmbird_stats, hmbird_stats_proc_open, NULL);
+/* hmbird_stats ops end */
+
+/* sched_ravg_window_frame_per_sec ops begin */
+static ssize_t sched_ravg_window_frame_per_sec_proc_write(struct file *file,
+			const char __user *buf, size_t count, loff_t *ppos)
+{
+	int *pval = (int *)pde_data(file_inode(file));
+
+	if (set_proc_buf_val(file, buf, count, pval))
+		return -EFAULT;
+
+	sched_ravg_window_change(*pval);
+
+	return count;
+}
+HMBIRD_PROC_OPS(sched_ravg_window_frame_per_sec, hmbird_common_open,
+			sched_ravg_window_frame_per_sec_proc_write);
+/* sched_ravg_window_frame_per_sec ops end */
+
+static ssize_t save_gov_str(struct file *file, const char __user *buf,
+					size_t count, loff_t *ppos)
+{
+	int cpu;
+	struct cpufreq_policy *policy;
+
+	for_each_possible_cpu(cpu) {
+		policy = cpufreq_cpu_get(cpu);
+		if (!policy || (cpu != policy->cpu))
+			continue;
+		WARN_ON(show_scaling_governor(policy, saved_gov[cpu]) <= 0);
+		hmbird_info_systrace("<gov_restore>:save origin gov : %s\n", saved_gov[cpu]);
+	}
+	return count;
+}
+HMBIRD_PROC_OPS(save_gov, hmbird_common_open, save_gov_str);
+
+static ssize_t cpu_cluster_proc_write(struct file *file, const char __user *buf,
+							size_t count, loff_t *ppos)
+{
+	u64 *pval = (u64 *)pde_data(file_inode(file));
+
+	if (set_proc_buf_val_u64(file, buf, count, pval))
+		return -EFAULT;
+
+	if (scx_enable == 0)
+		set_cpu_cluster(*pval);
+
+	return count;
+}
+HMBIRD_PROC_OPS(cpu_cluster_masks, hmbird_common_ul_open, cpu_cluster_proc_write);
+
+static ssize_t slim_walt_ctrl_write(struct file *file, const char __user *buf,
+					size_t count, loff_t *ppos)
+{
+	int *pval = (int *)pde_data(file_inode(file));
+	int tmp_val;
+
+	if (set_proc_buf_val(file, buf, count, &tmp_val))
+		return -EFAULT;
+
+	slim_walt_enable(tmp_val);
+	*pval = tmp_val;
+
+	return count;
+}
+
+HMBIRD_PROC_OPS(slim_walt_ctrl, hmbird_common_open, slim_walt_ctrl_write);
+
+/* yield_opt ops begin */
+static int yield_opt_show(struct seq_file *m, void *v)
+{
+	struct yield_opt_params *data = m->private;
+
+	seq_printf(m, "yield_opt:{\"enable\":%d; \"frame_per_sec\":%d; \"headroom\":%d}\n",
+				data->enable, data->frame_per_sec, data->yield_headroom);
+	return 0;
+}
+
+static int yield_opt_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, yield_opt_show, pde_data(inode));
+}
+
+static ssize_t yield_opt_write(struct file *file, const char __user *buf,
+							size_t count, loff_t *ppos)
+{
+	char *data;
+	int enable_tmp, frame_per_sec_tmp, yield_headroom_tmp, cpu;
+	unsigned long flags;
+
+	data = kmalloc(count + 1, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	if (copy_from_user(data, buf, count)) {
+		kfree(data);
+		return -EFAULT;
+	}
+
+	data[count] = '\0';
+
+	if (sscanf(data, "%d %d %d", &enable_tmp, &frame_per_sec_tmp, &yield_headroom_tmp) != 3) {
+		kfree(data);
+		return -EINVAL;
+	}
+
+	if ((enable_tmp != 0 && enable_tmp != 1) || (frame_per_sec_tmp != 30 && frame_per_sec_tmp
+			!= 60 && frame_per_sec_tmp != 90 && frame_per_sec_tmp != 120) ||
+			(yield_headroom_tmp < 1 || yield_headroom_tmp > 20)) {
+		kfree(data);
+		return -EINVAL;
+	}
+
+	yield_opt_params.frame_time_ns = NSEC_PER_SEC / frame_per_sec_tmp;
+	yield_opt_params.frame_per_sec = frame_per_sec_tmp;
+	yield_opt_params.yield_headroom = yield_headroom_tmp;
+	yield_opt_params.enable = enable_tmp;
+
+	for_each_possible_cpu(cpu) {
+		struct sched_yield_state *ys = &per_cpu(ystate, cpu);
+
+		raw_spin_lock_irqsave(&ys->lock, flags);
+		ys->last_yield_time = 0;
+		ys->last_update_time = 0;
+		ys->sleep_end = 0;
+		ys->yield_cnt = 0;
+		ys->yield_cnt_after_sleep = 0;
+		ys->sleep = 0;
+		ys->sleep_times = 0;
+		raw_spin_unlock_irqrestore(&ys->lock, flags);
+	}
+
+	kfree(data);
+	return count;
+}
+
+HMBIRD_PROC_OPS(yield_opt, yield_opt_open, yield_opt_write);
+
+
+static int __init hmbird_proc_init(void)
+{
+	struct proc_dir_entry *hmbird_dir;
+	struct proc_dir_entry *load_track_dir;
+	struct proc_dir_entry *freq_gov_dir;
+
+	if (get_hmbird_version_type() != HMBIRD_OGKI_VERSION)
+		return 0;
+
+	/* mkdir /proc/hmbird_sched */
+	hmbird_dir = proc_mkdir(HMBIRD_SCHED_PROC_DIR, NULL);
+	if (!hmbird_dir) {
+		pr_err("Error creating proc directory %s\n", HMBIRD_SCHED_PROC_DIR);
+		return -ENOMEM;
+	}
+
+	/* /proc/hmbird_sched--begin */
+	HMBIRD_CREATE_PROC_ENTRY_DATA("scx_enable", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&scx_enable_proc_ops,
+					&scx_enable);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("partial_ctrl", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&partial_enable);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("cpuctrl_high", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&cpuctrl_high_ratio);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("cpuctrl_low", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&cpuctrl_low_ratio);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("slim_stats", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&slim_stats);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("hmbirdcore_debug", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&hmbirdcore_debug);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("slim_for_app", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&slim_for_app);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("misfit_ds", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&misfit_ds);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("scx_shadow_tick_enable", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&highres_tick_ctrl);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("highres_tick_ctrl_dbg", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&highres_tick_ctrl_dbg);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("cpu7_tl", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&cpu7_tl);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("cpu_cluster_masks", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&cpu_cluster_masks_proc_ops,
+					&cpu_cluster_masks);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("save_gov", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&save_gov_proc_ops,
+					&save_gov);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("heartbeat", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&heartbeat);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("heartbeat_enable", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&heartbeat_enable);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("watchdog_enable", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&watchdog_enable);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("isolate_ctrl", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&isolate_ctrl);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("parctrl_high_ratio", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&parctrl_high_ratio);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("parctrl_low_ratio", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&parctrl_low_ratio);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("isoctrl_high_ratio", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&isoctrl_high_ratio);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("isoctrl_low_ratio", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&isoctrl_low_ratio);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("iso_free_rescue", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&iso_free_rescue);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("parctrl_high_ratio_l", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&parctrl_high_ratio_l);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("parctrl_low_ratio_l", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&parctrl_low_ratio_l);
+
+	HMBIRD_CREATE_PROC_ENTRY("hmbird_stats", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_stats_proc_ops);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("yield_opt", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&yield_opt_proc_ops,
+					&yield_opt_params);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("hmbird_preempt_policy", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&hmbird_preempt_policy);
+	/* /proc/hmbird_sched--end */
+
+	/* mkdir /proc/hmbird_sched/slim_walt */
+	load_track_dir = proc_mkdir(LOAD_TRACK_DIR, hmbird_dir);
+	if (!load_track_dir) {
+		pr_err("Error creating proc directory %s\n", LOAD_TRACK_DIR);
+		return -ENOMEM;
+	}
+
+	/* /proc/hmbird_sched/slim_walt--begin */
+	HMBIRD_CREATE_PROC_ENTRY_DATA("slim_walt_ctrl", HMBIRD_PROC_PERMISSION,
+					load_track_dir,
+					&slim_walt_ctrl_proc_ops,
+					&slim_walt_ctrl);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("slim_walt_dump", HMBIRD_PROC_PERMISSION,
+					load_track_dir,
+					&hmbird_common_proc_ops,
+					&slim_walt_dump);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("slim_walt_policy", HMBIRD_PROC_PERMISSION,
+					load_track_dir,
+					&hmbird_common_proc_ops,
+					&slim_walt_policy);
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("frame_per_sec", HMBIRD_PROC_PERMISSION,
+					load_track_dir,
+					&sched_ravg_window_frame_per_sec_proc_ops,
+					&sched_ravg_window_frame_per_sec);
+	/* /proc/hmbird_sched/slim_walt--end */
+
+	/* mkdir /proc/hmbird_sched/slim_freq_gov */
+	freq_gov_dir = proc_mkdir(SLIM_FREQ_GOV_DIR, hmbird_dir);
+	if (!freq_gov_dir) {
+		pr_err("Error creating proc directory %s\n", SLIM_FREQ_GOV_DIR);
+		return -ENOMEM;
+	}
+
+	/* /proc/hmbird_sched/slim_freq_gov--begin */
+	HMBIRD_CREATE_PROC_ENTRY_DATA("slim_gov_debug", HMBIRD_PROC_PERMISSION,
+					freq_gov_dir,
+					&hmbird_common_proc_ops,
+					&slim_gov_debug);
+	HMBIRD_CREATE_PROC_ENTRY_DATA("scx_gov_ctrl", HMBIRD_PROC_PERMISSION,
+					freq_gov_dir,
+					&hmbird_common_proc_ops,
+					&scx_gov_ctrl);
+	/* /proc/hmbird_sched/slim_freq_gov--end */
+
+	HMBIRD_CREATE_PROC_ENTRY_DATA("cluster_separate", HMBIRD_PROC_PERMISSION,
+					hmbird_dir,
+					&hmbird_common_proc_ops,
+					&cluster_separate);
+
+	return 0;
+}
+
+device_initcall(hmbird_proc_init);
diff --git a/kernel/sched/hmbird/hmbird_sched_proc.h b/kernel/sched/hmbird/hmbird_sched_proc.h
new file mode 100755
index 000000000000..e22bc75f1dd7
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_sched_proc.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __HMBIRD_SCHED_PROC_H__
+#define __HMBIRD_SCHED_PROC_H__
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#define HMBIRD_CREATE_PROC_ENTRY(name, mode, parent, proc_ops) \
+	do { \
+		if (!proc_create(name, mode, parent, proc_ops)) { \
+			pr_err("Error creating proc entry %s\n", name); \
+			return -ENOMEM; \
+		} \
+	} while (0)
+
+#define HMBIRD_CREATE_PROC_ENTRY_DATA(name, mode, parent, proc_ops, data) \
+	do { \
+		if (!proc_create_data(name, mode, parent, proc_ops, data)) { \
+			pr_err("Error creating proc entry with data %s\n", name); \
+			return -ENOMEM; \
+		} \
+	} while (0)
+
+#define HMBIRD_PROC_OPS(name, open_func, write_func) \
+	static const struct proc_ops name##_proc_ops = { \
+		.proc_open = open_func, \
+		.proc_write = write_func, \
+		.proc_read = seq_read, \
+		.proc_lseek = seq_lseek, \
+		.proc_release = single_release, \
+	}
+
+static ssize_t hmbird_common_write(struct file *file,
+				   const char __user *buf,
+				   size_t count, loff_t *ppos);
+static int hmbird_common_show(struct seq_file *m, void *v);
+static int hmbird_common_open(struct inode *inode, struct file *file);
+
+#endif
diff --git a/kernel/sched/hmbird/hmbird_shadow_tick.c b/kernel/sched/hmbird/hmbird_shadow_tick.c
new file mode 100755
index 000000000000..21de551c5132
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_shadow_tick.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+#include <linux/tick.h>
+#include "../../time/tick-sched.h"
+#include <linux/sched/hmbird_version.h>
+
+#include "hmbird_shadow_tick.h"
+
+#define HIGHRES_WATCH_CPU       0
+
+#include <linux/sched/hmbird_proc_val.h>
+static bool shadow_tick_enable(void) {return highres_tick_ctrl; }
+#ifdef CONFIG_HMBIRD_DEBUG_MODE
+static bool shadow_tick_dbg_enable(void) {return highres_tick_ctrl_dbg; }
+#endif
+static bool shadow_tick_timer_init_flag;
+
+#ifdef CONFIG_HMBIRD_DEBUG_MODE
+#define shadow_tick_printk(fmt, args...)	\
+do {							\
+	int cpu = smp_processor_id();			\
+	if (shadow_tick_dbg_enable() && cpu == HIGHRES_WATCH_CPU)	\
+		trace_printk("hmbird shadow tick :"fmt, args);	\
+} while (0)
+#else
+#define shadow_tick_printk(fmt, args...)
+#endif
+
+DEFINE_PER_CPU(struct hrtimer, stt);
+#define shadow_tick_timer(cpu) (&per_cpu(stt, (cpu)))
+#define STOP_IDLE_TRIGGER     (1)
+#define PERIODIC_TICK_TRIGGER (2)
+#define TICK_INTVAL	(1000000ULL)
+/*
+ * restart hrtimer while resume from idle. scheduler tick may resume after 4ms,
+ * so we can't restart hrtimer in scheduler tick.
+ */
+static DEFINE_PER_CPU(u8, trigger_event);
+
+/*
+ * Implement 1ms tick by inserting 3 hrtimer ticks to schduler tick.
+ * stop hrtimer when tick reachs 4, then restart it at scheduler timer handler.
+ */
+static DEFINE_PER_CPU(u8, tick_phase);
+
+static inline void highres_timer_ctrl(bool enable, int cpu)
+{
+	if (enable && hmbird_enabled()) {
+		if (!hrtimer_active(shadow_tick_timer(cpu)))
+			hrtimer_start(shadow_tick_timer(cpu),
+				ns_to_ktime(TICK_INTVAL), HRTIMER_MODE_REL_PINNED);
+	} else {
+		if (!enable)
+			hrtimer_cancel(shadow_tick_timer(cpu));
+	}
+}
+
+static inline void high_res_clear_phase(int cpu)
+{
+	per_cpu(tick_phase, cpu) = 0;
+}
+
+static enum hrtimer_restart highres_next_phase(int cpu, struct hrtimer *timer)
+{
+	per_cpu(tick_phase, cpu) = ++per_cpu(tick_phase, cpu) % 3;
+	if (per_cpu(tick_phase, cpu)) {
+		hrtimer_forward_now(timer, ns_to_ktime(TICK_INTVAL));
+		return HRTIMER_RESTART;
+	}
+	return HRTIMER_NORESTART;
+}
+
+void sched_switch_handler(void *data, bool preempt, struct task_struct *prev,
+		struct task_struct *next, unsigned int prev_state)
+{
+	int cpu = smp_processor_id();
+
+	if (shadow_tick_enable() && (cpu_rq(cpu)->idle == prev)) {
+		per_cpu(trigger_event, cpu) = STOP_IDLE_TRIGGER;
+		high_res_clear_phase(cpu);
+		highres_timer_ctrl(true, cpu);
+	}
+}
+
+static enum hrtimer_restart scheduler_tick_no_balance(struct hrtimer *timer)
+{
+	int cpu = smp_processor_id();
+	struct rq *rq = cpu_rq(cpu);
+	struct task_struct *curr = rq->curr;
+	struct rq_flags rf;
+
+	rq_lock(rq, &rf);
+	update_rq_clock(rq);
+	curr->sched_class->task_tick(rq, curr, 0);
+	rq_unlock(rq, &rf);
+
+	return highres_next_phase(cpu, timer);
+}
+
+void shadow_tick_timer_init(void)
+{
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		hrtimer_init(shadow_tick_timer(cpu), CLOCK_MONOTONIC, HRTIMER_MODE_REL_PINNED);
+		shadow_tick_timer(cpu)->function = &scheduler_tick_no_balance;
+	}
+}
+
+void start_shadow_tick_timer(void)
+{
+	int cpu = smp_processor_id();
+
+	if (shadow_tick_enable()) {
+		if (per_cpu(trigger_event, cpu) == STOP_IDLE_TRIGGER)
+			highres_timer_ctrl(false, cpu);
+		per_cpu(trigger_event, cpu) = PERIODIC_TICK_TRIGGER;
+		high_res_clear_phase(cpu);
+		highres_timer_ctrl(true, cpu);
+	}
+}
+
+static void stop_shadow_tick_timer(void)
+{
+	int cpu = smp_processor_id();
+
+	per_cpu(trigger_event, cpu) = 0;
+	high_res_clear_phase(cpu);
+	highres_timer_ctrl(false, cpu);
+}
+
+void android_vh_tick_nohz_idle_stop_tick_handler(void *unused, void *data)
+{
+	if (!shadow_tick_timer_init_flag)
+		return;
+	stop_shadow_tick_timer();
+}
+
+void scheduler_tick_handler(void *unused, struct rq *rq)
+{
+	if (!shadow_tick_timer_init_flag)
+		return;
+	start_shadow_tick_timer();
+}
+
+static int __init hmbird_shadow_tick_init(void)
+{
+	int ret = 0;
+
+	if (get_hmbird_version_type() != HMBIRD_OGKI_VERSION)
+		return 0;
+	shadow_tick_timer_init();
+	shadow_tick_timer_init_flag = true;
+	return ret;
+}
+
+device_initcall(hmbird_shadow_tick_init);
diff --git a/kernel/sched/hmbird/hmbird_shadow_tick.h b/kernel/sched/hmbird/hmbird_shadow_tick.h
new file mode 100755
index 000000000000..0c26fd984f0a
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_shadow_tick.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __HMBIRD_SHADOW_TICK_H__
+#define __HMBIRD_SHADOW_TICK_H__
+
+#include <linux/sched.h>
+
+void android_vh_tick_nohz_idle_stop_tick_handler(void *unused, void *data);
+void scheduler_tick_handler(void *unused, struct rq *rq);
+void sched_switch_handler(void *data, bool preempt, struct task_struct *prev,
+		struct task_struct *next, unsigned int prev_state);
+#endif
diff --git a/kernel/sched/hmbird/hmbird_trace.h b/kernel/sched/hmbird/hmbird_trace.h
new file mode 100755
index 000000000000..8468b406f347
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_trace.h
@@ -0,0 +1,92 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM hmbird
+
+#if !defined(_TRACE_HMBIRD_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_HMBIRD_H
+
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/tracepoint.h>
+
+#define MAX_FATAL_INFO (64)
+
+TRACE_EVENT(hmbird_fatal_info,
+
+	TP_PROTO(unsigned int type, int pe, int lnr, int bnr, char *info),
+
+	TP_ARGS(type, pe, lnr, bnr, info),
+
+	TP_STRUCT__entry(
+		__field(unsigned int, type)
+		__field(int, pe)
+		__field(int, lnr)
+		__field(int, bnr)
+		__array(char, info, MAX_FATAL_INFO)),
+
+	TP_fast_assign(
+		__entry->type = type;
+		__entry->pe = pe;
+		__entry->lnr = lnr;
+		__entry->bnr = bnr;
+		memcpy(__entry->info, info, MAX_FATAL_INFO);),
+
+	TP_printk("hmbird fatal error type=%u pe=%d lnr=%d bnr=%d info=%s",
+		__entry->type, __entry->pe, __entry->lnr, __entry->bnr,
+		__entry->info)
+);
+
+TRACE_EVENT(hmbird_update_history,
+
+	TP_PROTO(struct hmbird_entity *hmbird, struct rq *rq,
+		struct task_struct *p, u32 runtime, int samples, int event),
+
+	TP_ARGS(hmbird, rq, p, runtime, samples, event),
+
+	TP_STRUCT__entry(
+		__array(char,			comm, TASK_COMM_LEN)
+		__field(pid_t,			pid)
+		__field(unsigned int,		runtime)
+		__field(int,			samples)
+		__field(int,	event)
+		__field(unsigned int,		demand)
+		__array(u32,			hist, RAVG_HIST_SIZE)
+		__field(u16,			task_util)
+		__field(int,			cpu)),
+
+	TP_fast_assign(
+		memcpy(__entry->comm, p->comm, TASK_COMM_LEN);
+		__entry->pid		= p->pid;
+		__entry->runtime	= runtime;
+		__entry->samples	= samples;
+		__entry->event		= event;
+		__entry->demand		= hmbird->sts.demand;
+		memcpy(__entry->hist, hmbird->sts.sum_history,
+					RAVG_HIST_SIZE * sizeof(u32));
+		__entry->task_util	= hmbird->sts.demand_scaled;
+		__entry->cpu		= rq->cpu;),
+
+	TP_printk("comm=%s[%d]: runtime %u samples %d event %d demand %u (hist: %u %u %u %u %u) task_util %u cpu %d",
+		__entry->comm, __entry->pid,
+		__entry->runtime, __entry->samples,
+		__entry->event,
+		__entry->demand,
+		__entry->hist[0], __entry->hist[1],
+		__entry->hist[2], __entry->hist[3],
+		__entry->hist[4],
+		__entry->task_util,
+		__entry->cpu)
+);
+
+#endif /*_TRACE_HMBIRD_H */
+
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH ../../kernel/sched/hmbird
+
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE hmbird_trace
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/kernel/sched/hmbird/hmbird_util_track.c b/kernel/sched/hmbird/hmbird_util_track.c
new file mode 100755
index 000000000000..d520a8403401
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_util_track.c
@@ -0,0 +1,626 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024 Oplus. All rights reserved.
+ */
+#include "hmbird_sched.h"
+#include "hmbird_util_track.h"
+
+#define CREATE_TRACE_POINTS
+#include "hmbird_trace.h"
+#undef CREATE_TRACE_POINTS
+
+#define HMBIRD_DEBUG_PANIC		(1 << 3)
+static bool init_irq_work_inited;
+
+extern noinline int tracing_mark_write(const char *buf);
+
+int hmbird_sched_ravg_window = 8000000;
+int new_hmbird_sched_ravg_window = 8000000;
+DEFINE_SPINLOCK(new_sched_ravg_window_lock);
+DEFINE_PER_CPU(struct hmbird_sched_rq_stats, hmbird_sched_rq_stats);
+
+
+static struct irq_work hmbird_slim_walt_irq_work;
+
+/*Sysctl related interface*/
+#define WINDOW_STATS_RECENT		0
+#define WINDOW_STATS_MAX		1
+#define WINDOW_STATS_MAX_RECENT_AVG	2
+#define WINDOW_STATS_AVG		3
+#define WINDOW_STATS_INVALID_POLICY	4
+
+
+#define SCX_SCHED_CAPACITY_SHIFT  10
+#define SCHED_ACCOUNT_WAIT_TIME 0
+
+atomic64_t hmbird_irq_work_lastq_ws;
+static u64 tick_sched_clock;
+
+static inline u64 scale_exec_time(u64 delta, struct rq *rq)
+{
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+
+	return (delta * srq->task_exec_scale) >> SCX_SCHED_CAPACITY_SHIFT;
+}
+
+static inline u64 scale_time_to_util(u64 d)
+{
+	do_div(d, hmbird_sched_ravg_window >> SCX_SCHED_CAPACITY_SHIFT);
+	return d;
+}
+
+static u64 add_to_task_demand(struct rq *rq, struct task_struct *p, u64 delta)
+{
+	struct hmbird_sched_task_stats *sts = &(get_hmbird_ts(p)->sts);
+
+	delta = scale_exec_time(delta, rq);
+	sts->sum += delta;
+	if (unlikely(sts->sum > hmbird_sched_ravg_window))
+		sts->sum = hmbird_sched_ravg_window;
+
+	return delta;
+}
+
+
+static int
+account_busy_for_task_demand(struct rq *rq, struct task_struct *p, int event)
+{
+	/*
+	 * No need to bother updating task demand for the idle task.
+	 */
+	if (is_idle_task(p))
+		return 0;
+
+	/*
+	 * When a task is waking up it is completing a segment of non-busy
+	 * time. Likewise, if wait time is not treated as busy time, then
+	 * when a task begins to run or is migrated, it is not running and
+	 * is completing a segment of non-busy time.
+	 */
+	if (event == TASK_WAKE || (!SCHED_ACCOUNT_WAIT_TIME &&
+			 (event == PICK_NEXT_TASK || event == TASK_MIGRATE)))
+		return 0;
+
+	/*
+	 * The idle exit time is not accounted for the first task _picked_ up to
+	 * run on the idle CPU.
+	 */
+	if (event == PICK_NEXT_TASK && rq->curr == rq->idle)
+		return 0;
+
+	/*
+	 * TASK_UPDATE can be called on sleeping task, when its moved between
+	 * related groups
+	 */
+	if (event == TASK_UPDATE) {
+		if (rq->curr == p)
+			return 1;
+
+		return p->on_rq ? SCHED_ACCOUNT_WAIT_TIME : 0;
+	}
+
+	return 1;
+}
+
+static void rollover_cpu_window(struct rq *rq, bool full_window)
+{
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+	u64 curr_sum = srq->curr_runnable_sum;
+
+	if (unlikely(full_window))
+		curr_sum = 0;
+
+	srq->prev_runnable_sum = curr_sum;
+	srq->curr_runnable_sum = 0;
+}
+
+static u64
+update_window_start(struct rq *rq, u64 wallclock, int event)
+{
+	s64 delta;
+	int nr_windows;
+	bool full_window;
+
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+	u64 old_window_start = srq->window_start;
+
+	if (wallclock < srq->latest_clock)
+		wallclock = srq->latest_clock;
+	delta = wallclock - srq->window_start;
+	if (delta < 0) {
+		delta = 0;
+		wallclock = srq->window_start;
+	}
+	srq->latest_clock = wallclock;
+	if (delta < hmbird_sched_ravg_window)
+		return old_window_start;
+
+	nr_windows = div64_u64(delta, hmbird_sched_ravg_window);
+	srq->window_start += (u64)nr_windows * (u64)hmbird_sched_ravg_window;
+
+	srq->prev_window_size = hmbird_sched_ravg_window;
+	full_window = nr_windows > 1;
+	rollover_cpu_window(rq, full_window);
+
+	return old_window_start;
+}
+
+#define DIV64_U64_ROUNDUP(X, Y) div64_u64((X) + (Y - 1), Y)
+
+static inline unsigned int get_max_freq(unsigned int cpu)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);
+
+	return (policy == NULL) ? 0 : policy->cpuinfo.max_freq;
+}
+
+static inline unsigned int cpu_cur_freq(int cpu)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);
+
+	return (policy == NULL) ? 0 : policy->cur;
+}
+
+static void
+update_task_rq_cpu_cycles(struct task_struct *p, struct rq *rq, int event,
+			  u64 wallclock)
+{
+	int cpu = cpu_of(rq);
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+
+	srq->task_exec_scale = DIV64_U64_ROUNDUP(cpu_cur_freq(cpu) *
+					arch_scale_cpu_capacity(cpu), get_max_freq(cpu));
+}
+
+/*
+ * Called when new window is starting for a task, to record cpu usage over
+ * recently concluded window(s). Normally 'samples' should be 1. It can be > 1
+ * when, say, a real-time task runs without preemption for several windows at a
+ * stretch.
+ */
+static void update_history(struct rq *rq, struct task_struct *p,
+			 u32 runtime, int samples, int event)
+{
+	struct hmbird_sched_task_stats *sts = &(get_hmbird_ts(p)->sts);
+	u32 *hist = &sts->sum_history[0];
+	int i;
+	u32 max = 0, avg, demand;
+	u64 sum = 0;
+	u16 demand_scaled;
+
+	/* Ignore windows where task had no activity */
+	if (!runtime || is_idle_task(p) || !samples)
+		goto done;
+
+	/* Push new 'runtime' value onto stack */
+	for (; samples > 0; samples--) {
+		hist[sts->cidx] = runtime;
+		sts->cidx = ++(sts->cidx) % RAVG_HIST_SIZE;
+	}
+
+	for (i = 0; i < RAVG_HIST_SIZE; i++) {
+		sum += hist[i];
+		if (hist[i] > max)
+			max = hist[i];
+	}
+
+	sts->sum = 0;
+	avg = div64_u64(sum, RAVG_HIST_SIZE);
+
+	switch (slim_walt_policy) {
+	case WINDOW_STATS_RECENT:
+		demand = runtime;
+		break;
+	case WINDOW_STATS_MAX:
+		demand = max;
+		break;
+	case WINDOW_STATS_AVG:
+		demand = avg;
+		break;
+	default:
+		demand = max(avg, runtime);
+	}
+
+	demand_scaled = scale_time_to_util(demand);
+
+	sts->demand = demand;
+	sts->demand_scaled = demand_scaled;
+
+done:
+	return;
+}
+
+
+static u64 update_task_demand(struct task_struct *p, struct rq *rq,
+			       int event, u64 wallclock)
+{
+	struct hmbird_sched_task_stats *sts = &(get_hmbird_ts(p)->sts);
+
+	u64 mark_start = sts->mark_start;
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+
+
+	u64 delta, window_start = srq->window_start;
+	int new_window, nr_full_windows;
+	u32 window_size = hmbird_sched_ravg_window;
+	u64 runtime;
+
+	new_window = mark_start < window_start;
+	if (!account_busy_for_task_demand(rq, p, event)) {
+		if (new_window)
+			/*
+			 * If the time accounted isn't being accounted as
+			 * busy time, and a new window started, only the
+			 * previous window need be closed out with the
+			 * pre-existing demand. Multiple windows may have
+			 * elapsed, but since empty windows are dropped,
+			 * it is not necessary to account those.
+			 */
+			update_history(rq, p, sts->sum, 1, event);
+		return 0;
+	}
+
+	if (!new_window) {
+		/*
+		 * The simple case - busy time contained within the existing
+		 * window.
+		 */
+		return add_to_task_demand(rq, p, wallclock - mark_start);
+	}
+
+	/*
+	 * Busy time spans at least two windows. Temporarily rewind
+	 * window_start to first window boundary after mark_start.
+	 */
+	delta = window_start - mark_start;
+	nr_full_windows = div64_u64(delta, window_size);
+	window_start -= (u64)nr_full_windows * (u64)window_size;
+
+	/* Process (window_start - mark_start) first */
+	runtime = add_to_task_demand(rq, p, window_start - mark_start);
+
+	/* Push new sample(s) into task's demand history */
+	update_history(rq, p, sts->sum, 1, event);
+	if (nr_full_windows) {
+		u64 scaled_window = scale_exec_time(window_size, rq);
+
+		update_history(rq, p, scaled_window, nr_full_windows, event);
+		runtime += nr_full_windows * scaled_window;
+	}
+
+	/*
+	 * Roll window_start back to current to process any remainder
+	 * in current window.
+	 */
+	window_start += (u64)nr_full_windows * (u64)window_size;
+
+	/* Process (wallclock - window_start) next */
+	mark_start = window_start;
+	runtime += add_to_task_demand(rq, p, wallclock - mark_start);
+
+	return runtime;
+}
+
+u16 slim_walt_cpu_util(int cpu)
+{
+	u64 prev_runnable_sum;
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu);
+
+	prev_runnable_sum = srq->prev_runnable_sum;
+	do_div(prev_runnable_sum, srq->prev_window_size >> SCX_SCHED_CAPACITY_SHIFT);
+
+	return (u16)prev_runnable_sum;
+}
+
+static DEFINE_PER_CPU(u16, prev_cpu_util);
+static inline void cpu_util_update_systrace_c(int cpu)
+{
+	char buf[256];
+	u16 cpu_util = slim_walt_cpu_util(cpu);
+
+	if (cpu_util != per_cpu(prev_cpu_util, cpu)) {
+		snprintf(buf, sizeof(buf), "C|9999|Cpu%d_util|%u\n",
+						cpu, cpu_util);
+		tracing_mark_write(buf);
+		per_cpu(prev_cpu_util, cpu) = cpu_util;
+	}
+}
+
+
+static inline int account_busy_for_cpu_time(struct rq *rq,
+					    struct task_struct *p,
+					    int event)
+{
+	return !is_idle_task(p) && (event == PUT_PREV_TASK
+					|| event == TASK_UPDATE);
+}
+
+
+static void update_cpu_busy_time(struct task_struct *p, struct rq *rq,
+				 int event, u64 wallclock)
+{
+	int new_window, full_window = 0;
+	struct hmbird_sched_task_stats *sts = &(get_hmbird_ts(p)->sts);
+	u64 mark_start = sts->mark_start;
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+	u64 window_start = srq->window_start;
+	u32 window_size = srq->prev_window_size;
+	u64 delta;
+	u64 *curr_runnable_sum = &srq->curr_runnable_sum;
+	u64 *prev_runnable_sum = &srq->prev_runnable_sum;
+
+	new_window = mark_start < window_start;
+	if (new_window)
+		full_window = (window_start - mark_start) >= window_size;
+
+
+	if (!account_busy_for_cpu_time(rq, p, event))
+		goto done;
+
+
+	if (!new_window) {
+		/*
+		 * account_busy_for_cpu_time() = 1 so busy time needs
+		 * to be accounted to the current window. No rollover
+		 * since we didn't start a new window. An example of this is
+		 * when a task starts execution and then sleeps within the
+		 * same window.
+		 */
+		delta = wallclock - mark_start;
+
+		delta = scale_exec_time(delta, rq);
+		*curr_runnable_sum += delta;
+
+		goto done;
+	}
+
+	/*
+	 * situations below this need window rollover,
+	 * Rollover of cpu counters (curr/prev_runnable_sum) should have already be done
+	 * in update_window_start()
+	 *
+	 * For task counters curr/prev_window[_cpu] are rolled over in the early part of
+	 * this function. If full_window(s) have expired and time since last update needs
+	 * to be accounted as busy time, set the prev to a complete window size time, else
+	 * add the prev window portion.
+	 *
+	 * For task curr counters a new window has begun, always assign
+	 */
+
+	/*
+	 * account_busy_for_cpu_time() = 1 so busy time needs
+	 * to be accounted to the current window. A new window
+	 * must have been started in udpate_window_start()
+	 * If any of these three above conditions are true
+	 * then this busy time can't be accounted as irqtime.
+	 *
+	 * Busy time for the idle task need not be accounted.
+	 *
+	 * An example of this would be a task that starts execution
+	 * and then sleeps once a new window has begun.
+	 */
+
+	/*
+	 * A full window hasn't elapsed, account partial
+	 * contribution to previous completed window.
+	 */
+
+
+	delta = full_window ? scale_exec_time(window_size, rq) :
+				scale_exec_time(window_start - mark_start, rq);
+
+	*prev_runnable_sum += delta;
+
+	/* Account piece of busy time in the current window. */
+	delta = scale_exec_time(wallclock - window_start, rq);
+	*curr_runnable_sum += delta;
+
+done:
+	if (slim_walt_dump && new_window)
+		cpu_util_update_systrace_c(rq->cpu);
+}
+
+
+void slim_walt_window_rollover_run_once(u64 old_window_start, struct rq *rq)
+{
+	u64 result;
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+	u64 new_window_start = srq->window_start;
+
+	if (old_window_start == new_window_start)
+		return;
+
+	result = atomic64_cmpxchg(&hmbird_irq_work_lastq_ws,
+					old_window_start, new_window_start);
+	if (result != old_window_start)
+		return;
+
+	if (likely(cpu_online(raw_smp_processor_id())))
+		irq_work_queue(&hmbird_slim_walt_irq_work);
+	else
+		irq_work_queue_on(&hmbird_slim_walt_irq_work, cpumask_any(cpu_online_mask));
+}
+
+/*
+ * In the core scheduler, most of the load update points update the rq_clock after
+ * holding the rq lock. We can directly use rq_clock to reduce the overhead of
+ * obtaining the time, but to prevent the subsequent migration of the load update
+ * point to before the update of rq_clock, we wrap the judgment of the rq_clock
+ * update here.
+ */
+void hmbird_update_task_ravg_rqclock_wrapper(struct task_struct *p,
+				struct rq *rq, int event)
+{
+	if (!(rq->clock_update_flags & RQCF_UPDATED))
+		update_rq_clock(rq);
+
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+
+	hmbird_update_task_ravg(p, rq, event, max(rq_clock(rq), srq->latest_clock));
+}
+
+void hmbird_update_task_ravg(struct task_struct *p,
+				struct rq *rq, int event, u64 wallclock)
+{
+	struct hmbird_sched_task_stats *sts = &(get_hmbird_ts(p)->sts);
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+	u64 old_window_start;
+
+	if (!slim_walt_ctrl)
+		return;
+
+	if (!srq->window_start || sts->mark_start == wallclock)
+		return;
+
+	old_window_start = update_window_start(rq, wallclock, event);
+
+	if (!sts->window_start)
+		sts->window_start = srq->window_start;
+
+	if (!sts->mark_start)
+		goto done;
+
+	update_task_rq_cpu_cycles(p, rq, event, wallclock);
+	update_task_demand(p, rq, event, wallclock);
+	update_cpu_busy_time(p, rq, event, wallclock);
+
+	sts->window_start = srq->window_start;
+
+done:
+	sts->mark_start = wallclock;
+	slim_walt_window_rollover_run_once(old_window_start, rq);
+}
+
+static void slim_walt_irq_work(struct irq_work *irq_work)
+{
+	cpumask_t lock_cpus;
+	struct hmbird_sched_rq_stats *srq;
+	struct rq *rq;
+	int cpu;
+	int level = 0;
+	u64 wc;
+	unsigned long flags;
+
+	cpumask_copy(&lock_cpus, cpu_possible_mask);
+
+	for_each_cpu(cpu, &lock_cpus) {
+		if (level == 0)
+			raw_spin_lock(&cpu_rq(cpu)->__lock);
+		else
+			raw_spin_lock_nested(&cpu_rq(cpu)->__lock, level);
+		level++;
+	}
+
+	wc = sched_clock();
+
+	for_each_cpu(cpu, &lock_cpus) {
+		rq = cpu_rq(cpu);
+		hmbird_update_task_ravg(rq->curr, rq, TASK_UPDATE, wc);
+	}
+
+	cpufreq_update_util(cpu_rq(0), HMBIRD_CPUFREQ_WINDOW_ROLLOVER);
+	spin_lock_irqsave(&new_sched_ravg_window_lock, flags);
+	if (unlikely(new_hmbird_sched_ravg_window != hmbird_sched_ravg_window)) {
+		srq = &per_cpu(hmbird_sched_rq_stats, smp_processor_id());
+		if (wc < srq->window_start + new_hmbird_sched_ravg_window)
+			hmbird_sched_ravg_window = new_hmbird_sched_ravg_window;
+	}
+	spin_unlock_irqrestore(&new_sched_ravg_window_lock, flags);
+
+	for_each_cpu(cpu, &lock_cpus) {
+		raw_spin_unlock(&cpu_rq(cpu)->__lock);
+	}
+}
+static void hmbird_sched_init_rq(struct rq *rq)
+{
+	struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu_of(rq));
+
+	srq->prev_window_size = hmbird_sched_ravg_window;
+	srq->task_exec_scale = 1024;
+	srq->window_start = 0;
+}
+
+void hmbird_sched_init_task(struct task_struct *p)
+{
+	struct hmbird_sched_task_stats *sts = &(get_hmbird_ts(p)->sts);
+
+	memset(sts, 0, sizeof(struct hmbird_sched_task_stats));
+}
+
+static void hmbird_sched_stats_init(void)
+{
+	unsigned long flags;
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct rq *rq = cpu_rq(cpu);
+
+		raw_spin_lock_irqsave(&rq->__lock, flags);
+		hmbird_sched_init_rq(rq);
+		raw_spin_unlock_irqrestore(&rq->__lock, flags);
+	}
+	slim_walt_policy = WINDOW_STATS_MAX_RECENT_AVG;
+
+	if (false == init_irq_work_inited) {
+		init_irq_work(&hmbird_slim_walt_irq_work, slim_walt_irq_work);
+		init_irq_work_inited = true;
+	}
+}
+
+void hmbird_scheduler_tick(void)
+{
+	int cpu = smp_processor_id();
+	struct rq *rq = cpu_rq(cpu);
+
+	if (unlikely(!tick_sched_clock)) {
+		/*
+		 * Let the window begin 20us prior to the tick,
+		 * that way we are guaranteed a rollover when the tick occurs.
+		 * Use rq->clock directly instead of rq_clock() since
+		 * we do not have the rq lock and
+		 * rq->clock was updated in the tick callpath.
+		 */
+		if (cmpxchg64(&tick_sched_clock, 0, rq->clock - 20000))
+			return;
+		for_each_possible_cpu(cpu) {
+			struct hmbird_sched_rq_stats *srq = &per_cpu(hmbird_sched_rq_stats, cpu);
+
+			srq->window_start = tick_sched_clock;
+		}
+		atomic64_set(&hmbird_irq_work_lastq_ws, tick_sched_clock);
+	}
+}
+
+void slim_walt_enable(int enable)
+{
+	if (1 == !!enable) {
+		hmbird_sched_stats_init();
+		WRITE_ONCE(tick_sched_clock, 0);
+	} else
+		slim_walt_ctrl = 0;
+}
+
+void slim_get_cpu_util(int cpu, u64 *util)
+{
+	if (cpu < 0)
+		return;
+
+	*util = slim_walt_cpu_util(cpu);
+}
+
+void slim_get_task_util(struct task_struct *p, u64 *util)
+{
+	if (p == NULL)
+		return;
+
+	*util = get_hmbird_ts(p)->sts.demand_scaled;
+}
+
+void sched_ravg_window_change(int frame_per_sec)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&new_sched_ravg_window_lock, flags);
+	new_hmbird_sched_ravg_window = NSEC_PER_SEC / frame_per_sec;
+	spin_unlock_irqrestore(&new_sched_ravg_window_lock, flags);
+}
diff --git a/kernel/sched/hmbird/hmbird_util_track.h b/kernel/sched/hmbird/hmbird_util_track.h
new file mode 100755
index 000000000000..17b85df7f83b
--- /dev/null
+++ b/kernel/sched/hmbird/hmbird_util_track.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * HMBIRD scheduler class
+ *
+ * Copyright (c) 2024 OPlus.
+ * Copyright (c) 2024 Dao Huang
+ * Copyright (c) 2024 Yuxing Wang
+ * Copyright (c) 2024 Taiyu Li
+ */
+#ifndef __HMBIRD_UTIL_TRACK_H__
+#define __HMBIRD_UTIL_TRACK_H__
+
+void hmbird_update_task_ravg(struct task_struct *p,
+				struct rq *rq, int event, u64 wallclock);
+void hmbird_sched_init_task(struct task_struct *p);
+void slim_walt_enable(int enable);
+void slim_get_cpu_util(int cpu, u64 *util);
+void slim_get_task_util(struct task_struct *p, u64 *util);
+
+extern atomic64_t hmbird_irq_work_lastq_ws;
+
+enum task_event {
+	PUT_PREV_TASK   = 0,
+	PICK_NEXT_TASK  = 1,
+	TASK_WAKE       = 2,
+	TASK_MIGRATE    = 3,
+	TASK_UPDATE     = 4,
+	IRQ_UPDATE      = 5,
+};
+
+extern DEFINE_PER_CPU(struct hmbird_sched_rq_stats, hmbird_sched_rq_stats);
+
+#endif /* __HMBIRD_UTIL_TRACK_H__ */
diff --git a/kernel/sched/hmbird/slim.h b/kernel/sched/hmbird/slim.h
new file mode 100755
index 000000000000..eb386260e950
--- /dev/null
+++ b/kernel/sched/hmbird/slim.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __SLIM_H
+#define __SLIM_H
+
+extern atomic_t __hmbird_ops_enabled;
+extern atomic_t non_hmbird_task;
+extern int cgroup_ids_table[NUMS_CGROUP_KINDS];
+extern int heartbeat;
+extern int heartbeat_enable;
+extern int watchdog_enable;
+extern int isolate_ctrl;
+extern int parctrl_high_ratio;
+extern int parctrl_low_ratio;
+extern int isoctrl_high_ratio;
+extern int isoctrl_low_ratio;
+extern int iso_free_rescue;
+extern int yield_opt;
+
+extern enum hmbird_switch_type sw_type;
+extern noinline int tracing_mark_write(const char *buf);
+int task_top_id(struct task_struct *p);
+void stats_print(char *buf, int len);
+void hmbird_skip_yield(long *skip);
+extern spinlock_t hmbird_tasks_lock;
+
+struct yield_opt_params {
+	int enable;
+	int frame_per_sec;
+	u64 frame_time_ns;
+	int yield_headroom;
+};
+
+extern struct yield_opt_params yield_opt_params;
+
+#define MAX_GOV_LEN     (16)
+extern char saved_gov[NR_CPUS][MAX_GOV_LEN];
+
+#endif
diff --git a/kernel/sched/idle.c b/kernel/sched/idle.c
index 5007b25c5bc6..487255ac6832 100755
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@ -408,11 +408,17 @@ static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int fl
 
 static void put_prev_task_idle(struct rq *rq, struct task_struct *prev)
 {
+#ifdef CONFIG_HMBIRD_SCHED
+	hmbird_update_idle(rq, false);
+#endif
 }
 
 static void set_next_task_idle(struct rq *rq, struct task_struct *next, bool first)
 {
 	update_idle_core(rq);
+#ifdef CONFIG_HMBIRD_SCHED
+	hmbird_update_idle(rq, true);
+#endif
 	schedstat_inc(rq->sched_goidle);
 }
 
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 2b838a3a200a..8e438bfcec5a 100755
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -190,8 +190,11 @@ static inline int idle_policy(int policy)
 
 static inline int fair_policy(int policy)
 {
+#ifdef CONFIG_HMBIRD_SCHED
+	return policy == SCHED_HMBIRD || policy == SCHED_NORMAL || policy == SCHED_BATCH;
+#else
 	return policy == SCHED_NORMAL || policy == SCHED_BATCH;
-
+#endif
 }
 
 static inline int rt_policy(int policy)
@@ -239,7 +242,8 @@ static inline void update_avg(u64 *avg, u64 sample)
 #define shr_bound(val, shift)							\
 	(val >> min_t(typeof(shift), shift, BITS_PER_TYPE(typeof(val)) - 1))
 
-/* 
+
+/*
  * !! For sched_setattr_nocheck() (kernel) only !!
  *
  * This is actually gross. :(
@@ -506,6 +510,12 @@ static inline void set_task_rq_fair(struct sched_entity *se,
 			     struct cfs_rq *prev, struct cfs_rq *next) { }
 #endif /* CONFIG_SMP */
 #else /* CONFIG_FAIR_GROUP_SCHED */
+#ifdef CONFIG_HMBIRD_SCHED
+static inline int sched_group_set_shares(struct task_group *tg, unsigned long shares)
+{
+	return 0;
+}
+#endif
 #endif /* CONFIG_FAIR_GROUP_SCHED */
 
 #else /* CONFIG_CGROUP_SCHED */
@@ -3600,5 +3610,8 @@ static inline bool cpu_busy_with_softirqs(int cpu)
 }
 #endif /* CONFIG_RT_SOFTIRQ_AWARE_SCHED */
 
+#ifdef CONFIG_HMBIRD_SCHED
+#include "hmbird.h"
+#endif
 
 #endif /* _KERNEL_SCHED_SCHED_H */
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 998c2eefe173..2a3f819b9e88 100755
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -34,6 +34,10 @@
 
 #include <trace/events/timer.h>
 
+#ifdef CONFIG_HMBIRD_SCHED
+#include "../sched/hmbird/hmbird_shadow_tick.h"
+#endif
+
 /*
  * Per-CPU nohz control structure
  */
@@ -1112,6 +1116,9 @@ static bool can_stop_idle_tick(int cpu, struct tick_sched *ts)
 	return true;
 }
 
+#ifdef CONFIG_HMBIRD_SCHED
+extern void android_vh_tick_nohz_idle_stop_tick_handler(void *unused, void *data);
+#endif
 /**
  * tick_nohz_idle_stop_tick - stop the idle tick from the idle task
  *
@@ -1124,6 +1131,9 @@ void tick_nohz_idle_stop_tick(void)
 	ktime_t expires;
 
 	trace_android_vh_tick_nohz_idle_stop_tick(NULL);
+#ifdef CONFIG_HMBIRD_SCHED
+	android_vh_tick_nohz_idle_stop_tick_handler(NULL,NULL);
+#endif
 	/*
 	 * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the
 	 * tick timer expiration time is known already.
diff --git a/kernel/sched/hmbird/hmbird.c b/kernel/sched/hmbird/hmbird.c
index ce05928392bf..f47f79079297 100755
--- a/kernel/sched/hmbird/hmbird.c
+++ b/kernel/sched/hmbird/hmbird.c
@@ -633,14 +633,14 @@ static void init_isolate_cpus(void)
 	WARN_ON(!alloc_cpumask_var(&iso_masks.exclusive, GFP_KERNEL));
 	WARN_ON(!alloc_cpumask_var(&iso_masks.big, GFP_KERNEL));
 	WARN_ON(!alloc_cpumask_var(&iso_masks.little, GFP_KERNEL));
-	cpumask_set_cpu(0, iso_masks.big);
-	cpumask_set_cpu(1, iso_masks.big);
-	cpumask_set_cpu(2, iso_masks.big);
-	cpumask_set_cpu(3, iso_masks.big);
-	cpumask_set_cpu(4, iso_masks.big);
-	cpumask_set_cpu(5, iso_masks.ex_free);
+	cpumask_set_cpu(0, iso_masks.little);
+	cpumask_set_cpu(1, iso_masks.little);
+	cpumask_set_cpu(2, iso_masks.little);
+	cpumask_set_cpu(3, iso_masks.little);
+	cpumask_set_cpu(4, iso_masks.little);
+	cpumask_set_cpu(5, iso_masks.little);
 	cpumask_set_cpu(6, iso_masks.partial);
-	cpumask_set_cpu(7, iso_masks.ex_free);
+	cpumask_set_cpu(7, iso_masks.big);
 }
 
 extern spinlock_t css_set_lock;
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 716788a51a5e..a258adcea40c 100755
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4917,7 +4917,6 @@ late_initcall(sched_core_sysctl_init);
  */
 int sched_fork(unsigned long clone_flags, struct task_struct *p)
 {
-
 #ifdef CONFIG_HMBIRD_SCHED
 	int ret;
 #endif
@@ -4973,7 +4972,7 @@ int sched_fork(unsigned long clone_flags, struct task_struct *p)
 		p->sched_class = &hmbird_sched_class;
 	} else if (rt_prio(p->prio)) {
 		p->sched_class = &rt_sched_class;
-	else
+	} else {
 		p->sched_class = &fair_sched_class;
 	}
 #else
@@ -6291,6 +6290,7 @@ __pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
 		if (p) {
 			hmbird_notify_pick_next_task(rq, p, class);
 			return p;
+		}
 	}
 #else
 	for_each_class(class) {
